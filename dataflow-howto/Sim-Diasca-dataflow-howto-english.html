<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.13.1: http://docutils.sourceforge.net/" />
<title>Sim-Diasca Dataflow HOWTO</title>
<meta content="Sim-Diasca, dataflow, how-to, block" name="keywords" />
<link rel="stylesheet" href="pygments-default.css" type="text/css" />
<link rel="stylesheet" href="sim-diasca.css" type="text/css" />
<link href="sim-diasca-icon.png" rel="icon">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
<div class="document" id="sim-diasca-dataflow-howto">
<h1 class="title">Sim-Diasca Dataflow HOWTO</h1>

<p><span class="raw-html"><a name="sim_diasca_top"></a></span></p>
<p><span class="raw-html"><center><table><tr colspan="2"><center><img src="sim-diasca.png" style="width:500px"></center></tr><tr><td><center><img src="logo-EDF-english.png" style="width:150px"></center></td><td><center><img src="lgpl-v3-logo-bordered.png" style="width:140px"></center></td></tr></table></span></p>
<p></p>
<p><span class="raw-html"><div class="banner"><p><em>Sim-Diasca Dataflow HOWTO</em> <a href="https://olivier-boudeville-edf.github.io/Sim-Diasca/">browse latest</a> <a href="Sim-Diasca-dataflow-howto-english.pdf">get PDF</a> <a href="#sim_diasca_top">go to top</a> <a href="#sim_diasca_toc">go to toc</a> <a href="#sim_diasca_bottom">go to bottom</a> <a href="https://github.com/Olivier-Boudeville-EDF/Sim-Diasca">go to project</a> <a href="mailto:olivier(dot)boudeville(at)edf(dot)fr?subject=[Sim-Diasca]%20Remark">email us</a></p></div></span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Organisation:</th><td class="field-body">Copyright (C) 2016-2022 EDF R&amp;D</td>
</tr>
<tr class="field"><th class="field-name">Contact:</th><td class="field-body">olivier (dot) boudeville (at) edf (dot) fr</td>
</tr>
<tr class="field"><th class="field-name">Authors:</th><td class="field-body">Olivier Boudeville, Samuel Thiriot</td>
</tr>
<tr class="field"><th class="field-name">Creation Date:</th><td class="field-body">Thursday, February 25, 2016</td>
</tr>
<tr class="field"><th class="field-name">Lastly updated:</th><td class="field-body">Thursday, January 13, 2022</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">2.4.2</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Stable</td>
</tr>
<tr class="field"><th class="field-name">Website:</th><td class="field-body"><a class="reference external" href="http://sim-diasca.com">http://sim-diasca.com</a></td>
</tr>
<tr class="field"><th class="field-name">Dedication:</th><td class="field-body">For the implementers for Sim-Diasca dataflow-based models.</td>
</tr>
<tr class="field"><th class="field-name">Abstract:</th><td class="field-body">This document describes how dataflows, i.e. data-driven graphs of blocks, are to be defined and evaluated in the Sim-Diasca simulations relying on them.</td>
</tr>
</tbody>
</table>
<p><span class="raw-html"></center></span></p>
<p></p>
<p><span class="raw-html"><a name="sim_diasca_toc"></a></span></p>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first"><strong>Table of Contents</strong></p>
<ul class="simple">
<li><a class="reference internal" href="#foreword" id="id87">Foreword</a></li>
<li><a class="reference internal" href="#usual-organization-of-the-model-evaluation" id="id88">Usual Organization of the Model Evaluation</a></li>
<li><a class="reference internal" href="#an-alternate-mode-of-operation-the-dataflow" id="id89">An Alternate Mode of Operation: the Dataflow</a></li>
<li><a class="reference internal" href="#on-dataflows-experiments" id="id90">On Dataflows &amp; Experiments</a><ul>
<li><a class="reference internal" href="#dataflow-definition" id="id91">Dataflow Definition</a></li>
<li><a class="reference internal" href="#experiment-definition" id="id92">Experiment Definition</a></li>
</ul>
</li>
<li><a class="reference internal" href="#on-dataflow-processing-units" id="id93">On Dataflow Processing Units</a></li>
<li><a class="reference internal" href="#on-dataflow-ports-channels-and-buses" id="id94">On Dataflow Ports, Channels and Buses</a></li>
<li><a class="reference internal" href="#on-dataflow-values" id="id95">On Dataflow Values</a><ul>
<li><a class="reference internal" href="#type-of-a-value" id="id96">Type of a Value</a></li>
<li><a class="reference internal" href="#unit-of-a-value" id="id97">Unit of a Value</a></li>
<li><a class="reference internal" href="#semantics-of-a-value" id="id98">Semantics of a Value</a></li>
<li><a class="reference internal" href="#constraints-applying-to-a-value" id="id99">Constraints Applying to a Value</a></li>
<li><a class="reference internal" href="#accuracy-of-a-value" id="id100">Accuracy of a Value</a></li>
<li><a class="reference internal" href="#wrapping-up-about-values" id="id101">Wrapping Up About Values</a></li>
</ul>
</li>
<li><a class="reference internal" href="#logic-of-the-dataflow-block-activation" id="id102">Logic of the Dataflow Block Activation</a><ul>
<li><a class="reference internal" href="#the-activate-on-new-set-policy" id="id103">The 'Activate On New Set' Policy</a></li>
<li><a class="reference internal" href="#the-activate-when-all-set-policy" id="id104">The 'Activate When All Set' Policy</a></li>
<li><a class="reference internal" href="#custom-activation-policies" id="id105">Custom Activation Policies</a></li>
</ul>
</li>
<li><a class="reference internal" href="#on-dataflow-objects" id="id106">On Dataflow Objects</a></li>
<li><a class="reference internal" href="#on-model-assemblies" id="id107">On Model Assemblies</a><ul>
<li><a class="reference internal" href="#defining-the-notion-of-assembly" id="id108">Defining the Notion of Assembly</a></li>
<li><a class="reference internal" href="#ad-hoc-assemblies" id="id109">Ad-hoc Assemblies</a></li>
<li><a class="reference internal" href="#dynamic-composable-assemblies" id="id110">Dynamic, Composable Assemblies</a></li>
<li><a class="reference internal" href="#envisioned-extensions" id="id111">Envisioned Extensions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-more-complete-example" id="id112">A More Complete Example</a><ul>
<li><a class="reference internal" href="#a-view-onto-a-theoretical-simulation" id="id113">A View Onto a Theoretical Simulation</a></li>
<li><a class="reference internal" href="#a-view-onto-an-actual-simulation" id="id114">A View Onto an Actual Simulation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#developing-dataflow-elements-in-other-programming-languages" id="id115">Developing Dataflow Elements in Other Programming Languages</a><ul>
<li><a class="reference internal" href="#python-dataflow-binding" id="id116">Python Dataflow Binding</a></li>
<li><a class="reference internal" href="#java-dataflow-binding" id="id117">Java Dataflow Binding</a></li>
<li><a class="reference internal" href="#other-language-bindings" id="id118">Other Language Bindings</a></li>
</ul>
</li>
<li><a class="reference internal" href="#more-advanced-dataflow-uses" id="id119">More Advanced Dataflow Uses</a><ul>
<li><a class="reference internal" href="#dynamic-update-of-the-dataflow" id="id120">Dynamic Update of the Dataflow</a></li>
<li><a class="reference internal" href="#iteration-specification-iterated-ports" id="id121">Iteration Specification &amp; Iterated Ports</a></li>
<li><a class="reference internal" href="#domain-specific-timestamps" id="id122">Domain-Specific Timestamps</a></li>
<li><a class="reference internal" href="#usefulness-of-cyclic-dataflows" id="id123">Usefulness of Cyclic Dataflows?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#experiments" id="id124">Experiments</a><ul>
<li><a class="reference internal" href="#purpose-of-experiment-endpoints" id="id125">Purpose of Experiment Endpoints</a></li>
<li><a class="reference internal" href="#experiment-progress" id="id126">Experiment Progress</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-general-view-on-the-dataflow-synchronisation" id="id127">A General View on the Dataflow Synchronisation</a></li>
<li><a class="reference internal" href="#the-world-manager-and-its-dataflow-object-managers" id="id128">The World Manager and its Dataflow Object Managers</a><ul>
<li><a class="reference internal" href="#purpose-of-the-world-manager" id="id129">Purpose of the World Manager</a></li>
<li><a class="reference internal" href="#purpose-of-the-object-managers" id="id130">Purpose of the Object Managers</a></li>
<li><a class="reference internal" href="#expressing-dataflow-changes-through-world-events" id="id131">Expressing Dataflow Changes Through World Events</a></li>
<li><a class="reference internal" href="#changetrees-and-changesets" id="id132">Changetrees and Changesets</a></li>
<li><a class="reference internal" href="#changeset-crunching" id="id133">Changeset Crunching</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-experiment-manager-and-its-unit-managers" id="id134">The Experiment Manager and its Unit Managers</a><ul>
<li><a class="reference internal" href="#purpose-of-the-experiment-manager" id="id135">Purpose of the Experiment Manager</a></li>
<li><a class="reference internal" href="#purpose-of-the-unit-managers" id="id136">Purpose of the Unit Managers</a></li>
<li><a class="reference internal" href="#mode-of-operation" id="id137">Mode of Operation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#about-mock-up-units" id="id138">About Mock-up Units</a><ul>
<li><a class="reference internal" href="#definition-of-a-mock-up-unit" id="id139">Definition of a Mock-up Unit</a></li>
<li><a class="reference internal" href="#simulation-time-specification" id="id140">Simulation Time Specification</a></li>
<li><a class="reference internal" href="#input-match-specification" id="id141">Input Match Specification</a></li>
<li><a class="reference internal" href="#output-state-specification" id="id142">Output State Specification</a></li>
<li><a class="reference internal" href="#consistency-and-checking" id="id143">Consistency and Checking</a></li>
<li><a class="reference internal" href="#examples-of-a-mock-up-function" id="id144">Examples of a Mock-up Function</a></li>
<li><a class="reference internal" href="#data-based-mock-up-definition" id="id145">Data-Based Mock-up Definition</a></li>
<li><a class="reference internal" href="#mock-up-definition-from-a-spreadsheet" id="id146">Mock-up Definition from a Spreadsheet</a></li>
<li><a class="reference internal" href="#a-few-supplementary-pieces-of-advice" id="id147">A few Supplementary Pieces of Advice</a></li>
<li><a class="reference internal" href="#possible-enhancements" id="id148">Possible Enhancements</a></li>
</ul>
</li>
<li><a class="reference internal" href="#integrating-a-model-as-a-dataflow-a-short-walkthrough" id="id149">Integrating a Model As a Dataflow: a Short Walkthrough</a><ul>
<li><a class="reference internal" href="#preliminary-step-0-remembering-the-basics" id="id150">Preliminary Step (#0): Remembering the Basics</a></li>
<li><a class="reference internal" href="#step-1-ensure-that-the-overall-simulated-world-can-be-structured-as-a-dataflow" id="id151">Step #1: Ensure that the Overall Simulated World Can be Structured As a Dataflow</a></li>
<li><a class="reference internal" href="#step-2-determine-the-specific-relationships-between-the-dataflow-and-this-model" id="id152">Step #2: Determine the Specific Relationships Between the Dataflow and this Model</a></li>
<li><a class="reference internal" href="#step-3-break-the-black-box-into-actual-dataflow-units" id="id153">Step #3: Break the Black Box Into Actual Dataflow Units</a></li>
<li><a class="reference internal" href="#step-4-implement-the-corresponding-actual-units" id="id154">Step #4: Implement the Corresponding Actual Units</a></li>
<li><a class="reference internal" href="#step-5-add-the-corresponding-unit-manager-s" id="id155">Step #5: Add the Corresponding Unit Manager(s)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#requirements-for-the-dataflow-integration-of-a-model" id="id156">Requirements For the Dataflow Integration of a Model</a></li>
<li><a class="reference internal" href="#implementation-section" id="id157">Implementation Section</a><ul>
<li><a class="reference internal" href="#id80" id="id158">Mode of Operation</a></li>
<li><a class="reference internal" href="#usage-defining-one-s-dataflow" id="id159">Usage: Defining One's Dataflow</a></li>
<li><a class="reference internal" href="#class-or-instance-level-checking" id="id160">Class or Instance-level Checking</a></li>
<li><a class="reference internal" href="#scheduling-cycle-of-experiments" id="id161">Scheduling Cycle of Experiments</a></li>
<li><a class="reference internal" href="#life-cycle" id="id162">Life Cycle</a></li>
<li><a class="reference internal" href="#implementation-details" id="id163">Implementation Details</a></li>
</ul>
</li>
<li><a class="reference internal" href="#appendices" id="id164">Appendices</a><ul>
<li><a class="reference internal" href="#annex-1-design-questions" id="id165">Annex 1: Design Questions</a></li>
<li><a class="reference internal" href="#annex-2-possible-overall-improvements" id="id166">Annex 2: Possible Overall Improvements</a></li>
<li><a class="reference internal" href="#annex-3-conventions-for-the-graphical-representation-of-dataflows" id="id167">Annex 3: Conventions for the Graphical Representation of Dataflows</a></li>
<li><a class="reference internal" href="#annex-4-credits" id="id168">Annex 4: Credits</a></li>
</ul>
</li>
</ul>
</div>
<p></p>
<div class="section" id="foreword">
<h1><a class="toc-backref" href="#id87">Foreword</a></h1>
<p>The simulation of complex systems often relies on loosely-coupled agents exchanging signals based on a dynamic, potentially complex applicative protocol over a very flexible scheduling.</p>
<p>However, in some cases, the modelling activity results alternatively in the computations being at least partly described as <em>a static network of interconnected tasks that can send values to each other over channels</em> that applies to a simulated world - i.e. a <strong>dataflow</strong>.</p>
<p>Both approaches will be detailed and contrasted below, before focusing on how dataflows can be defined and used with Sim-Diasca.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Most of the dataflow-related concepts mentioned in this document are illustrated on a <strong>complete, runnable simulation case</strong>: the <tt class="docutils literal">Dataflow Urban Example</tt>, whose sources are located in the <tt class="docutils literal"><span class="pre">mock-simulators/dataflow-urban-example</span></tt> directory of the standard Sim-Diasca distribution.</p>
<p>Besides these case-specific elements, the sources of the <strong>generic dataflow infrastructure</strong> are also available, in the <tt class="docutils literal"><span class="pre">sim-diasca/src/core/src/dataflow</span></tt> directory.</p>
<p class="last">Please feel free to skim in these respective sources for a better practical understanding of the dataflow infrastructure.</p>
</div>
</div>
<div class="section" id="usual-organization-of-the-model-evaluation">
<h1><a class="toc-backref" href="#id88">Usual Organization of the Model Evaluation</a></h1>
<p>In most simulations of complex systems, the simulated world is sufficiently <strong>disaggregated into numerous autonomous model instances</strong> (be they named agents or actors) so that <strong>the evaluation of their respective behaviours and interactions naturally leads to processing the simulation</strong>. In this context, trying to constrain or even hard-code static sequences of events is often neither possible nor desirable.</p>
<p>For example, one can see a city as a set of buildings, roads, people, etc., each with its own state and behaviour, the overall city (including its districts, precincts, etc.) being the byproduct of their varied interactions - a possibly hierarchical, certainly <em>emergent</em> organisation.</p>
<p>This approach is probably the most commonly used when modelling a complex system, hence it is the one natively supported by Sim-Diasca: the target system is meant to be described as a (potentially large) collection of model instances (a.k.a. actors) possibly affected by scenarios and, provided that their respective state and behaviour have been adequately modelled, the engine is able to evaluate them in the course of the simulation, concurrently, while actors feed the probes that are needed in order to generate the intended results.</p>
<p>The (engine-synchronised) interactions between actors are at the very core of these simulations, which are determined by how actors get to know each other, exchange information, opt for a course of action, create or destroy others and, more generally, interact through an <strong>implicit overall applicative protocol resulting from the superposition of their individual, respective behaviours</strong>.</p>
<p>However other, quite different, organisational schemes can be devised, including the one discussed in this section, the <strong>dataflow</strong> paradigm.</p>
<p></p>
</div>
<div class="section" id="an-alternate-mode-of-operation-the-dataflow">
<h1><a class="toc-backref" href="#id89">An Alternate Mode of Operation: the Dataflow</a></h1>
<p>Let's define first what is a dataflow.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A dataflow is a way of describing a set of interdependent processings whose evaluation is driven by the availability of the data they are to handle.</p>
</div>
<p>In this more constrained organisation, rather than having actors freely exchanging various symbols and messages according to dynamically-decided patterns, we rely here on quite specialised actors that embody <em>dataflow blocks</em>, which are:</p>
<ul class="simple">
<li>either <em>dataflow processing units</em> (instances of the <tt class="docutils literal">DataflowProcessingUnit</tt> class), which set and listen for <em>values</em>, through <em>channels</em> that are delimited each by an <em>input port</em> and an <em>output port</em>, and perform associated computations</li>
<li>or <em>dataflow objects</em> (instances of the <tt class="docutils literal">DataflowObject</tt> class) that stores <em>attributes</em> that can be set and read respectively thanks to their associated input and output ports</li>
</ul>
<p>All these dataflow blocks and the channels linking them form altogether a graph (whose nodes are the blocks, and whose edges are the channels). This graph is by default:</p>
<ul class="simple">
<li><strong>statically defined</strong>: its structure can be established before the simulation starts</li>
<li><strong>static</strong>: in the general case, its structure is not expected to change in the course of the simulation</li>
<li><strong>directed</strong>: channels are unidirectional, only from an output port of a block to an input port of a block</li>
<li><strong>acyclic</strong>: by following the declared (directed) channels, no path should go through the same block more than once</li>
</ul>
<p>The graph can be explicit or not: either it is described as a whole (as a single, standalone entity), or it can be merely extrapolated from the union of the channels drawn between the declared blocks.</p>
<p>Dataflows of course have an immediate graphical counterpart. The conventional symbols we elected are represented in this key:</p>
<p><span class="raw-html"><center><img src="dataflow-legend.png" id="responsive-image-intermediate"></img></center></span>
</p>
<p>By convention, input ports are in orange, output ports in green, dataflow objects in light purple, dataflow units (ex: processing or mock-up ones) are in light blue and comprise the symbol of their activation policy, and channels are in various shades of blue <a class="footnote-reference" href="#id2" id="id1">[1]</a>.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Please refer to <a class="reference internal" href="#annex-3-conventions-for-the-graphical-representation-of-dataflows">Annex 3: Conventions for the Graphical Representation of Dataflows</a> for more information.</td></tr>
</tbody>
</table>
<p>Still in blue, the <tt class="docutils literal">SUTC</tt> quadruplet:</p>
<ul class="simple">
<li>the channel <em>Semantics</em> (i.e. the meaning of the conveyed values) can be specified, as an arbitrary domain-specific symbol prefixed with <tt class="docutils literal">&quot;S:&quot;</tt> (like in <tt class="docutils literal">&quot;S: 'produced heat'&quot;</tt>); project conventions may apply, notably in order to adopt the RDF format, like in:</li>
</ul>
<pre class="code bash literal-block">
S:<span class="s1">'http://foobar.org/urban/1.1/energy/demand'</span>
</pre>
<ul class="simple">
<li>the <em>Unit</em> of the value, prefixed with <tt class="docutils literal">&quot;U:&quot;</tt> (ex: <tt class="docutils literal">&quot;U: kW.h&quot;</tt>, or <tt class="docutils literal">&quot;U: <span class="pre">g/Gmol.s^-2&quot;</span></tt>); often the unit information implies a type (described in next point): for example the unit <tt class="docutils literal">&quot;U: W&quot;</tt> implies the type <tt class="docutils literal">&quot;T: float&quot;</tt>; in this case the type information can be safely omitted</li>
<li>the <em>Type</em> of the values conveyed by the channel, prefixed with <tt class="docutils literal">&quot;T:&quot;</tt> (ex: <tt class="docutils literal">&quot;T: string&quot;</tt> or <tt class="docutils literal">&quot;T: {integer,boolean}&quot;</tt>)</li>
<li>the <em>Constraints</em> (if any) applying to the exchanged value, as a list of elementary constraints (ex: <tt class="docutils literal">&quot;C: [ <span class="pre">{between,{2.0,8.0}}</span> ]&quot;</tt> means that a single constraint applies to the exchanged values, which is that they must be between 2 and 8)</li>
</ul>
<p>These <tt class="docutils literal">SUTC</tt> information shall preferably be specified close to the associated channel (if any) or output port.</p>
<p>Unit activation, semantics, units, types and constraints are discussed more in-depth later in this document.</p>
<p>Specifying the names of dataflow units and ports is mandatory.</p>
<p>As a processing unit is in charge of <em>performing</em> a specific task included in a more general computation graph (the dataflow), its name shall reflect that; one may consider that the name of such a unit is implicitly prefixed with a verb like <tt class="docutils literal">compute_</tt>. For example, a processing unit named <tt class="docutils literal">fuel_intake</tt> could be understood as <tt class="docutils literal">compute_fuel_intake</tt> (and we expect it to have at least one output port dealing with fuel intake).</p>
<p>Finally, as some dataflow units have for purpose to aggregate metrics across time and/or space, some scale indication may be given for documentation purposes, enclosed in an hexagon in pale yellow.</p>
<p>The dataflow objects are specifically discussed in a section of their own later in this document.</p>
<p>As a result, a dataflow, which shall be interpreted as <strong>a graph of computations</strong>, may look as this (meaningless) example:</p>
<p><span class="raw-html"><center><img src="dataflow-example.png" id="responsive-image-full"></img></center></span>
</p>
<p>We can see that a dataflow does not need to be fully connected (the blocks may form disjoint subgraphs) and that ports (input and output ones alike) may not be connected either.</p>
<p>The global progress of the computations happens here from left to right.</p>
<p>A <a class="reference internal" href="#more-complete-example">more complete example</a> is given later in this document.</p>
<p>Now let's detail a bit all the elements involved.</p>
<p></p>
</div>
<div class="section" id="on-dataflows-experiments">
<span id="dataflows"></span><h1><a class="toc-backref" href="#id90">On Dataflows &amp; Experiments</a></h1>
<div class="section" id="dataflow-definition">
<h2><a class="toc-backref" href="#id91">Dataflow Definition</a></h2>
<p>As mentioned, a dataflow is a <em>graph of computations whose evaluation is driven by the availability of the data they are to handle.</em></p>
<p>In practice, it is a set of interlinked dataflow blocks, typically <a class="reference internal" href="#dataflow-processing-units">dataflow processing units</a> and <a class="reference internal" href="#dataflow-objects">dataflow objects</a>.</p>
<p>Even though dataflows could remain only implicit data-structures (they would just correspond to an actual set of interlinked dataflow elements), we preferred introducing an actual <strong>dataflow class</strong>, in order to ease the interaction with such instances and provide a reference point.</p>
<p>So overall operations on a given dataflow (ex: creations, modifications, report inquiries) shall be operated only through its corresponding federating <tt class="docutils literal">class_Dataflow</tt> instance.</p>
<p>Multiple dataflow instances may exist, and they are collectively managed by the overall <a class="reference internal" href="#experiment-manager">experiment manager</a>, introduced later in this document.</p>
</div>
<div class="section" id="experiment-definition">
<h2><a class="toc-backref" href="#id92">Experiment Definition</a></h2>
<p>An experiment corresponds to the overall evaluation task that is to be performed by a (here: dataflow-based) simulation, as it is described by the corresponding simulation case.</p>
<p>For that such an experiment aggregates any number of dataflows, which progress in parallel, typically through a series of steps <a class="footnote-reference" href="#id4" id="id3">[2]</a>.</p>
<p>During each step, each dataflow instance, based on any update of its input ports, is fully evaluated (i.e. until it reaches a fully stable state).</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>In engine-related terms, an experiment step of the dataflow infrastructure corresponds to a simulation tick of the engine. During such a step, dataflows are evaluated over diascas, resulting on their elements exchanging values, until none of the output port is set anymore. Then the next step (tick) can be evaluated, etc.</td></tr>
</tbody>
</table>
<p>More in-depth information can be found in the <a class="reference internal" href="#experiments">Experiments</a> section.</p>
</div>
</div>
<div class="section" id="on-dataflow-processing-units">
<span id="dataflow-processing-units"></span><h1><a class="toc-backref" href="#id93">On Dataflow Processing Units</a></h1>
<p>A (processing) unit is, with dataflow objects, the most common type of dataflow block.</p>
<p>A dataflow unit encapsulates a <em>kind of computation</em>. For example, if an energy demand has to be computed in a dataflow, an <tt class="docutils literal">EnergyDemandUnit</tt> processing unit can be defined.</p>
<p>Such a unit is a <em>type</em>, in the sense that it is an abstract blueprint that shall be instantiated in order to rely on actual units to perform the expected computations. Therefore, in our example, a <tt class="docutils literal">class_EnergyDemandUnit</tt> processing unit shall be defined (specified and implemented), so that we can obtain various unit instances out of it in order to populate our dataflow.</p>
<p>As discussed in the next section, each of the instances of a given dataflow unit defines input and output <a class="reference internal" href="#ports">ports</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>It shall be noted that, additionally, each processing unit instance benefits from a <strong>state</strong> of its own (that it may or may not use): the attributes that the unit class introduced are available in order to implement any memory needed by the unit, and of course these attributes will retain their values through the whole lifetime of that instance (hence through simulation ticks and diascas).</p>
<p class="last">So a unit may encapsulate any processing between a pure, stateless function to a more autonomous, stateful, agent.</p>
</div>
</div>
<div class="section" id="on-dataflow-ports-channels-and-buses">
<span id="ports"></span><h1><a class="toc-backref" href="#id94">On Dataflow Ports, Channels and Buses</a></h1>
<p>A port is the only way by which a dataflow block (typically a unit) may interact (propagate a value) with other blocks.</p>
<p>Following rules apply:</p>
<ul class="simple">
<li>a port is either an <strong>input</strong> one (listening to the update of a value conveyed by the corresponding channel) or an <strong>output</strong> one (able to update its corresponding value and notify its registered input listeners); this is reflected by their type (either <tt class="docutils literal">input_port</tt> or <tt class="docutils literal">output_port</tt>)</li>
<li>each port is <strong>named</strong> (as a non-empty string <a class="footnote-reference" href="#id9" id="id5">[3]</a>, ex: <tt class="docutils literal">&quot;my foobar port&quot;</tt>) and no two input ports of a block can bear the same name, nor output ones can (however an input port and an output port of the same block <em>can</em> have the same name - they will be differentiated by their nature)</li>
<li>a <strong>port identifier</strong> is defined from a pair made of an identifier of the block that defined it and from the name of that port <a class="footnote-reference" href="#id10" id="id6">[4]</a> (ex: it could be <tt class="docutils literal">(&quot;My <span class="pre">Unit&quot;,&quot;Port</span> 24&quot;)</tt>, or based on more technical identifiers)</li>
<li>a port (input or output) may either hold a value (arbitrary data can be set; the port is then considered as ready, i.e. as <tt class="docutils literal">set</tt>), or not - in which case it holds the <tt class="docutils literal">unset</tt> symbol (the port is then itself considered as <tt class="docutils literal">unset</tt>)</li>
<li>an <strong>output</strong> port can be considered as being always unset: as soon as a new value is available, it notifies all its connected input ports and then reverts back to the unset status; therefore the set/unset status can be abstracted out for output ports, which just get punctually activated</li>
<li>conversely, this status matters for <strong>input</strong> ports: a block starts with all its input ports to <tt class="docutils literal">unset</tt>, and, each time an input port is notified by an output port, this input port switches to <tt class="docutils literal">set</tt>; how a block is to react depending on none, one, some or all of its input ports being set is discussed below</li>
<li>an <strong>output port will send downstream the value it holds</strong> whenever:<ul>
<li>it gets <strong>set</strong>: exactly one sending will be performed per setting (regardless of the value that is set) to each of the input ports it is linked to; as a result, setting explicitly a port to a value that happens to be the same as the one that it was already holding will nevertheless trigger a sending (therefore &quot;not setting a value&quot; vs &quot;setting the current value again&quot; are operations that differ semantically)</li>
<li>it gets <strong>connected</strong> (i.e. a channel is created from this output port to an input port) <em>whereas this output port has already been set at least once in the past</em>; then, on channel creation, the latest value it sent will be re-emitted, only to the newly connected input port</li>
</ul>
</li>
<li>ports can convey arbitrary data (i.e. any Erlang term), yet any given port has a <strong>type</strong>, which defines what are the licit the values that it can hold (ex: &quot;this port can be set to any pair of non-negative floats&quot;) <a class="footnote-reference" href="#id11" id="id7">[5]</a></li>
<li><strong>a block can declare any number of output ports</strong> (possibly none, in which case it is an <em>exit block</em>, a sink)</li>
<li><strong>a block can declare any number of input ports</strong> (possibly none, in which case it is an <em>entry block</em>, a source)</li>
<li><strong>a channel links exactly one output port to one input port</strong>, and these two ports shall have the same types, units and semantics (which are the ones of the channel)</li>
<li><strong>any number of channels may originate from an output port</strong> (possibly none); when an output port is being set (i.e. when it performs a punctual transition from <tt class="docutils literal">unset</tt> to <tt class="docutils literal">set</tt>), then all the input ports listening to it are notified of that <a class="footnote-reference" href="#id12" id="id8">[6]</a></li>
<li><strong>an input port may be the target of up to one channel</strong>; if no channel feeds a port, then it remains in the <tt class="docutils literal">unset</tt> state</li>
<li>a port records the timestamp (in simulation time) of the last notification (possibly <tt class="docutils literal">none</tt>) it either sent (for output ports) or received (for input ones)</li>
<li>a <strong>bus</strong> corresponds to a set of channels ; it shall be seen, at least currently, only as a graphical convention introduced in order to avoid that too many parallel channels are drawn, which would obfuscate the representation of a dataflow (note that no bus per se is considered when evaluating the dataflow; the runtime is only aware of ports being connected to others, so buses - and even channels - are abstracted out)</li>
</ul>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[3]</a></td><td>The only restriction is that the <tt class="docutils literal">&quot;_iterated_&quot;</tt> substring cannot exist in a user-defined port name (so for example <tt class="docutils literal">&quot;foo_iterated_bar_42&quot;</tt> will be rejected by the dataflow infrastructure).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[4]</a></td><td>A port identifier is typed as <tt class="docutils literal"><span class="pre">-type</span> port_id() :: <span class="pre">{dataflow_object_pid(),port_name()}.</span></tt> where <tt class="docutils literal">dataflow_object_pid()</tt> is a PID (the one of the block) and <tt class="docutils literal">port_name()</tt> is a binary string.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[5]</a></td><td>The dataflow system may or may not check that typing information.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[6]</a></td><td>Indeed the <tt class="docutils literal">onInputPortSet/3</tt> actor oneway of their respective block is executed, specifying the port identifier of the triggered input port and the corresponding timestamped value (specifying the tick and diasca of the notification). Generally this information is not of interest for the block implementer, as defining for example a unit activation policy allows to handle automatically input ports being triggered.</td></tr>
</tbody>
</table>
<p>Even if conceptually it is sufficient that only the output port knows the input ports it may notify (and not the other way round), technically the input ports also know the (single, if any) output port that may notify them, for example for a simpler support of unsubscribing schemes.</p>
<p></p>
</div>
<div class="section" id="on-dataflow-values">
<h1><a class="toc-backref" href="#id95">On Dataflow Values</a></h1>
<p>We saw that a value designates <strong>a piece of data carried by a channel</strong>, from an output port to any number of input ports.</p>
<p>Various information are associated to the output ports and to the values they carry (they are metadata), notably the <tt class="docutils literal">SUTC</tt> quadruplet (for <em>Semantics-Units-Type-Constraints</em>), which the next sections detail in turn, yet in a different order for the sake of clarity - roughly from the most concrete to the highest-level.</p>
<div class="section" id="type-of-a-value">
<h2><a class="toc-backref" href="#id96">Type of a Value</a></h2>
<div class="section" id="type-basics">
<h3>Type Basics</h3>
<p>A channel is <strong>typed</strong>, in the sense that all the values that it conveys shall be of the same type (in terms of programming language; ex: a floating-point value), which is the one specified for the channel. The <tt class="docutils literal">T</tt> in <tt class="docutils literal">SUTC</tt> stands for this <em>type</em> information.</p>
<p>The <em>name</em> of a type must be a series of alphanumerical characters, in lowercase, starting with an alphabetical one, and possibly containing underscore (<tt class="docutils literal">_</tt>) characters; example of a type name: <tt class="docutils literal">integer</tt> or <tt class="docutils literal">this_is_my_type_name_221</tt>.</p>
<p>The complete type specification in a dataflow (typically used to describe a port) shall be prefixed with <tt class="docutils literal">&quot;T:&quot;</tt> (for example <tt class="docutils literal">&quot;T: integer&quot;</tt> would mean that the corresponding port handles values of type <tt class="docutils literal">integer</tt>).</p>
<p>In the absence of <em>unit</em> information (see next section), the <em>type</em> information is mandatory and must be specified by both port endpoints. It may or may not be checked, at build and/or run time.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The specified typing information is currently <em>not</em> used: as a consequence, the values conveyed by the dataflow are <em>not</em> yet checked against their declared type.</p>
</div>
<p>A set of <em>built-in</em> and <em>derived</em> types is provided, and many port specifications rely directly on them in order to define simple, scalar, atomic values (often floating-point ones) - as opposed to compound ones. Specifications may also define and use any additional type that they may need.</p>
<p>Moreover, if deemed useful, more complex data structures may be specified, based on <em>polymorphic</em> types like tuples (denoted as <tt class="docutils literal">{}</tt>), on lists (denoted as <tt class="docutils literal">[]</tt>) or even, in the future, on associative tables.</p>
<p>All these constructs enable the specification of all the typing information needed by the user in order to describe, in computing terms, the values exchanged over the dataflow.</p>
<p>Let's discuss the basic typing primitives first, i.e. the built-in types.</p>
</div>
<div class="section" id="built-in-types">
<h3>Built-in Types</h3>
<p>Following <strong>built-in types</strong> are available (they map to Erlang native types; some related technical details put between parentheses or in footnotes may be safely ignored by the reader):</p>
<p><span class="raw-html"><center></span></p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="51%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Name of the built-in type</th>
<th class="head">Description</th>
<th class="head">Example value</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">integer</tt></td>
<td>Any (unbounded; positive or negative) integer
value.</td>
<td><tt class="docutils literal"><span class="pre">-112</span></tt></td>
</tr>
<tr><td><tt class="docutils literal">float</tt></td>
<td>Any floating-point value (in double precision).</td>
<td><tt class="docutils literal">3.14159</tt></td>
</tr>
<tr><td><tt class="docutils literal">number</tt></td>
<td>Any number (either an integer or a float) <a class="footnote-reference" href="#id15" id="id13">[7]</a>.</td>
<td><tt class="docutils literal">1.1</tt></td>
</tr>
<tr><td><tt class="docutils literal">string</tt></td>
<td>Any series of characters delimited by double
quotes <a class="footnote-reference" href="#id16" id="id14">[8]</a>.</td>
<td><tt class="docutils literal">&quot;Hello world!&quot;</tt></td>
</tr>
<tr><td><tt class="docutils literal">boolean</tt></td>
<td>Either <tt class="docutils literal">'true'</tt> or <tt class="docutils literal">'false'</tt>.</td>
<td><tt class="docutils literal">'true'</tt></td>
</tr>
<tr><td><tt class="docutils literal">count</tt></td>
<td>A non-negative integer, to mention a number of
elements (possibly zero).</td>
<td><tt class="docutils literal">17</tt></td>
</tr>
<tr><td><tt class="docutils literal">percent</tt></td>
<td>A floating-point percentage (alias of
<tt class="docutils literal">float</tt>), the value <tt class="docutils literal">1.0</tt> corresponding to
100%.</td>
<td><tt class="docutils literal"><span class="pre">-1.4</span></tt></td>
</tr>
<tr><td><tt class="docutils literal">json_content</tt></td>
<td>An opaque, stringified
<a class="reference external" href="https://en.wikipedia.org/wiki/JSON">JSON</a>
representation of a value.</td>
<td>(undisclosed, as
meant to be opaque)</td>
</tr>
<tr><td><tt class="docutils literal">any</tt></td>
<td>Wildcard type, corresponding to any type (no
information given, hence no type checking can
be performed in this case).</td>
<td><tt class="docutils literal">&quot;I am a value.&quot;</tt></td>
</tr>
</tbody>
</table>
<p><span class="raw-html"></center></span></p>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[7]</a></td><td>Note that some types overlap, notably some of them are special cases of others, like integers and numbers. So, for a given value, multiple type specifications apply (ex: <tt class="docutils literal">any</tt> will always match).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[8]</a></td><td>Mapped as an Erlang binary string, displayed as a basic string.</td></tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Indiscriminate use of the <tt class="docutils literal">any</tt> type is strictly prohibited;
typically it should <em>never</em> be used operationally (ex: when defining
actual ports), as it would then be a way of bypassing the type system.</p>
<p class="last">For advanced users: the main use of <tt class="docutils literal">any</tt> lies in the very specific context of &quot;polymorphic units&quot;, i.e. units that may be able to process values of all kinds of types.</p>
</div>
</div>
<div class="section" id="derived-types">
<h3>Derived Types</h3>
<p>These types are not built-in, they are to be specifically derived (possibly by the user directly) from other types (which themselves may be built-in or derived).</p>
<div class="section" id="type-definition">
<h4>Type Definition</h4>
<p>Often, a new type definition has to be used in several occurrences (ex: when having different ports that happen to rely on the same type). Rather than repeating the same type definition each time, we recommend that, as soon as a type definition is used more than once for the same purpose, a (derived) type is defined from it and named one time for all - and then referred to as often as needed.</p>
<p>Indeed, being (new) types, derived types have their own name (ex:  <tt class="docutils literal">my_own_type</tt>), knowing that the names of all built-in types are reserved.</p>
<p>So, in order to define a derived type named <tt class="docutils literal">my_own_type</tt> according to any kind of definition (designated here by <tt class="docutils literal">A_TYPE_DEFINITION</tt>), the following syntax shall be used:</p>
<pre class="literal-block">
my_own_type :: A_TYPE_DEFINITION
</pre>
<p>For example, if various ports had to handle a number of vehicles, then it may be advisable to introduce a specific type for this purpose, which could be named <tt class="docutils literal">vehicle_count</tt>.</p>
<p>In this case, this derived type would happen to be simply a synonym of the <tt class="docutils literal">integer</tt> built-in type (the <tt class="docutils literal">vehicle_count</tt> type would then be here an <em>alias</em> a the <tt class="docutils literal">integer</tt> built-in one):</p>
<pre class="literal-block">
vehicle_count :: integer
</pre>
<p>Then, this new type being defined, ports may use it and specify that they handle channel values of that type, thanks to <tt class="docutils literal">T: vehicle_count</tt>.</p>
</div>
<div class="section" id="type-constructs">
<h4>Type Constructs</h4>
<p>Aliases are of course useful, yet one may have to specify types that are more complex than exact synonyms of the built-in types.</p>
<p>For that, the user can rely on following type constructs, which allow introducing new types, or combinations thereof:</p>
<ul>
<li><p class="first"><em>union types</em>, i.e. types that regroup other types and whose values can be of either one of these types</p>
<ul class="simple">
<li>in the specification of such an union type, the listed types are separated by the pipe (<tt class="docutils literal">|</tt>) character, representing the OR operator</li>
<li>for example, the union of types T1, T2 and T3 is: <tt class="docutils literal">T1|T2|T3</tt>; the aforementioned <tt class="docutils literal">number</tt> built-in type can be defined as: <tt class="docutils literal">integer|float</tt></li>
</ul>
</li>
<li><p class="first"><em>symbol types</em>, each of which being a simple label (a non-empty series of characters delimited by single quotes), like <tt class="docutils literal">'my_symbol'</tt> or <tt class="docutils literal">'Red Alert'</tt>; a symbol is both a type and a value, in the sense that defining a symbol is defining a type which happens to have a single value (itself) <a class="footnote-reference" href="#id18" id="id17">[9]</a>; moreover type names are themselves symbols (without their single quotes); so defining <tt class="docutils literal">my_type</tt> as, for example, <tt class="docutils literal">integer</tt>, corresponds to the definition of an alias type, a synonym of integer which can be used in other type definitions (such as in <tt class="docutils literal">[my_type]</tt>)</p>
</li>
<li><p class="first"><em>enumerated types</em> (a.k.a. enumerations) is a user-defined union of <em>symbols</em>, simply obtained from the two previous constructs; for example a <tt class="docutils literal">burner_status</tt> enumeration type might be defined as:</p>
<pre class="literal-block">
'burner_enabled' | 'burner_disabled' | 'burner_on_operation'
</pre>
</li>
</ul>
<p>and a value of that type (a symbol) may be, for example: <tt class="docutils literal">'burner_disabled'</tt></p>
<p>One can see that the <tt class="docutils literal">boolean</tt> type is actually nothing but a <tt class="docutils literal"><span class="pre">'true'|'false'</span></tt> enumeration.</p>
<p>Defining a single-type enumeration corresponds to defining a symbol type.</p>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[9]</a></td><td>Symbols are mapped to Erlang atoms.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="polymorphic-types">
<h3>Polymorphic Types</h3>
<p>Finally, in addition to all the atomic types (built-in or derived) presented above, following built-in <strong>polymorphic types</strong> (types that depend on others) are supported as well:</p>
<ul class="simple">
<li><em>list</em> of type <tt class="docutils literal">T</tt>, noted as <tt class="docutils literal">list(T)</tt> or <tt class="docutils literal">[T]</tt>: any kind of (proper, homogeneous) list (empty or not), represented between square brackets, to account for a variable-size sequential container containing values of type <tt class="docutils literal">T</tt><ul>
<li>ex: <tt class="docutils literal">list(integer)</tt> and <tt class="docutils literal">[integer]</tt> denote the same type, a list containing any number of integers; values of that type can thus be: <tt class="docutils literal"><span class="pre">[4,-17]</span></tt>, <tt class="docutils literal">[]</tt>, etc.</li>
<li><tt class="docutils literal">list()</tt> refers to any kind of list (alias of <tt class="docutils literal">list(any)</tt>)</li>
</ul>
</li>
<li><em>tuple</em> containing elements of types T1, T2, T3, etc., noted as <tt class="docutils literal"><span class="pre">{T1,T2,T3,...}</span></tt>: any kind of tuple (fixed-size container, homogeneous or not), delimited by curly braces<ul>
<li>ex: a value of the  <tt class="docutils literal"><span class="pre">{burner_status,float,[bool]}</span></tt> type might be <tt class="docutils literal"><span class="pre">{'burner_on_operation',14.7,['false','false']}</span></tt></li>
<li><tt class="docutils literal">tuple(T)</tt> refers to tuples whose elements are all of type <tt class="docutils literal">T</tt>, and whose number is not specified (ex: <tt class="docutils literal">{2,46,5}</tt> is of type <tt class="docutils literal">tuple(integer)</tt>), while <tt class="docutils literal">tuple()</tt> refers to any kind of tuple</li>
</ul>
</li>
<li>in later versions: <em>associative tables</em>, whose keys are of type <tt class="docutils literal">Tk</tt> and values are of type <tt class="docutils literal">Tv</tt>, noted as <tt class="docutils literal">table(Tk,Tv)</tt></li>
</ul>
<p>Note that <em>recursive</em> types (ex: a type <tt class="docutils literal">tree</tt> being defined as <tt class="docutils literal">{tree,tree,node_content}</tt>), are, at least currently, not allowed (they can be expressed yet no specific support for them is provided).</p>
</div>
<div class="section" id="implementation-wise">
<h3>Implementation-wise</h3>
<p>The dataflow infrastructure includes a <tt class="docutils literal">TypeServer</tt>, which tracks statically (i.e. on a per-class level) or dynamically (for any dynamically-created port) the type declarations and uses, to provide a first, very basic support for typing enforcement.</p>
<p></p>
</div>
</div>
<div class="section" id="unit-of-a-value">
<h2><a class="toc-backref" href="#id97">Unit of a Value</a></h2>
<p>A value of a given type (typically a float) can actually correspond to quantities as different as meters and kilowatts per hour.</p>
<p>Therefore <strong>units shall preferably be specified alongside with values</strong>, and a language to express these units must be retained. The <tt class="docutils literal">U</tt> in <tt class="docutils literal">SUTC</tt> stands for this <em>unit</em> information.</p>
<p>One should refer to the documentation of the <tt class="docutils literal">Myriad</tt> layer <a class="footnote-reference" href="#id20" id="id19">[10]</a> for a description of how units can be specified, compared, checked and used.</p>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[10]</a></td><td>Please refer to the <em>Description of the Management of Units</em> section, in the technical manual of the Myriad layer (in <tt class="docutils literal"><span class="pre">Ceylan-Myriad-Layer-technical-manual-english.pdf</span></tt>).</td></tr>
</tbody>
</table>
<p>In a dataflow, the unit of the values that will be held by a port shall preferably be specified when declaring that port. This is done thanks to a string, prefixed with <tt class="docutils literal">&quot;U:&quot;</tt> (ex: <tt class="docutils literal">&quot;U: kW.h&quot;</tt>, <tt class="docutils literal">&quot;U: <span class="pre">g/Gmol.s^-2&quot;</span></tt> or <tt class="docutils literal">&quot;U: {mm,mm,mm}&quot;</tt> for a 3D vector in millimeters).</p>
<p>Specifying the unit of a scalar value implies declaring its type as <tt class="docutils literal">float</tt>.</p>
<p>If, for a value, no unit is given, then its type, as discussed in <a class="reference internal" href="#type-of-a-value">Type of a Value</a>, shall be specified.</p>
</div>
<div class="section" id="semantics-of-a-value">
<h2><a class="toc-backref" href="#id98">Semantics of a Value</a></h2>
<p>Specifying the type and unit of a value is certainly useful, yet it would generally be insufficient to convey its <em>meaning</em>, i.e. to express how that value shall be interpreted.</p>
<p>For example, knowing that a port accepts floating-point values in kilojoules does not tell whether this value corresponds to an energy demand, an actual consumption or a production.</p>
<p>Therefore this domain-specific information shall be specified separately. It is to be done thanks to the specification of a symbol (similar to a string, corresponding to an Erlang atom), prefixed with <tt class="docutils literal">&quot;S:&quot;</tt>, standing for <strong>semantics</strong> (which is the <tt class="docutils literal">S</tt> in <tt class="docutils literal">SUTC</tt>). For example: <tt class="docutils literal">&quot;S: 'security credentials'&quot;</tt> or <tt class="docutils literal">&quot;S: 'energy_demand'&quot;</tt>.</p>
<p>We recommend that semantics are specified according to a well-defined, standard format: <a class="reference external" href="https://en.wikipedia.org/wiki/Resource_Description_Framework">RDF</a> (standing for <em>Resource Description Framework</em>).</p>
<p>RDF statements (potentially expressed as RDF triples) about subjects (ex: a block or a port) clarify the intents (made them explicit and expressed in an uniform way) and may allow the use of tools able to perform queries and inference. This may enable, in the future, the automatic checking and even generation of proper dataflows.</p>
<p>Typically a port semantics is then a <em>subject</em> in RDF parlance, like in:</p>
<pre class="code bash literal-block">
S:<span class="s1">'http://foobar.org/urban/1.1/energy/demand'</span>
</pre>
<p>where:</p>
<ul class="simple">
<li>the normalising organisation is designated by its domain name <tt class="docutils literal">foobar.org</tt></li>
<li>it published a <tt class="docutils literal">urban</tt> ontology, whose version in use here is <tt class="docutils literal">1.1</tt></li>
<li>it addresses potentially multiple fields of interest, including the one of <tt class="docutils literal">energy</tt></li>
<li>one sub-topic of which is the <tt class="docutils literal">demand</tt> (of energy)</li>
</ul>
<p>As a result, the full chain (the output port, the channels, the value itself and the related input ports) can perform a basic check of the semantic consistency for each  exchange over the dataflow, and have an extra chance of detecting and rejecting any erroneous port connection (even if in technical terms, i.e. in terms of typing and unit, it may look perfectly legit).</p>
<p>Currently a minimum lexicographic distance (the <a class="reference external" href="https://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein</a> one) is enforced (by the <tt class="docutils literal">SemanticServer</tt> of the dataflow infrastructure) between any two semantic elements, so that any spelling mistake can be more easily detected.</p>
<p>Generally the channel is shown as bearing the semantics, implying that this formalised meaning is shared by the corresponding output port, the associated input ports and by the values that they exchange.</p>
</div>
<div class="section" id="constraints-applying-to-a-value">
<h2><a class="toc-backref" href="#id99">Constraints Applying to a Value</a></h2>
<p>The <tt class="docutils literal">C</tt> in <tt class="docutils literal">SUTC</tt> stands for this <em>constraints</em> information.</p>
<p>They allow to specify a set of rules by which the value must abide.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Unlike most of the other meta-data (ex: semantics or type), constraints are not considered as being intrinsic to a value; they are generally seen as a property (on values) that is enforced at the port level.</p>
</div>
<p>The following constraints can be mixed and matched:</p>
<ul class="simple">
<li><tt class="docutils literal">{greater_than,G}</tt> means that the (scalar) value must be greater than, or equal to, the number <tt class="docutils literal">G</tt></li>
<li><tt class="docutils literal">{lower_than,L}</tt> means that the (scalar) value must be lower than, or equal to, the number <tt class="docutils literal">L</tt></li>
<li><tt class="docutils literal">{between,A,B}</tt> means that the (scalar) value must be greater than, or equal to, the number <tt class="docutils literal">A</tt> and lower than, or equal to, the number <tt class="docutils literal">B</tt></li>
<li><tt class="docutils literal">{in,L}</tt> means that the value must be an element of the list <tt class="docutils literal">L</tt></li>
<li><tt class="docutils literal">positive</tt> means that the (scalar) value must be positive (possibly null)</li>
<li><tt class="docutils literal">strictly_positive</tt> means that the (scalar) value must be strictly positive (null not allowed)</li>
<li><tt class="docutils literal">negative</tt> means that the (scalar) value must be negative (possibly null)</li>
<li><tt class="docutils literal">strictly_negative</tt> means that the (scalar) value must be strictly negative (null not allowed)</li>
<li><tt class="docutils literal">non_null</tt> means that the (scalar) value must not be null (strictly positive or negative, zero not allowed)</li>
</ul>
<p>For example, constraints applying to a value could be:</p>
<pre class="code bash literal-block">
C: <span class="o">[</span> <span class="o">{</span>between,2020,2040<span class="o">}</span>, <span class="o">{</span>in, <span class="o">[</span><span class="m">1989</span>,2021,2030,2988<span class="o">]}</span> <span class="o">]</span>
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>As mentioned, for all numerical comparisons (ex: <tt class="docutils literal">greater_than</tt>), the value of interest is expected to be a (scalar) number.</p>
<p class="last">Otherwise (ex: the value is a triplet, or the value is not a number), the associated constraint is considered as <em>not</em> satisfied.</p>
</div>
<p>All constraints have to apply (as if they were associated by <tt class="docutils literal">AND</tt> operators). The previous example would thus allow only two possible values, <tt class="docutils literal">2021</tt> and <tt class="docutils literal">2030</tt>.</p>
<p>Various additional kinds of constraints may be supported, based on encountered needs.</p>
<p>Constraints are currently parametrised by <em>constants</em> (ex: <tt class="docutils literal">{greather_than,10.0}</tt>); maybe in the future they could also accept <em>references</em> onto other local ports (ex: to compare their values or base some constraints on operations, like <tt class="docutils literal">sum</tt>, performed on their values).</p>
</div>
<div class="section" id="accuracy-of-a-value">
<h2><a class="toc-backref" href="#id100">Accuracy of a Value</a></h2>
<p>This may be the next value-level metadata to be handled by the dataflow infrastructure.</p>
<p>Depending on various factors like data quality and numerical errors (ex: floating-point rounding), the computed values might show a good precision and many digits, yet a poor <a class="reference external" href="https://en.wikipedia.org/wiki/Accuracy_and_precision">accuracy</a>.</p>
<p>The first step to prevent it is to measure how accurate a computation is. This can be evaluated thanks to <a class="reference external" href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html#689">relative error and ulps</a> (for <em>units in the last place</em>).</p>
<p>So an accuracy may be associated to each value exchanged over the dataflow, and it may then be updated by each processing unit relying on it.</p>
<p>By default accuracy is best measured in terms of relative error, as, if ulps are the most natural way to measure rounding error, they are less suitable to analyse the error caused by various formulas.</p>
<p>Anyway, often only the order of magnitude of rounding errors is of interest, and ulps and relative errors may be used interchangeably since their magnitude differ by at most a constant factor, the radix, typically equal to 2 (binary representation), or less frequently 10 (decimal one).</p>
<p>Another measure could be the &quot;precision&quot;, once defined as the number of bits used to represent the significand of a floating-point number. Libraries like <a class="reference external" href="http://www.mpfr.org/">MPFR</a> can be given a target, arbitrary precision and may enforce it (hence we would expect the accuracy of the corresponding values to be constant across the corresponding ports).</p>
<p>Each project is free to retain its own conventions regarding how the accuracy is quantified (usually as a floating-point number). The dataflow infrastructure provides the mechanisms to keep track of it, and, in processing units, update it. An accuracy specification is to be prefixed with <tt class="docutils literal">&quot;A:&quot;</tt>, like in <tt class="docutils literal">&quot;A: 8&quot;</tt>.</p>
<p>Should no accuracy be used for a given value, it should be replaced by the <tt class="docutils literal">'unknown_accuracy'</tt> atom (which is the default).</p>
<p>The accuracy could be also translated as a confidence interval, i.e. an interval that covers an unknown parameter with probability <tt class="docutils literal"><span class="pre">P=1-alpha</span></tt>, where <tt class="docutils literal">P</tt> is the confidence level, and <tt class="docutils literal">alpha</tt> should be as close as possibly to 0 (typical values of <tt class="docutils literal">P</tt>: 0.95, 0.99 or 0.999) thanks to a sufficiently large number of samples.</p>
<p>As no general consensus exists about accuracy, it has not been included among the usual metadata associated to values. In the future this could added, accuracy becoming the <tt class="docutils literal">A</tt> of <tt class="docutils literal">SUTCA</tt>.</p>
</div>
<div class="section" id="wrapping-up-about-values">
<h2><a class="toc-backref" href="#id101">Wrapping Up About Values</a></h2>
<p>So an output port may send a notification to a set of input ports, with the following information being associated:</p>
<ul class="simple">
<li>a semantics, like in <tt class="docutils literal">S: 'energy_demand'</tt></li>
<li>a unit, like in <tt class="docutils literal">U: kW.h</tt></li>
<li>a type, like in <tt class="docutils literal">T: float</tt></li>
<li>constraints, like in <tt class="docutils literal">C: [{lower_than,100}]</tt></li>
<li>an accuracy, like in <tt class="docutils literal">A: 11.0</tt>, to be understood here as the number of bits for the precision of the significand</li>
<li>a value, like in <tt class="docutils literal">6.7121</tt></li>
<li>a timestamp, like in <tt class="docutils literal">{117,3}</tt>, i.e. tick offset #117, diasca 3</li>
<li>the port identifier of the sender</li>
</ul>
<p>The semantics, the unit, the type carried by endpoints and the sender port identifier are exchanged and checked at the channel creation, i.e. when the input port is linked to its output one.</p>
<p>The unit of the value, its associated constraints, its accuracy, its actual value and its timestamp are checked and sent to the input port each time it is triggered by its output port.</p>
<p></p>
</div>
</div>
<div class="section" id="logic-of-the-dataflow-block-activation">
<h1><a class="toc-backref" href="#id102">Logic of the Dataflow Block Activation</a></h1>
<p>We saw that a key element of a dataflow lies in its blocks, notably in its processing units.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Blocks are either dataflow objects or dataflow units. We will discuss here mainly of the latter (i.e., of units), as the activation of a dataflow object offers no flexibility: it will be activated iff at least one of its input ports has been assigned, leading to its corresponding attribute(s) being set, and to the associated outport(s) being in turn assigned.</p>
</div>
<p>For a given dataflow block, it must be decided:</p>
<ul class="simple">
<li>at which logical step the block is to be activated, i.e. <em>when</em> the activation of a block shall be examined</li>
<li>on which additional condition(s) it shall be activated, i.e. <em>how</em> in practice the block update shall be determined as having to be triggered</li>
<li>what results from such an activation, i.e. <em>what</em> are the operations this block should then perform</li>
</ul>
<p>Such an activation translates to the execution of the <tt class="docutils literal">activate/1</tt> method of that block (at this point, it is most probably a processing unit). The role of this method is to be <strong>the place where the unit defines its actual processing</strong>; for that, the unit most probably overrode the corresponding default do-nothing implementation.</p>
<p>During this processing, as for any actor oneway, the unit is free to perform <strong>computations</strong>, to send <strong>actor messages</strong> and to operate <strong>state changes</strong>. This includes notably reverting any of its input ports to the <tt class="docutils literal">unset</tt> state, and activating any of its output ports.</p>
<p>Now that it has been determined <em>what</em> an activation entails (pretty much anything within the degrees of freedom of an actor), the conditions ruling <em>when</em> an activation shall occur are to be specified. Various policies are available for that.</p>
<p>For a given <strong>activation policy</strong>, these conditions should only depend on the readiness of the input ports of that unit, and of its state.</p>
<p>Even if a given processing unit might define its own activation rules, the set of built-in activation policies described below should be sufficient for most uses.</p>
<p>In all cases, under the hood the unit will be notified thanks to an actor message that one of its input ports has been triggered, knowing that during a diasca any number of such messages may be received (indeed a unit may have multiple input ports; moreover, even if it may not be usual practice, an upstream block might have triggered one of its output ports more than once) and then reordered before being processed on the next diasca.</p>
<div class="section" id="the-activate-on-new-set-policy">
<h2><a class="toc-backref" href="#id103">The 'Activate On New Set' Policy</a></h2>
<p>The first built-in activation policy consists in updating the unit when <strong>at least one of its input ports</strong> went from <tt class="docutils literal">unset</tt> to <tt class="docutils literal">set</tt>.</p>
<p>This policy, named <tt class="docutils literal">activate_on_new_set</tt>, will activate the unit at most <em>once per diasca</em>, at the one immediately following the diasca at which these input ports were triggered, no matter of how many input ports were triggered on the previous diasca nor on how many times they were each triggered.</p>
<p>An (unordered) list of input port triggers, together with the corresponding values then set, will be available to the <tt class="docutils literal">activate/1</tt> method when it will be automatically executed.</p>
<p>Either a bulk update may follow (the unit taking them into account as a whole), or it may perform a fold on that list to react in turn to each trigger (to emulate the case where they would be received and processed one after the other <a class="footnote-reference" href="#id22" id="id21">[11]</a>).</p>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id21">[11]</a></td><td>Note that, as all actor messages, the triggers have been reordered by the engine according to the simulation mode.</td></tr>
</tbody>
</table>
<p>It is up to the unit to reset the input ports (i.e. to set each of them back to the <tt class="docutils literal">unset</tt> state) when deemed appropriate.</p>
<p><span class="raw-html"><center><img src="activate-on-new-set-policy.png" id="responsive-image-tiny"></img></center></span>
</p>
<p>This <em>Activate On New Set</em> policy (sometimes shortened as the &quot;On New&quot; policy) is graphically symbolized as an arrow, to denote that any update of an input port directly triggers the associated unit computation.</p>
</div>
<div class="section" id="the-activate-when-all-set-policy">
<h2><a class="toc-backref" href="#id104">The 'Activate When All Set' Policy</a></h2>
<p>The second built-in activation policy, named <tt class="docutils literal">activate_when_all_set</tt>, is to update the unit if and only if <strong>all of its input ports have been set</strong>: each time an input port is triggered, this policy automatically determines if it was the last one still unset and, if yes, it executes the <tt class="docutils literal">activate/1</tt> method.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>This policy used also to take care, once that method had been executed, of automatically setting back all input ports to their <tt class="docutils literal">unset</tt> state.</p>
<p class="last">As at least some models rely on &quot;stable&quot; inputs (inputs that vary infrequently, if ever - and thus may be set only once, but read multiple times), we preferred disabling that mechanism. So, now, in all cases, <em>input ports are never automatically unset</em>.</p>
</div>
<p><span class="raw-html"><center><img src="activate-when-all-set-policy.png" id="responsive-image-tiny"></img></center></span>
</p>
<p>This <em>Activate When All Set</em> policy (sometimes shortened as the &quot;When All&quot; policy) is graphically symbolized as a star resembling to a lock, to denote that no associated unit computation will take place until all input ports have been enabled (i.e. are set).</p>
</div>
<div class="section" id="custom-activation-policies">
<h2><a class="toc-backref" href="#id105">Custom Activation Policies</a></h2>
<p>Some units may require, under rare circumstances, a custom policy, i.e. <strong>a policy of their own</strong> that does not match any of the built-in ones.</p>
<p>For example source units, i.e. units not having any input port, can be defined, but of course then none of the policies above can apply (as they can never be triggered). Nevertheless such source units are typically needed in order to bootstrap the processing of a dataflow.</p>
<p>To solve this, rather than forcing the definition of at least one &quot;dummy&quot; input port per unit, <strong>all units can also be explicitly triggered</strong>: they can rely on their <tt class="docutils literal">activateExplicitly/2</tt> actor oneway for that, in charge of calling their <tt class="docutils literal">activate/1</tt> oneway as other policies do.</p>
<p>This policy may for example also be used to account for units having fixed, active temporalities. A daily-activated unit may schedule itself every 24 hours (declaring such a regular spontaneous scheduling, during which it may activate its output ports), while another unit may be ruled per-hour.</p>
<p>So dataflows can federate mixed temporalities, knowing that the use of this policy of explicit activation is fully optional (as by default a dataflow is fully passive and is only driven by changes in its input ports) and shall be regarded only as a last resort, should the built-in policies be insufficient.</p>
<p><span class="raw-html"><center><img src="custom-activation-policy.png" id="responsive-image-tiny"></img></center></span>
</p>
<p>This <em>Custom</em> policy is graphically symbolized as a sheet of paper, to denote that the unit activation is driven by a freely chosen user-specified logic.</p>
<p></p>
</div>
</div>
<div class="section" id="on-dataflow-objects">
<span id="dataflow-objects"></span><h1><a class="toc-backref" href="#id106">On Dataflow Objects</a></h1>
<p>We asserted previously that the most common form of dataflow block is the processing unit; the other major form is the <em>dataflow object</em>, discussed here.</p>
<p>Indeed, if dataflow units allow to describe the computations that shall be performed, generally they have to rely on the structure of the simulated world in order to feed their computations with relevant data.</p>
<p>Holding these information, and possibly making them change over time, is the purpose of the <strong>dataflow objects</strong>. They are plain, standard (Sim-Diasca) actors, except that they may define <em>dataflow attributes</em>, i.e. their own state attributes that can be involved in dataflows.</p>
<p>To a dataflow attribute is indeed generally associated a pair of ports, an input one and an output one. These ports allow to bridge the gap between two worlds:</p>
<ul class="simple">
<li>the one of the <strong>multi-agent, dynamic, loosely coupled actors</strong>, serving the purpose of <em>describing</em> a disaggregated target system and its evolution</li>
<li>the one of the (mostly statically connected) <strong>dataflow units</strong>, in charge of performing <em>computations</em> over a target system</li>
</ul>
<p>A dataflow object is represented with the light-blue background that is common to all dataflow blocks, while each of its attributes is associated to an input and/or an output port (typically both), like in:</p>
<p><span class="raw-html"><center><img src="dataflow-objects-example.png" id="responsive-image-small"></img></center></span>
</p>
<p>In this example, all attributes are standard, &quot;bidirectional&quot; attributes (they can be read and/or written by other dataflow blocks), except the maintenance cost, which is a &quot;terminal&quot; attribute (in the sense that it can be set, yet cannot be read by other blocks of the dataflow).</p>
<p></p>
</div>
<div class="section" id="on-model-assemblies">
<span id="model-assemblies"></span><h1><a class="toc-backref" href="#id107">On Model Assemblies</a></h1>
<div class="section" id="defining-the-notion-of-assembly">
<h2><a class="toc-backref" href="#id108">Defining the Notion of Assembly</a></h2>
<p>As seen already, within simulations, the target system (ex: a city) is translated into a set of instances of dataflow objects of various types (ex: <tt class="docutils literal">Building</tt>, <tt class="docutils literal">Household</tt>, etc.), on which models - themselves made of a set of instances of processing units of various types (ex: <tt class="docutils literal">EnergyDemand</tt>, <tt class="docutils literal">PollutionExhausted</tt>, etc.), complemented with at least one unit manager - are to operate.</p>
<p>The (generally interconnected) set of models involved into a single simulation is named a <strong>model assembly</strong>.</p>
<p>Assemblies may comprise any number of models: generally at least one, most often multiple ones, since the purpose of this dataflow approach is to perform model coupling.</p>
<p>Let's from now adopt the convention that a <em>model name</em> is a series of alphanumerical characters (ex: <tt class="docutils literal">FoobarBazv2</tt>) and that its <em>canonical name</em> is the lowercase version of it (ex: <tt class="docutils literal">foobarbazv2</tt>).</p>
</div>
<div class="section" id="ad-hoc-assemblies">
<h2><a class="toc-backref" href="#id109">Ad-hoc Assemblies</a></h2>
<p>One option is that a <tt class="docutils literal">FoobarBazv2</tt> model is <em>directly</em> integrated in a dataflow thanks to an ad-hoc simulation case for a target assembly, a case whose name could be freely chosen (ex: <tt class="docutils literal">my_foobarbazv2_case.erl</tt>).</p>
<p>Then, in this simulation case (accounting for the corresponding assembly), all relevant <tt class="docutils literal">FoobarBazv2</tt>-specific settings would have to be directly specified (ex: the elements to deploy for it, the unit managers it is to rely on, etc.); note that these model-specific information would be somewhat hardcoded there.</p>
</div>
<div class="section" id="dynamic-composable-assemblies">
<h2><a class="toc-backref" href="#id110">Dynamic, Composable Assemblies</a></h2>
<p>Alternatively, rather than potentially duplicating these settings in all cases including that model, one may define instead a <tt class="docutils literal"><span class="pre">foobarbazv2-model.info</span></tt> file (note the use of its canonical name) that would centralise all the settings relevant for that model, in the Erlang term format <a class="footnote-reference" href="#id24" id="id23">[12]</a>.</p>
<p>For example it could result in this file having for content (note that these settings can be specified in any order):</p>
<pre class="code erlang literal-block">
<span class="c">% The elements specific to FoobarBazv2 that shall be deployed:
</span><span class="p">{</span> <span class="n">elements_to_deploy</span><span class="p">,</span> <span class="p">[</span> <span class="p">{</span> <span class="s">&quot;../csv/Foobar/Baz/version-2&quot;</span><span class="p">,</span> <span class="n">data</span> <span class="p">},</span>
                        <span class="p">{</span> <span class="s">&quot;../models/Foobar-Baz&quot;</span><span class="p">,</span> <span class="n">code</span> <span class="p">}</span> <span class="p">]</span> <span class="p">}.</span>

<span class="c">% To locate any Python module accounting for a processing unit:
</span><span class="p">{</span> <span class="n">language_bindings</span><span class="p">,</span> <span class="p">[</span> <span class="p">{</span> <span class="n">python</span><span class="p">,</span> <span class="p">[</span> <span class="s">&quot;my-project/Foobar-Baz/v2&quot;</span> <span class="p">]</span> <span class="p">}</span> <span class="p">]</span> <span class="p">}.</span>

<span class="c">% Here this model relies on two unit managers:
</span><span class="p">{</span> <span class="n">unit_managers</span><span class="p">,</span> <span class="p">[</span> <span class="n">class_FoobarBazEnergyUnitManager</span><span class="p">,</span>
                   <span class="n">class_FoobarBazPollutionUnitManager</span> <span class="p">]</span> <span class="p">}.</span>
</pre>
<table class="docutils footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id23">[12]</a></td><td>Hence this file will simply store a series of lines containing Erlang terms, each line ending with a dot (i.e. the format notably used by <a class="reference external" href="http://erlang.org/doc/man/file.html#consult-1">file:consult/1</a>).
We preferred this format over JSON as the scope of these information is strictly limited to the simulation, and being able to introduce comments here (i.e. lines starting with <tt class="docutils literal">%</tt>) is certainly useful.</td></tr>
</tbody>
</table>
<p>Defining the needs of a model as such enables the definition and use of dynamic assemblies, that can be freely be mixed and matched.</p>
<p>Indeed, should all the models of interest have their configuration file available, defining an assembly would just boil down to specify the names of the models it comprises (ex: <tt class="docutils literal">FoobarBazv2</tt>, <tt class="docutils literal">ACME</tt> and <tt class="docutils literal">ComputeShading</tt>; that's it).</p>
</div>
<div class="section" id="envisioned-extensions">
<h2><a class="toc-backref" href="#id111">Envisioned Extensions</a></h2>
<p>In the future, the <strong>disaggregated view</strong> of the simulation regarding the target system (decomposing it based on dataflow objects) could be the <strong>automatic byproduct of the gathering of the models within an assembly</strong>: each model would declare the dataflow objects it expects to plug into and the corresponding attributes (with metadata), then an automated merge would check that this coupling makes sense ( and would generate a disaggregated view out of it.</p>
<p>In said model-specific configuration file, we could have for example:</p>
<pre class="code erlang literal-block">
<span class="p">{</span> <span class="n">dataflow_objects</span><span class="p">,</span> <span class="p">[</span>
  <span class="p">{</span> <span class="n">class_Building</span><span class="p">,</span> <span class="p">[</span>
     <span class="c">% Name of the first attribute:
</span>     <span class="p">{</span> <span class="n">surface</span><span class="p">,</span>
       <span class="c">% Corresponding SUTC metadata:
</span>       <span class="c">% First the semantics:
</span>       <span class="p">[</span> <span class="s">&quot;http://foobar.org/surface&quot;</span> <span class="p">],</span>
       <span class="c">% Then the unit, type (no constraint here):
</span>       <span class="s">&quot;m^2&quot;</span><span class="p">,</span> <span class="nb">float</span> <span class="p">}.</span>
     <span class="p">{</span> <span class="n">construction_date</span><span class="p">,</span> <span class="p">...</span> <span class="p">}</span> <span class="p">]</span> <span class="p">},</span>

  <span class="p">{</span> <span class="n">class_Household</span><span class="p">,</span> <span class="p">[</span>
     <span class="p">{</span> <span class="n">child_count</span><span class="p">,</span> <span class="p">...</span> <span class="p">}</span> <span class="p">]</span> <span class="p">}</span> <span class="p">]</span> <span class="p">}.</span>
</pre>
<p>Then, before the start of the simulation, each model of the assembly could be requested about its dataflow objects, and they could be dynamically defined that way, if and only if, of each attribute of each dataflow object mentioned, all definitions agreed (equality operation to be defined for the SUTC metadata).</p>
<p></p>
</div>
</div>
<div class="section" id="a-more-complete-example">
<span id="more-complete-example"></span><h1><a class="toc-backref" href="#id112">A More Complete Example</a></h1>
<p>Here we took the case of an hypothetical modelling of a city, in which the target system happens to be disaggregated into districts, buildings, etc.</p>
<div class="section" id="a-view-onto-a-theoretical-simulation">
<h2><a class="toc-backref" href="#id113">A View Onto a Theoretical Simulation</a></h2>
<p>Here we propose to enforce an additional, stricter convention, which is that no two computation processing units shall interact <strong>directly</strong> (i.e. with an output port of one being linked to an input port of the other); their exchanges shall be <strong>mediated</strong> by at least one dataflow object instead. As a consequence a unit interacts solely with the target system.</p>
<p>Respecting such a convention allows to <strong>uncouple the processing units</strong> more completely: one can be used autonomously, even if the other is not used (or does not even exist).</p>
<p>As a result, this example simulation consists on the <strong>intersection of two mostly independent planes</strong>, the one of the target system (in light purple, based on dataflow objects) and the one of the computations applied on it (in light blue, based on computation units).</p>
<p>This intersection is implemented thanks to <em>dataflow objects</em> and the related channels (in blue), since they are making the bridge between the two planes.</p>
<p><span class="raw-html"><center><img src="dataflow-city-example.png" id="responsive-image-full"></img></center></span>
</p>
<p>One can also notice:</p>
<ul class="simple">
<li>two <strong>dataflow probes</strong> (on the right), should specific results have to be extracted from the dataflow (read here from the output ports of some blocks)</li>
<li>external <strong>state importer and exporter</strong>, supposing here that this simulation is integrated into a wider computation chain (respectively in charge of providing an input state of the world at each time step, and, once evaluated and updated by the dataflow, of reading back this state and possibly transferring it to other, third-party, computational components; they are specialised versions of <a class="reference internal" href="#experiment-entry-and-exit-points">experiment entry and exit points</a>).</li>
</ul>
<p>We can see that we have still here a rather high-level, abstract view of the dataflow: types are mentioned (ex: <tt class="docutils literal">Building</tt>) instead of instances (ex: <tt class="docutils literal">building_11</tt>, <tt class="docutils literal">building_12</tt>, etc.), and managers (discussed later in this document) are omitted.</p>
</div>
<div class="section" id="a-view-onto-an-actual-simulation">
<h2><a class="toc-backref" href="#id114">A View Onto an Actual Simulation</a></h2>
<p>The following instance-level diagram describes the simulation case whose sources are available in the <tt class="docutils literal"><span class="pre">mock-simulators/dataflow-urban-example</span></tt> directory:</p>
<p><span class="raw-html"><center><img src="urban-example-dataflow.png" id="responsive-image-full"></img></center></span>
</p>
<p>This case demonstrates the following elements:</p>
<ul class="simple">
<li>two specific entry and exit experiment points</li>
<li>two types of processing units, one of which relies on an (input) port iteration</li>
<li>four unit instances</li>
<li>two unit activation policies</li>
</ul>
<p>To run that example:</p>
<pre class="code bash literal-block">
$ <span class="nb">cd</span> mock-simulators/dataflow-urban-example/src
$ make batch
</pre>
<p>Alternatively, to run a display-enabled version thereof, one may run <tt class="docutils literal">make run</tt> instead.</p>
<p></p>
</div>
</div>
<div class="section" id="developing-dataflow-elements-in-other-programming-languages">
<h1><a class="toc-backref" href="#id115">Developing Dataflow Elements in Other Programming Languages</a></h1>
<p>The dataflow infrastructure, like the rest of Sim-Diasca, uses a single implementation language, <a class="reference external" href="http://erlang.org">Erlang</a>, which may be readily used in order to implement, notably, dataflow processing units.</p>
<p>However it may be useful to introduce, in one's simulation, dataflow blocks (ex: a set of processing units corresponding to at least one model) that are implemented in other programming languages, especially if they are for the most part already developed and complex: integrating them in a dataflow might involve less efforts than redeveloping them.</p>
<p>To ease these integrations, <strong>language bindings</strong> have been defined, currently for the <tt class="docutils literal">Python</tt> and the <tt class="docutils literal">Java</tt> languages - still to be used from GNU/Linux. These bindings provide <strong>APIs in order to develop dataflow constructs</strong> in these languages and have them take part to the simulations.</p>
<p>Note that a language binding often induces the use of a specific version of the associated programming language (ex: the Python binding may target a specific version of Python). We tend to prefer the latest stable versions for these languages (as they are generally more stable and provide more features), however in some cases some helper libraries that might be proposed for inclusion by models (for their internal use) may not be updated yet.</p>
<p>In that case, should these extra dependencies be acknowledged, a language downgrade <em>may</em> be feasible, until these libraries are made compliant again with the current language version.</p>
<p>One should refer to the <em>Sim-Diasca Coupling HOWTO</em> for further information regarding how third-party code can be introduced in a Sim-Diasca simulation, whether or not it is done in a dataflow context.</p>
<p></p>
<div class="section" id="python-dataflow-binding">
<h2><a class="toc-backref" href="#id116">Python Dataflow Binding</a></h2>
<div class="section" id="general-information">
<h3>General Information</h3>
<p>This binding allows to use the <a class="reference external" href="https://www.python.org/">Python</a> programming language, typically to write dataflow processing units.</p>
<p>The Python version <tt class="docutils literal">3.6.0</tt> (released on December 23rd, 2016) or more recent is to be used. We recommend to stick to the latest stable one (available <a class="reference external" href="https://www.python.org/downloads/">here</a>). Let's designate by <tt class="docutils literal">A.B.C</tt> the actual version of Python that is used (ex: <tt class="docutils literal">A.B.C=3.6.0</tt>).</p>
<p>A Python <a class="reference external" href="http://docs.python-guide.org/en/latest/dev/virtualenvs/">virtual environment</a>, named <tt class="docutils literal"><span class="pre">sim-diasca-dataflow-env</span></tt>, is provided to ease developments.</p>
</div>
<div class="section" id="binding-archive">
<h3>Binding Archive</h3>
<p>All necessary binding elements (notably the virtual environment and the sources) are provided in a separate archive (which includes notably a full Python install), which bears the same version number as the one of the associated Sim-Diasca install <a class="footnote-reference" href="#id26" id="id25">[13]</a>.</p>
<table class="docutils footnote" frame="void" id="id26" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id25">[13]</a></td><td>The sources of this binding in the Sim-Diasca repository can be found in <tt class="docutils literal"><span class="pre">sim-diasca/src/core/src/dataflow/bindings/python/src</span></tt> (from now it is called &quot;the binding repository&quot;).</td></tr>
</tbody>
</table>
<p>This binding archive has to be extracted first:</p>
<pre class="code bash literal-block">
$ tar xvjf Sim-Diasca-x.y.z-dataflow-python-binding.tar.bz2
$ <span class="nb">cd</span> Sim-Diasca-x.y.z-dataflow-python-binding
</pre>
</div>
<div class="section" id="python-virtual-environment">
<h3>Python Virtual Environment</h3>
<p>It should be ensured first that <tt class="docutils literal">pip</tt> (actually <tt class="docutils literal">pipA.B</tt>, like in <tt class="docutils literal">pip3.6</tt>) and <tt class="docutils literal">virtualenv</tt> are installed.</p>
<p>For example, in Arch Linux (as root), supposing that a direct Internet connection available:</p>
<pre class="code bash literal-block">
$ pacman -Sy python-pip
$ pip install virtualenv
</pre>
<p>We will make here direct use of the virtual environment that will be obtained next; one may alternatively use <a class="reference external" href="http://virtualenvwrapper.readthedocs.io/en/latest/index.html">virtualenvwrapper</a> for easier operations.</p>
<div class="section" id="recommended-getting-this-virtual-environment-directly-from-the-binding-archive">
<h4>Recommended: Getting this Virtual Environment Directly from the Binding Archive</h4>
<p>The virtual environment corresponding to this binding is located at the root of the archive, in the <tt class="docutils literal"><span class="pre">sim-diasca-dataflow-env</span></tt> tree.</p>
<p>It can be used as it is, without further effort.</p>
</div>
<div class="section" id="alternate-mode-of-operation-recreating-this-virtual-environment">
<h4>Alternate Mode of Operation: Recreating this Virtual Environment</h4>
<p>If using directly the binding archive is the recommended approach, in some cases one may nevertheless want to recreate the virtual environment by oneself.</p>
<p>Then, as a normal user, an empty environment shall be created, activated and populated with the right packages:</p>
<pre class="code bash literal-block">
$ virtualenv sim-diasca-dataflow-env --python<span class="o">=</span>pythonA.B
$ <span class="nb">source</span> sim-diasca-dataflow-env/bin/activate
$ pip install -r sim-diasca-dataflow-env-requirements.txt
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Care must be taken so that the same <tt class="docutils literal">A.B</tt> Python version as the one in the archive is specified here.</p>
<p class="last">We hereby supposed that the <tt class="docutils literal">Bash</tt> shell is used. If <tt class="docutils literal">csh</tt> or <tt class="docutils literal">fish</tt> is used instead, use the <tt class="docutils literal">activate.csh</tt> or <tt class="docutils literal">activate.fish</tt> counterpart scripts.</p>
</div>
</div>
<div class="section" id="using-this-virtual-environment">
<h4>Using this Virtual Environment</h4>
<p>To begin using it, if not already done, one should activate it first:</p>
<pre class="code bash literal-block">
$ <span class="nb">source</span> sim-diasca-dataflow-env/bin/activate
</pre>
<p>Then all shell commands will use a prompt starting with <tt class="docutils literal"><span class="pre">&quot;(sim-diasca-dataflow-env)&quot;</span></tt> to avoid that the user forgets that this environment is enabled.</p>
<p>Packages provided in this environment shall be managed thanks to <a class="reference external" href="https://pypi.python.org/pypi/pip">pip</a>.</p>
<p>The list of the packages used by default by the binding is maintained in the <tt class="docutils literal"><span class="pre">sim-diasca-dataflow-env-requirements.txt</span></tt> file (available at the root of both the binding archive and repository) <a class="footnote-reference" href="#id28" id="id27">[14]</a>.</p>
<table class="docutils footnote" frame="void" id="id28" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id27">[14]</a></td><td>It is obtained thanks to: <tt class="docutils literal">pip freeze &gt; <span class="pre">sim-diasca-dataflow-env-requirements.txt</span></tt>.</td></tr>
</tbody>
</table>
<p>From now on, any additional package that one installs (using <tt class="docutils literal">pip</tt>) will be placed in this <tt class="docutils literal"><span class="pre">sim-diasca-dataflow-env</span></tt> directory, in isolation from the global Python installation.</p>
<p>The list of the packages currently used (in the context of this virtual environment) can be obtained thanks to:</p>
<pre class="code bash literal-block">
$ pip list
</pre>
<p>Once finished with it, the virtual environment can be deactivated with <tt class="docutils literal">deactivate</tt> (now directly available from the <tt class="docutils literal">PATH</tt>):</p>
<pre class="code bash literal-block">
$ deactivate
</pre>
</div>
</div>
<div class="section" id="sources-of-the-binding">
<h3>Sources of the Binding</h3>
<p>The binding itself, relying for its execution on the aforementioned virtual environment, is a regular (as opposed to a <a class="reference external" href="https://docs.python.org/3/reference/import.html#namespace-packages">namespace</a> one) <a class="reference external" href="https://docs.python.org/3/tutorial/modules.html#packages">Python package</a> named <tt class="docutils literal">sim_diasca_dataflow_binding</tt>, located under the same name at the root of the binding archive <a class="footnote-reference" href="#id30" id="id29">[15]</a>.</p>
<table class="docutils footnote" frame="void" id="id30" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id29">[15]</a></td><td>As mentioned before, its sources in our repository are located in the <tt class="docutils literal"><span class="pre">sim-diasca/src/core/src/dataflow/bindings/python/src</span></tt> directory.</td></tr>
</tbody>
</table>
<p></p>
</div>
<div class="section" id="use-of-the-binding">
<h3>Use of the Binding</h3>
<p>Let's take the example of a user-defined processing unit, let's say in <tt class="docutils literal">my_example_unit.py</tt>, that may be graphically described as:</p>
<p><span class="raw-html"><center><img src="python-unit-example.png" id="responsive-image-medium"></img></center></span>
</p>
<p>Its corresponding Python-based full implementation may be:</p>
<pre class="code python literal-block">
<span class="kn">from</span> <span class="nn">sim_diasca_dataflow_binding.common</span> <span class="kn">import</span> <span class="n">trace</span>
<span class="kn">from</span> <span class="nn">sim_diasca_dataflow_binding.common</span> <span class="kn">import</span> <span class="n">error</span>
<span class="kn">from</span> <span class="nn">sim_diasca_dataflow_binding.dataflow</span> <span class="kn">import</span> <span class="n">unit</span>

<span class="k">class</span> <span class="nc">MyExampleUnit</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">ProcessingUnit</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;A unit computing heat and fees; 2 input ports, 1 output one.&quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">:</span><span class="n">UnitName</span><span class="p">,</span><span class="n">relative_fee</span><span class="p">:</span><span class="nb">float</span><span class="p">):</span>

    <span class="c1"># A static, constant fee applied to some costs:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">fixed_fee</span> <span class="o">=</span> <span class="mf">115.0</span>

    <span class="c1"># An instance-specific proportional fee:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">relative_fee</span> <span class="o">=</span> <span class="n">relative_fee</span>

    <span class="n">my_input_specs</span> <span class="o">=</span> <span class="p">[</span>
      <span class="n">InputPortSpec</span><span class="p">(</span><span class="s1">'heat_produced'</span><span class="p">,</span><span class="s1">'http://foo.org/heat'</span><span class="p">,</span><span class="s1">'kW.h'</span><span class="p">,</span><span class="s1">'float'</span><span class="p">),</span>
      <span class="n">InputPortSpec</span><span class="p">(</span><span class="s1">'unitary_cost'</span><span class="p">,</span><span class="s1">'http://foo.org/cost'</span><span class="p">,</span><span class="s1">'$'</span><span class="p">,</span><span class="s1">'integer'</span><span class="p">)</span> <span class="p">]</span>

    <span class="n">my_output_specs</span> <span class="o">=</span> <span class="p">[</span> <span class="n">OutputPortSpec</span><span class="p">(</span><span class="s1">'integrated_cost'</span><span class="p">,</span>
      <span class="s1">'http://foo.org/cost'</span><span class="p">,</span><span class="s1">'$'</span><span class="p">,</span><span class="s1">'float'</span><span class="p">)</span> <span class="p">]</span>

    <span class="n">unit</span><span class="o">.</span><span class="n">ProcessingUnit</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">my_input_specs</span><span class="p">,</span>
      <span class="n">my_output_specs</span><span class="p">,</span><span class="n">ActivationPolicy</span><span class="o">.</span><span class="n">on_new_set</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">activate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Automatically called by the dataflow, as requested by
       the selected activation policy.&quot;&quot;&quot;</span>

    <span class="n">input_cost_port</span><span class="o">=</span><span class="s1">'unitary_cost'</span>
    <span class="c1"># 'Activate On New Set' policy, hence may be unset:</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set</span><span class="p">(</span><span class="n">input_cost_port</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing fees.&quot;</span><span class="p">)</span>
      <span class="n">cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_input_port_value</span><span class="p">(</span><span class="n">input_cost_port</span><span class="p">)</span>
      <span class="n">new_cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_fees</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">set_output_port_value</span><span class="p">(</span><span class="s1">'integrated_cost'</span><span class="p">,</span>
          <span class="n">new_cost</span><span class="p">)</span>

  <span class="c1"># The domain-specific logic is best placed outside of the</span>
  <span class="c1"># dataflow logic:</span>
  <span class="k">def</span> <span class="nf">apply_fees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cost</span><span class="p">:</span><span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Applies all fees to specified cost.&quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fee</span> <span class="o">+</span> <span class="n">cost</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_fee</span>
</pre>
<p>For reference, in <tt class="docutils literal">sim_diasca_dataflow_binding/dataflow/unit.py</tt>, we may have the following definitions (used in our example unit above):</p>
<pre class="code python literal-block">
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>

<span class="c1"># Type aliases (mostly for documentation purposes):</span>

<span class="n">Semantics</span> <span class="o">=</span> <span class="nb">str</span>
<span class="n">Unit</span> <span class="o">=</span> <span class="nb">str</span>
<span class="n">Type</span> <span class="o">=</span> <span class="nb">str</span>
<span class="n">Constraint</span> <span class="o">=</span> <span class="nb">str</span>

<span class="n">BlockName</span> <span class="o">=</span> <span class="nb">str</span>

<span class="n">PortName</span> <span class="o">=</span> <span class="nb">str</span>
<span class="n">InputPortName</span> <span class="o">=</span> <span class="n">PortName</span>
<span class="n">OutputPortName</span> <span class="o">=</span> <span class="n">PortName</span>

<span class="n">PortValue</span> <span class="o">=</span> <span class="n">Any</span>

<span class="c1"># Taken from https://docs.python.org/3/library/enum.html#functional-api:</span>
<span class="k">class</span> <span class="nc">AutoNumberedEnum</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
   <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
       <span class="n">value</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">__members__</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
       <span class="n">obj</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
       <span class="n">obj</span><span class="o">.</span><span class="n">_value_</span> <span class="o">=</span> <span class="n">value</span>
       <span class="k">return</span> <span class="n">obj</span>


<span class="k">class</span> <span class="nc">ActivationPolicy</span><span class="p">(</span><span class="n">AutoNumberedEnum</span><span class="p">):</span>
   <span class="n">on_new_set</span> <span class="o">=</span> <span class="p">()</span>
   <span class="n">when_all_set</span> <span class="o">=</span> <span class="p">()</span>
   <span class="n">custom</span> <span class="o">=</span> <span class="p">()</span>

<span class="k">class</span> <span class="nc">InputPortSpec</span><span class="p">():</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span><span class="n">InputPortName</span><span class="p">,</span> <span class="n">semantics</span><span class="p">:</span><span class="n">Semantics</span><span class="p">,</span>
      <span class="n">unit</span><span class="p">:</span><span class="n">Unit</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span><span class="n">Type</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="n">List</span><span class="p">[</span><span class="n">Constraint</span><span class="p">]</span> <span class="p">):</span>
    <span class="p">[</span><span class="o">...</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">OutputPortSpec</span><span class="p">():</span>
    <span class="p">[</span><span class="o">...</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">Port</span><span class="p">():</span>
    <span class="p">[</span><span class="o">...</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">InputPort</span><span class="p">(</span><span class="n">Port</span><span class="p">):</span>
    <span class="p">[</span><span class="o">...</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">OutputPort</span><span class="p">(</span><span class="n">Port</span><span class="p">):</span>
    <span class="p">[</span><span class="o">...</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">ProcessingUnit</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">Emitter</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Base, abstract, dataflow processing unit.&quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span><span class="n">UnitName</span><span class="p">,</span> <span class="n">input_specs</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="n">InputPortSpec</span><span class="p">],</span>
                  <span class="n">output_specs</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="n">OutputPortSpec</span><span class="p">],</span>
                  <span class="n">activation_policy</span><span class="p">:</span><span class="n">ActivationPolicy</span><span class="p">):</span>

    <span class="c1"># Class-specific attribute declaration:</span>
    <span class="c1">#  - input_ports={} : Mapping[InputPort]</span>
    <span class="c1">#  - output_ports={}: Mapping[OutputPort]</span>
    <span class="c1">#  - activation_policy: ActivationPolicy</span>

    <span class="n">trace</span><span class="o">.</span><span class="n">Emitter</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">category</span><span class="o">=</span><span class="s2">&quot;dataflow.unit&quot;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s2">&quot;Being initialised.&quot;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">register_input_ports</span><span class="p">(</span><span class="n">input_specs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">register_output_ports</span><span class="p">(</span><span class="n">output_specs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">activation_policy</span><span class="o">=</span><span class="n">validate_activation_policy</span><span class="p">(</span><span class="n">activation_policy</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">register_input_ports</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">specs</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="n">InputPortSpec</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="p">[</span><span class="o">...</span><span class="p">]</span>

  <span class="k">def</span> <span class="nf">register_output_ports</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">specs</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="n">OutputPortSpec</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="p">[</span><span class="o">...</span><span class="p">]</span>

  <span class="k">def</span> <span class="nf">validate_activation_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">:</span><span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ActivationPolicy</span><span class="p">:</span>
    <span class="p">[</span><span class="o">...</span><span class="p">]</span>

  <span class="k">def</span> <span class="nf">is_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">:</span><span class="n">InputPortName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Tells whether specified input port is currently set.&quot;&quot;&quot;</span>
    <span class="p">[</span><span class="o">...</span><span class="p">]</span>

  <span class="k">def</span> <span class="nf">get_input_port_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">:</span><span class="n">InputPortName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PortValue</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns the value to which the specified input port is set.
       Raises ValueNotSetError if the port is not set.
    &quot;&quot;&quot;</span>
    <span class="p">[</span><span class="o">...</span><span class="p">]</span>

  <span class="k">def</span> <span class="nf">set_output_port_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">:</span><span class="n">OutputPortName</span><span class="p">,</span><span class="n">PortValue</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="p">[</span><span class="o">...</span><span class="p">]</span>


  <span class="k">def</span> <span class="nf">activate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Evaluates the processing borne by that unit.

    Once a unit gets activated, it is typically expected that it reads
    its (set) input ports and, based on their value and on its own state,
    that it set its output ports accordingly.
    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
</pre>
</div>
<div class="section" id="binding-implementation">
<h3>Binding Implementation</h3>
<p>The Python dataflow binding relies on <a class="reference external" href="http://erlport.org/">ErlPort</a> for its mode of operation.</p>
<p>Please refer to the <tt class="docutils literal"><span class="pre">Sim-Diasca</span> Technical Manual</tt> to properly install this binding.</p>
<p></p>
</div>
</div>
<div class="section" id="java-dataflow-binding">
<h2><a class="toc-backref" href="#id117">Java Dataflow Binding</a></h2>
<p>This binding allows to use the <a class="reference external" href="https://www.java.com/">Java</a> programming language, typically to write dataflow processing units.</p>
<p>The Java version <tt class="docutils literal">8</tt> or higher is recommended.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Unlike the Python one, the Java Binding is not ready for use yet.</p>
</div>
</div>
<div class="section" id="other-language-bindings">
<h2><a class="toc-backref" href="#id118">Other Language Bindings</a></h2>
<p>A low-hanging fruit could be <a class="reference external" href="https://www.ruby-lang.org/">Ruby</a>, whose binding could be provided relatively easily thanks to <a class="reference external" href="http://erlport.org/">ErlPort</a>.</p>
<p><a class="reference external" href="https://www.rust-lang.org/">Rust</a> could be quite useful to support as well.</p>
<p></p>
</div>
</div>
<div class="section" id="more-advanced-dataflow-uses">
<h1><a class="toc-backref" href="#id119">More Advanced Dataflow Uses</a></h1>
<div class="section" id="dynamic-update-of-the-dataflow">
<h2><a class="toc-backref" href="#id120">Dynamic Update of the Dataflow</a></h2>
<p>One may imagine, dynamically (i.e. in the course of the simulation):</p>
<ul class="simple">
<li>creating or destroying blocks</li>
<li>creating or destroying channels</li>
<li>updating the connectivity of channels and blocks</li>
<li>creating or destroying input or output ports of a block</li>
</ul>
<p>This would be useful as soon as the target system is itself <strong>dynamic</strong> in some way (ex: buildings being created in a city over the years, each building relying on its associated computation units - which thus have to be dynamic as well, at least with varying multiplicities).</p>
<p>Moreover, often all the overall layout cannot be statically defined, and the dataflow as a whole has to be dynamically connected to the components feeding it or waiting for its outputs (ex: a database reader having to connect in some way to some input ports) - so some amount of <strong>flexibility</strong> is definitively needed.</p>
</div>
<div class="section" id="iteration-specification-iterated-ports">
<span id="port-iterations"></span><h2><a class="toc-backref" href="#id121">Iteration Specification &amp; Iterated Ports</a></h2>
<div class="section" id="usage-overview">
<h3>Usage Overview</h3>
<p>In some cases, a given type of unit may support instances that can have, each, <strong>an arbitrary number of ports relying on identical metadata</strong> (i.e. ports that have to obey the exact same specifications).</p>
<p>An example of that is a processing unit aggregating a given metrics associated to each building of a given area: each instance of that unit may have as many input ports (all having then exactly the same metadata) as there are different buildings in its associated area, and the class cannot anticipate the number of such ports that shall exist in its various instances <a class="footnote-reference" href="#id33" id="id32">[16]</a>.</p>
<table class="docutils footnote" frame="void" id="id33" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id32">[16]</a></td><td>Not to mention that buildings may be created and destroyed in the course of the simulation, so, even for any given instance, the number of ports may have to change over simulation time...</td></tr>
</tbody>
</table>
<p>Supporting <strong>iterated ports</strong> spares the need of defining many ports that would happen to all obey the same specification; typically, instead of declaring by hand an <tt class="docutils literal">energy_demand</tt> port and similar look-alike ports (that could be named <tt class="docutils literal">energy_demand_second</tt>, <tt class="docutils literal">energy_demand_third</tt>, etc.) with the same settings, an <tt class="docutils literal">energy_demand(initial,min,max)</tt> port iteration can be specified.</p>
<p>This leads, for each instance of this unit, to the creation of <tt class="docutils literal">initial</tt> different iterated ports, all respecting the <tt class="docutils literal">energy_demand</tt> port specification.</p>
<p>At any time, for each of these unit instances, there would be at least <tt class="docutils literal">min</tt> instances of such ports, and no more than <tt class="docutils literal">max</tt> - that can be either a positive integer, a named variable or the <tt class="docutils literal">*</tt> (wildcard) symbol, meaning here that a finite yet unspecified and unbounded number of these ports can exist.</p>
<p>More precisely, in a way relatively similar to the UML conventions regarding multiplicities, for a given port iteration one may specify either a fixed number of iterated ports, or a range:</p>
<p><span class="raw-html"><center></span></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="17%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Multiplicity</th>
<th class="head">Examples</th>
<th class="head">Meaning: for this iteration, at all times there will be:</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Fixed constant</td>
<td>7</td>
<td>Exactly 7 iterated ports</td>
</tr>
<tr><td>Variable name</td>
<td><tt class="docutils literal">n</tt></td>
<td>Exactly <tt class="docutils literal">n</tt> iterated ports</td>
</tr>
<tr><td><tt class="docutils literal">*</tt></td>
<td><tt class="docutils literal">*</tt></td>
<td>Any number of iterated ports</td>
</tr>
<tr><td>Min..Max</td>
<td>0..4,a..b, 2..*</td>
<td>Between Min and Max iterated ports (bounds included)</td>
</tr>
</tbody>
</table>
<p><span class="raw-html"></center></span></p>
<p>In a given dataflow, variable names (ex: <tt class="docutils literal">m</tt>, <tt class="docutils literal">n</tt>, <tt class="docutils literal">o</tt>, etc.) are expected to match. For example, if the variable <tt class="docutils literal">n</tt> is referenced more than once in the dataflow, then all its occurrences refer to the same value (which is let unspecified in the diagram).</p>
<p>Iterated ports are automatically named by the runtime (ex: <tt class="docutils literal">energy_demand_iterated_1</tt>, <tt class="docutils literal">energy_demand_iterated_2</tt>); they are standard ports and thus their name shall remain an identifier <a class="footnote-reference" href="#id35" id="id34">[17]</a>.</p>
<table class="docutils footnote" frame="void" id="id35" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id34">[17]</a></td><td>This is why the runtime enforces the single restriction that applies to port names, which is that the <tt class="docutils literal">_iterated_</tt> substring cannot exist in such a user-defined name.</td></tr>
</tbody>
</table>
<p>Graphically, the set of ports corresponding to an iteration is represented as a rectangle enclosing these iterated ports (when representing actual instances, the rectangle may be empty); multiplicities are to be specified between brackets (to distinguish them from the iteration name) and preferably at the bottom of the associated rectangle.</p>
<p>All these elements shall be of the same color as the one of the port. Any common metadata shall preferably be listed once.</p>
<p>An example of these conventions is the following processing unit, featuring two input and and two output port iterations:</p>
<p><span class="raw-html"><center><img src="port-iteration.png" id="responsive-image-medium"></img></center></span>
</p>
<p>We can see above that, at any time, the first input iteration shall have between 2 and 7 (included) iterated ports, while the second input iterations is detailed graphically and has exactly 5 iterated ports (<tt class="docutils literal">[5]</tt> is thus implied).</p>
<p>As for the output iterations, both have a certain number of iterated ports, and, as <tt class="docutils literal">k</tt> is different from <tt class="docutils literal">p</tt>, their respective counts of iterated ports may not match (ex: we can have <tt class="docutils literal">k=2</tt> and <tt class="docutils literal">p=0</tt>).</p>
</div>
<div class="section" id="in-terms-of-implementation">
<h3>In Terms of Implementation</h3>
<p>An <strong>iteration specification</strong> enables the creation of multiple (input or output) ports of the same type, each of these instances being designated as an <strong>iterated port</strong> (technically an iterated port is nothing but a standard port).</p>
<p>For example, defining an iteration specification of 3 instances named <tt class="docutils literal">foobar</tt>  will result in the creation of 3 actual (iterated) ports, each complying to this specification, and named <tt class="docutils literal">foobar_iterated_1</tt>, <tt class="docutils literal">foobar_iterated_2</tt> and <tt class="docutils literal">foobar_iterated_3</tt> <a class="footnote-reference" href="#id37" id="id36">[18]</a>.</p>
<table class="docutils footnote" frame="void" id="id37" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id36">[18]</a></td><td>As mentioned, once created, these three ports will be fully standard ports; the <tt class="docutils literal">_iterated_</tt> substring helps avoiding that the names of iterated ports clash with other ports (it convey no specific meaning as such).</td></tr>
</tbody>
</table>
<p>By default, port specifications are not iterated: in implementation terms, the <tt class="docutils literal">is_iterated</tt> field of a port specification is set to <tt class="docutils literal">false</tt>.</p>
<p>To enable the creation of iterated ports, the <tt class="docutils literal">is_iteration</tt> field of the corresponding port specification shall be set to either of these three forms:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">{Initial,{Min,Max}}</span></tt> where <tt class="docutils literal">Initial</tt> is the initial number of iterated ports to be created according to this specification, and <tt class="docutils literal">Min</tt> and <tt class="docutils literal">Max</tt> are respectively the minimum and maximum counts of corresponding iterated ports that are allowed to exist<ul>
<li>then the runtime will create the corresponding initial number of instances (whose name is suffixed as mentioned with an incremented number starting from 1), and ensure that, even in the presence of runtime port creations, the number of the corresponding iterated ports will remain within specified bounds</li>
<li><tt class="docutils literal">Initial</tt> and <tt class="docutils literal">Min</tt> are positive integers, while <tt class="docutils literal">Max</tt> can also be set to the <tt class="docutils literal">unbounded</tt> atom to allow for an unlimited number of such iterated ports; of course <tt class="docutils literal">Initial</tt> must be in the <tt class="docutils literal">{Min,Max}</tt> range</li>
</ul>
</li>
<li><tt class="docutils literal">{Initial,Max}</tt>, which is a shorthand of <tt class="docutils literal"><span class="pre">{Initial,{_Min=0,Max}}</span></tt></li>
<li><tt class="docutils literal">Initial</tt>, which is a shorthand of <tt class="docutils literal"><span class="pre">{Initial,{_Min=0,_Max=unbounded}}</span></tt></li>
</ul>
<p></p>
</div>
</div>
<div class="section" id="domain-specific-timestamps">
<h2><a class="toc-backref" href="#id122">Domain-Specific Timestamps</a></h2>
<p>By default, engine ticks directly translate to a real, quantified simulation time: depending on the starting timestamp and on the selected simulation frequency, a given tick corresponds to an <strong>exact time and date</strong> in the Gregorian calendar (ex: each month and year lasting for the right number of days - not respectively, for example, 30 and 365, a simplification that is done in some cases in order to remain in a constant time-step setting).</p>
<p>However, in some simulations, models are ruled by such a strange simplified time <a class="footnote-reference" href="#id39" id="id38">[19]</a>, so domain-specific timestamps may be useful. Their general form is <tt class="docutils literal"><span class="pre">{timescale(),index()}</span></tt>, where <tt class="docutils literal">timescale()</tt> designates the selected time granularity for the underlying channel (ex: <tt class="docutils literal">constant_year</tt>, <tt class="docutils literal">month_of_30_days</tt>) and <tt class="docutils literal">index()</tt> is a counter (a positive integer corresponding to as many periods of the specified time granularity).</p>
<table class="docutils footnote" frame="void" id="id39" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id38">[19]</a></td><td>Even if this oversimplification just by itself yields already significant relative errors (greater than 10%).</td></tr>
</tbody>
</table>
<p>For example, in a simulation some models may be evaluated at a yearly timescale, while others would be at a daily one. Considering that initial year and day have been set beforehand, a timestamp may become <tt class="docutils literal">{yearly,5}</tt> or <tt class="docutils literal">{daily,421}</tt>. This could be used to check that connected ports have indeed the same temporality (ex: no yearly port linked to a daily - a <em>timescale convertor unit</em> needing to be inserted in that case), and that none of such timescale-specific timesteps (i.e. index) went amiss in the channel.</p>
</div>
<div class="section" id="usefulness-of-cyclic-dataflows">
<h2><a class="toc-backref" href="#id123">Usefulness of Cyclic Dataflows?</a></h2>
<p>One can notice that cyclic dataflow graphs are allowed by this scheme based on input and output ports, and that even &quot;recursive dataflow objects&quot; (i.e. dataflow objects having one of their output port connected to one of their input ones) can exist.</p>
<p>Of course some convergence criterion is needed in order to avoid a never-ending evaluation.</p>
<p></p>
</div>
</div>
<div class="section" id="experiments">
<h1><a class="toc-backref" href="#id124">Experiments</a></h1>
<p>As mentioned in the <a class="reference internal" href="#experiment-definition">Experiment Definition</a> section, an experiment is the top-level abstraction in charge of <strong>driving the computations applying to a simulated world</strong>.</p>
<div class="section" id="purpose-of-experiment-endpoints">
<span id="experiment-entry-and-exit-points"></span><h2><a class="toc-backref" href="#id125">Purpose of Experiment Endpoints</a></h2>
<p>Depending on the project, it may be convenient for a given experiment relying on any number of dataflows to define a pair of components in charge of triggering and terminating its evaluation (typically once a specified number of steps were performed), as points of entry and exit, respectively.</p>
<p>For that, base classes are provided (<tt class="docutils literal">ExperimentEntryPoint</tt> and <tt class="docutils literal">ExperimentExitPoint</tt>) that are meant, if needed, to be subclassed on a per-project basis.</p>
<p>The purpose of these (optional) endpoints is to drive multiple dataflow instances, possibly on par with some external software (ex: any overall integration platform).</p>
<p>Their impact in the progress of an experiment is discussed next.</p>
</div>
<div class="section" id="experiment-progress">
<h2><a class="toc-backref" href="#id126">Experiment Progress</a></h2>
<p>In terms of logical ordering, the usual <strong>course of action of a dataflow-oriented simulation</strong> discussed here is <a class="footnote-reference" href="#id41" id="id40">[20]</a>:</p>
<ol class="arabic simple">
<li>a new simulation tick <tt class="docutils literal">T</tt> begins: the experiment entry point (which is an actor) is scheduled</li>
<li>a synchronisation stage, detailed in the next sections, occurs: the dataflows are suspended, and the state of the simulated world is updated first, then the computations that shall be applied on it are modified accordingly</li>
<li>then the dataflows are resumed, and it usually triggers (based on intermediate logical moments, i.e. diascas) in turn (source) dataflow objects and/or processing units</li>
<li>this may trigger cascading updates of dataflow elements over diascas</li>
<li>once all evaluations are done, the experiment exit point (another actor) is to wrap up all information and perform any related tick-termination operation (ex: sending an update regarding the newer state of the simulated world to a third-party platform)</li>
<li>then the next planned tick begins (usually this corresponds to <tt class="docutils literal">T+1</tt>), and the process continues until a termination criterion is met (typically a final timestamp is reached, or the simulation is notified that no changes are to be expected anymore)</li>
</ol>
<table class="docutils footnote" frame="void" id="id41" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id40">[20]</a></td><td>To shed some light on the related implementation (as the technical organisation is a bit different), please refer to the <a class="reference internal" href="#scheduling-cycle-of-experiments">Scheduling Cycle of Experiments</a>.</td></tr>
</tbody>
</table>
<p>As a result, the <strong>processing of a given timestep</strong> may boil down to an overall three-step process:</p>
<ol class="upperalpha simple">
<li>synchronisation of the state of the simulation from an external source (thanks to a state importer - generally an experiment entry point)</li>
<li>then evaluation of the corresponding dataflow</li>
<li>then update of an external target, based on the resulting state of the simulation (thanks a state exporter - generally an experiment exit point)</li>
</ol>
<p>These external source and target may actually correspond to the same data repository, held by a more general platform.</p>
<p>The rest of that HOWTO explained with great detail how step B is tackled. We will thereafter focus thus on step A, knowing that step C in many ways is a reciprocal of this step, and thus may be at least partly deduced from the understanding of step A.</p>
</div>
</div>
<div class="section" id="a-general-view-on-the-dataflow-synchronisation">
<h1><a class="toc-backref" href="#id127">A General View on the Dataflow Synchronisation</a></h1>
<p>The goal is to properly manage the <strong>transformation of a source dataflow into a target one</strong>, in the context of the simulation of a system.</p>
<p>More precisely, here the <em>source</em> dataflow is the one obtained after the evaluation of a timestep, while the <em>target</em> dataflow is the one that shall be evaluated at the next timestep.</p>
<p>In-between, an external operator may apply any kind of changes to the simulated system, and of course these changes shall be reflected onto its dataflow counterpart.</p>
<p>Such <strong>changes</strong> may be <strong>defined programmatically</strong> <a class="footnote-reference" href="#id44" id="id42">[21]</a> or be <strong>discovered at runtime from an external source</strong> <a class="footnote-reference" href="#id45" id="id43">[22]</a>. The next sections will focus on the latter case, which is the trickier to handle.</p>
<table class="docutils footnote" frame="void" id="id44" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id42">[21]</a></td><td>If the dataflow is to be managed programmatically (i.e. thanks to specific code), then a user-defined program is to use the various dataflow-relative primitives in order to create the initial state of the dataflow and possibly update it in the course of the simulation; see, in <tt class="docutils literal"><span class="pre">mock-simulators/dataflow-urban-example</span></tt>, the <tt class="docutils literal">dataflow_urban_example_programmatic_case.erl</tt> test case for that.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id45" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id43">[22]</a></td><td>This setting is illustrated by the <tt class="docutils literal">dataflow_urban_example_platform_emulating_case.erl</tt> test case.</td></tr>
</tbody>
</table>
<p>As already mentioned, dataflows are made of blocks, linked by channels, and two different sorts of blocks exists here:</p>
<ul class="simple">
<li>the <em>dataflow blocks</em>, which are in charge of describing the current state of the simulated world</li>
<li>the <em>dataflow processing units</em>, which are in charge of performing domain-specific computations onto that state</li>
</ul>
<p>Let's introduce first, and in a few words only, the main elements that are provided in order to transform a dataflow into another:</p>
<ul class="simple">
<li>the changes in the state of the simulated world are orchestrated by the <strong>World Manager</strong>, driving the various <strong>Object Managers</strong> for that</li>
<li>the changes in the computations to be operated are orchestrated by the <strong>Experiment Manager</strong>, driving the various <strong>Unit Managers</strong> for that</li>
<li>each change is described by an individual <strong>World Synchronisation Event</strong>, meant to affect potentially both the state of the simulated world and, in turn, the computations operated on it</li>
<li>a <strong>Changeset</strong> may aggregate many of these events, and a dataflow can be turned into another by simply applying a series of changesets</li>
</ul>
<p>The diagram below gives a synthetic, example view of the overall mode of operation in action:</p>
<p><span class="raw-html"><center><img src="manager-interactions.png" id="responsive-image-large"></img></center></span>
</p>
<p>Let's discuss now more precisely the various elements of the solution, and how they interact.</p>
</div>
<div class="section" id="the-world-manager-and-its-dataflow-object-managers">
<span id="world-manager"></span><h1><a class="toc-backref" href="#id128">The World Manager and its Dataflow Object Managers</a></h1>
<div class="section" id="purpose-of-the-world-manager">
<h2><a class="toc-backref" href="#id129">Purpose of the World Manager</a></h2>
<p>This manager (singleton instance of the <tt class="docutils literal">WorldManager</tt> class), whose shorthand is <tt class="docutils literal">WM</tt>, is used in order to <strong>create, update and keep track of the simulated world and its structure</strong>; this world is itself made of the target system of interest (ex: a city) and of its context (ex: its associated weather system, the other cities in the vicinity, etc.).</p>
<p>As a result, the world manager is generic, yet its use is specific to a given modelling structure (ex: to some way of describing a city), and bears no direct relationship with the computations that will be performed on it (one of its purposes is indeed to help uncoupling the description of the world of interest from the models operating on it, so that they can themselves be defined independently, one from another).</p>
<p>This virtual world is to be modelled based on <strong>various types of dataflow objects</strong>. For example, if the target system is a city, then districts, roads, buildings, weather elements, other cities, etc. may be defined (as types first, before planning their instantiaton) in order to represent the whole.</p>
<p>These dataflow objects, which account for the state of the simulation world, are to be defined <strong>individually</strong> (in terms of internal state; ex: a building has a <tt class="docutils literal">surface</tt> and an <tt class="docutils literal">height</tt> attributes, of corresponding SUTC metadata) and <strong>collectively</strong> (in terms of structure and relationships; ex: a building must be included in a district, and may comprise any number of dwellings).</p>
</div>
<div class="section" id="purpose-of-the-object-managers">
<h2><a class="toc-backref" href="#id130">Purpose of the Object Managers</a></h2>
<p>For each of these types of dataflow objects, an <strong>object manager</strong>, in charge of taking care of the corresponding dataflow objects (i.e. the instances of that type) must be defined <a class="footnote-reference" href="#id47" id="id46">[23]</a>. For example the <tt class="docutils literal">BuildingManager</tt> will take care of (all) <tt class="docutils literal">Building</tt> instances.</p>
<p>Note that a given object manager is to take care of <em>at least</em> one type of objects, possibly multiple ones (ex: if deemed more appropriate, a single object manager may be defined in order to take care of the buildings <em>and</em> of the households <em>and</em> and the districts).</p>
<table class="docutils footnote" frame="void" id="id47" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id46">[23]</a></td><td>All actual dataflow managers are either instances of the <tt class="docutils literal">DataflowObjectManager</tt> class (for the simpler cases), or child classes thereof (ex: to support specifically some kind of associations). All these managers are themselves simulation actors, as interacting with them in the course of the simulation may be necessary (ex: to create new object instances).</td></tr>
</tbody>
</table>
<p>The purpose of an object manager is to be the entry point whenever having to <strong>perform dataflow-level operations on the object instances</strong> of the type(s) it is in charge of (ex: actual buildings): in the course of the simulation, instances may indeed have to be properly created, associated, connected, modified, deleted, etc.</p>
<p>Finally, all dataflow object managers are federated by this <tt class="docutils literal">WM</tt> (<em>World Manager</em>), which is their direct parent, in charge of driving them all.</p>
<p>The main use of the world manager and of its associated dataflow object managers is the enabling of <strong>external state synchronization</strong>.</p>
<p>Should, for example, an overall, targeted simulation be actually performed by a pipe-line of platforms (including of course at least the one at hand, which is based on this dataflow infrastructure), at each time step the state of the simulation would need to be updated from these other platforms and, reciprocally, once modified by the dataflow-based one, would need to be passed to the next platforms.</p>
<p><strong>The various dataflow objects involved in the simulation have to reflect the current state of the world</strong>; for that, from one timestep to the next, changes have to be applied onto them. For example, if the evaluation runs on a yearly timestep, handling simulation year 2026 requires that changes that happened since the end of the dataflow evaluation of 2025 are taken into account before starting to simulate year 2026.</p>
</div>
<div class="section" id="expressing-dataflow-changes-through-world-events">
<h2><a class="toc-backref" href="#id131">Expressing Dataflow Changes Through World Events</a></h2>
<p>These changes are expressed at the dataflow level thanks to <strong>world (synchronisation) events</strong>. Following types of world events <a class="footnote-reference" href="#id49" id="id48">[24]</a> have been defined:</p>
<p><span class="raw-html"><center><img src="dataflow-world-events.png" id="responsive-image-small"></img></center></span>
</p>
<table class="docutils footnote" frame="void" id="id49" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id48">[24]</a></td><td>Refer to <tt class="docutils literal">dataflow_changesets_defines.hrl</tt> for their actual definitions: for each type of event, a corresponding datastructure is defined in order to store the identifier of each event, the type of dataflow object it refers to, the external and internal identifier of the instance(s) involved, extra type-specific information, etc.</td></tr>
</tbody>
</table>
<p>More precisely:</p>
<ul class="simple">
<li>a <strong>creation</strong> event describes the creation of a block, typically of a dataflow object (ex: building B2 being built in the city on the current year)</li>
<li>a <strong>deletion</strong> event describes the deletion of a block, typically of a dataflow object (ex: district D7 being destructed)</li>
<li>an <strong>association</strong> event describes the creation of an association between dataflow objects; a <em>binary</em> association is a very common, special case thereof (ex: building B2 is &quot;located in&quot; neighborhood N3)</li>
<li>a <strong>disassociation</strong> event describes the removal of an association between dataflow objects (ex: household H1 is not &quot;living in&quot; building B2 anymore)</li>
<li>a <strong>connection</strong> event describes the creation of a dataflow channel between two ports of blocks, from an output one to an input one (ex: from the <tt class="docutils literal">surface</tt> output port of building B6, to the <tt class="docutils literal">average_area</tt> input port of the land-use processing unit L9)</li>
<li>a <strong>disconnection</strong> event describes the deletion of a dataflow channel that used to exist between two ports</li>
<li>an <strong>update</strong> event describes the modification of the value of attributes of a dataflow object (ex: for building B2, the <tt class="docutils literal">surface</tt> attribute is set to 120.0 m^2, while its <tt class="docutils literal">inhabitant_count</tt> is set to 7)</li>
</ul>
<p>Should, for a given project, the incoming dataflow updates deal only with the <em>state</em> of the simulated world (not directly with the <em>computations</em> themselves - whose changes may be automatically deduced from the state ones at a latter step), only a subset of the types of world events are to be supported (by the world manager), namely all types of events but connections and disconnections.</p>
</div>
<div class="section" id="changetrees-and-changesets">
<h2><a class="toc-backref" href="#id132">Changetrees and Changesets</a></h2>
<p><strong>A given event may induce any number of other events</strong> (ex: a creation of a building may induce its association with a given district), which themselves may induce in turn other events, and so on.</p>
<p>As a result, we define the concept of <em>changetree</em> (an event and all the ones it induces, directly or not) and of <em>changeset</em> (a list of changetrees):</p>
<p><span class="raw-html"><center><img src="dataflow-changes.png" id="responsive-image-large"></img></center></span>
</p>
<p>It is the role of the dataflow entry point (typically fetching its informations from an external source) to stream the corresponding changesets to the world manager, and to notify it when the synchronisation has been fully described (i.e. when all changesets have been transmitted).</p>
</div>
<div class="section" id="changeset-crunching">
<h2><a class="toc-backref" href="#id133">Changeset Crunching</a></h2>
<p>When the world manager receives a changeset, <strong>it dispatches each event in turn to the relevant object manager</strong>, based on the type of the dataflow object to which this event applies. For example an event about the creation of a building will be transmitted to the object manager which declared it was in charge of the dataflow objects of type <tt class="docutils literal">Building</tt>.</p>
<p>Events are processed by the world manager based on their height on the pending changetrees, so that <strong>their order of induction is preserved</strong> : first the root events of all changetrees of the current changeset are dispatched (in an asynchronous way, all in parallel, during the same logical moment), then, when one of these events is reported (by the corresponding object manager) as completed, the world manager dispatches in turn the events that it is inducing, and so on (as a result, if event E1 induces event E2, the processing of E2 will not start before the completion of the processing of E1 <a class="footnote-reference" href="#id51" id="id50">[25]</a>). <strong>All the changetrees progress in parallel, and each at its maximum rate</strong> (knowing that not all operations triggered require the same number of diascas to complete).</p>
<table class="docutils footnote" frame="void" id="id51" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id50">[25]</a></td><td>This is a necessary feature; for example, if E1 is a creation of a building and E2 is its association, E2 will need to rely on an already fully created object before being able to define any association involving it.</td></tr>
</tbody>
</table>
<p>Moreover, when an object manager reports to the world manager the completion of event(s), <strong>it may as well inject new events</strong>. For example, if creating a building entails creating three lifts, then the building object manager may inject three additional lift creation events. Then these events will be processed, among the pending others, by the world manager, and thus will be dispatched to the lift object manager. This allows for an indirect communication between object managers, and to embed, if needed, domain-specific rules in order to structure appropriately the state of the simulated system.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>During the whole synchronisation phase, the blocks of the dataflow that are affected (ex: created or updated) are put in stasis, i.e. they are suspended.</p>
<p>Otherwise their evaluation could start whereas the dataflow did not reach yet a stable state, which could lead to an incorrect evaluation of the overall dataflow.</p>
<p class="last">To anticipate a bit, the actual evaluation will take place when the dataflow(s) will resume their suspended blocks, which will happen later - once the experiment manager will have finished its own synchronisation work.</p>
</div>
<p>As changesets are streamed and processed, the world manager collects the completed events, in a flat, ordered list: all events are enumerated there according to their processing/induction order (i.e. if E2 is induced by E1, E1 will be listed <em>before</em> E2), and they will not embed induced events anymore (so that each event is present exactly once in this flattened list).</p>
<p>Once in a final state (all changesets transmitted and processed), <strong>the corresponding overall aggregated completed changeset is sent to the next stage</strong> of the dataflow update, dealing this time with the computational part thereof - as explained in the next section.</p>
<p></p>
</div>
</div>
<div class="section" id="the-experiment-manager-and-its-unit-managers">
<span id="experiment-manager"></span><h1><a class="toc-backref" href="#id134">The Experiment Manager and its Unit Managers</a></h1>
<div class="section" id="purpose-of-the-experiment-manager">
<h2><a class="toc-backref" href="#id135">Purpose of the Experiment Manager</a></h2>
<p>The <em>Experiment Manager</em> is a component (singleton instance of the <tt class="docutils literal">ExperimentManager</tt> class), whose shorthand is <tt class="docutils literal">EM</tt>, and that is responsible for the <strong>management of the processing part of the dataflow(s)</strong>, i.e. of the <strong>computations</strong> that are to be operated on the simulated world, accounting for the experiment that is to take place onto the simulated world.</p>
<p>These (model-specific) computations are implemented by <strong>processing units</strong>, which are driven by the <strong>unit managers</strong> - which are themselves federated by the <strong>experiment manager</strong>.</p>
<p>As a result, the experiment manager is generic (while its use is domain-specific), and it can be seen as an orthogonal counterpart of the <a class="reference internal" href="#world-manager">world manager</a>, according to this table matching concepts:</p>
<p><span class="raw-html"><center></span></p>
<table border="1" class="docutils">
<colgroup>
<col width="51%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">State of the Simulated World</th>
<th class="head">Computations to be Operated</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Dataflow Object</td>
<td>Dataflow Processing Unit</td>
</tr>
<tr><td>Object Manager</td>
<td>Unit Manager</td>
</tr>
<tr><td>World Manager</td>
<td>Experiment Manager</td>
</tr>
</tbody>
</table>
<p><span class="raw-html"></center></span></p>
<p>Having them separated allows to isolate and uncouple more easily the operations to be performed from the elements they are to operate on. They however both rely on changesets to perform their operations.</p>
</div>
<div class="section" id="purpose-of-the-unit-managers">
<h2><a class="toc-backref" href="#id136">Purpose of the Unit Managers</a></h2>
<p>Dataflows may rely on any number of unit managers.</p>
<p>A <strong>Unit Manager</strong> is in charge of taking care of all instances of at least one <strong>type of units</strong> involved in the dataflow <a class="footnote-reference" href="#id53" id="id52">[26]</a>, for a given model; as such, a unit manager may typically create, delete, modify (including reconnecting) the units of the type(s) it supports.</p>
<table class="docutils footnote" frame="void" id="id53" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id52">[26]</a></td><td>All actual unit managers are child classes of the <tt class="docutils literal">UnitManager</tt> base class, to handle the operations specific to the types of the processing units that they support.</td></tr>
</tbody>
</table>
<p>Let's say for example that, for a given model, we have, among other ones, two types of processing units, <tt class="docutils literal">EnergyDemandUnit</tt> and <tt class="docutils literal">WaterDemandUnit</tt> that are to operate each on a given building.</p>
<p>A unit manager named <tt class="docutils literal">ResourceDemandUnitManager</tt> may be in charge of all instances of these two types of units, for example so that it can be ensured that the two kinds of demands are appropriately interlinked and applied consistently (ex: exactly to the same buildings).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Most models rely on multiple types of processing units - yet on a <em>single</em>, unified unit manager instance that drives them all.</p>
<p>However one can instead define, for a given model, <strong>multiple unit managers</strong>, each in charge of a subset of the types of processing units involved - provided that these unit managers partition these unit types, i.e. that each unit type is driven by exactly one unit manager instance.</p>
<p>If such a scheme allows the work on the processing units to be split in more autonomous parts, it induces limitations: relying on a single unit manager allows to store in its state <em>all</em> unified information about dataflow objects (based on the world events it listens to) and units (as, for that model, it is their sole manager), which is often necessary to perform proper channel creations (ex: to determine the right instance of processing unit to be connected to a given dataflow object).</p>
<p class="last">As a result, unit managers tend to define various associative tables, to keep track of which processing unit they created (ex: a pollution computation) in response to the creation of which dataflow object (ex: a car). Unit managers are then able to connect these units adequately, once they are reported as created.</p>
</div>
<p>As a result, each unit manager federates the units of specific types, so that it can perform - for computations and on behalf of the EM - what dataflow object managers perform for the simulated world on behalf of the WM <a class="footnote-reference" href="#id55" id="id54">[27]</a>: <strong>a unit manager will synchronise the computation part of the dataflow regarding these unit types</strong>.</p>
<table class="docutils footnote" frame="void" id="id55" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id54">[27]</a></td><td>Similarly to object managers, unit managers typically take part to the simulation (ex: they may create processing units) and therefore must be properly synchronized; as such they are simulation actors as well.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="mode-of-operation">
<h2><a class="toc-backref" href="#id137">Mode of Operation</a></h2>
<p>This synchronisation of the computational part of the dataflow could be explicitly dictated by an external source, as done previously for the part of the dataflow devoted to the description of the state of the simulated system. However, more often than not, <strong>the changes in the computation part may be determined automatically from the changes done on the state part, based on relevant rules</strong>. The purpose of the unit managers is to <em>implement</em> said rules.</p>
<p>To do so, each unit manager is to declare not only the types of processing units it is to manage (ex: <tt class="docutils literal">ResourceDemandUnitManager</tt> taking care of <tt class="docutils literal">EnergyDemandUnit</tt> and <tt class="docutils literal">WaterDemandUnit</tt>), but also the <strong>world synchronisation events it listens to</strong>, and <strong>how it is to react to them</strong>.</p>
<p>For example, <tt class="docutils literal">ResourceDemandUnitManager</tt> may request to be notified whenever a building is created and/or whenever the current operating state of a given heat pump changed (ex: from nominal mode to degraded mode). It may then choose to apply the relevant domain-specific actions in order to adapt the computations performed by the dataflow, such as, respectively, creating one instance of <tt class="docutils literal">EnergyDemandUnit</tt> and of <tt class="docutils literal">WaterDemandUnit</tt> and connecting them to the new building, or linking said heat pump to a different processing unit implementing a model corresponding to its new mode of operation (by updating their dataflow connectivity).</p>
<p>In practice, a given unit manager may declare (to the experiment manager) any number of <strong>event match clauses</strong> <a class="footnote-reference" href="#id58" id="id56">[28]</a>, whose granularity can be finely tuned (from a non-discriminating unit manager listening to all events of all types, to one focusing only on very precise matches <a class="footnote-reference" href="#id59" id="id57">[29]</a>).</p>
<table class="docutils footnote" frame="void" id="id58" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id56">[28]</a></td><td>Refer to <tt class="docutils literal">dataflow_changesets_defines.hrl</tt> for their actual definitions: for each type of event match (ex: <tt class="docutils literal">creation_event_match</tt>), a corresponding datastructure is defined in order to store against which element(s) of the corresponding event the match shall be done (ex: &quot;the (created) object type shall be of type <tt class="docutils literal">Building</tt>, it should occur in the context of this dataflow, involve a dataflow object bearing this external identifier and/or this internal one, specify these construction parameters, etc.).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id59" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id57">[29]</a></td><td>Of course a unit manager is free to perform any additional, arbitrary filtering it may need, simply by ignoring the notified events that would not be deemed of interest.</td></tr>
</tbody>
</table>
<p>Then, when the World Manager will transmit the aggregated changeset <a class="footnote-reference" href="#id62" id="id60">[30]</a> to the Experiment Manager, this latter simulation agent will iterate through the events in turn, and notify the unit managers whose event clauses matched <a class="footnote-reference" href="#id63" id="id61">[31]</a>.</p>
<table class="docutils footnote" frame="void" id="id62" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id60">[30]</a></td><td>A single, aggregated changeset is relied upon on purpose: if changesets were streamed by the World Manager to the Experiment Manager as they complete, unit managers would have to be able to operate on an unstable dataflow view of the system state (i.e. subject to changes due to further changesets), which could jeopardize the correctness of the synchronisation of the computational part.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id63" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id61">[31]</a></td><td>Translating to calling their appropriate event handler; for example, should a given event match a <tt class="docutils literal">binary_association_event_match</tt> declared by a unit manager, the experiment manager will transmit this event to this unit manager, by calling its <tt class="docutils literal">onBinaryAssociationEventMatched</tt> method.</td></tr>
</tbody>
</table>
<p>This unit manager will then be <strong>free to react appropriately to this listened event, by performing changes onto the computational part</strong> of the underlying dataflow. As hinted in the <tt class="docutils literal">ResourceDemandUnitManager</tt> example, typical changes are to create or delete a processing unit, or to connect or disconnect ports of a processing unit to ports of dataflow objects <a class="footnote-reference" href="#id65" id="id64">[32]</a>.</p>
<table class="docutils footnote" frame="void" id="id65" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id64">[32]</a></td><td>As a result, unit managers have to rely on a corresponding API, possibly implemented also in the language bindings. For example, a Python-based unit manager would use methods inherited from the <tt class="docutils literal">UnitManager</tt> base class, such as the self-explanatory <tt class="docutils literal">create_unit</tt> or <tt class="docutils literal">connect_unit</tt> methods.</td></tr>
</tbody>
</table>
<p></p>
<p></p>
</div>
</div>
<div class="section" id="about-mock-up-units">
<span id="mock-up-units"></span><h1><a class="toc-backref" href="#id138">About Mock-up Units</a></h1>
<p><em>Mock-up units</em> are units that, instead of implementing a computation logic, <strong>directly compose the state of their output ports based on the one of their input ports</strong>, relying for that on the static information (data, not code) that they embed.</p>
<p>As such, mock-up units merely <em>associate</em> pre-recorded outputs to inputs, instead of <em>implementing</em> computations allowing to determine the former from the latter ones.</p>
<p>These mock-up units can act as &quot;termination plugs&quot;, i.e. placeholders inserted in a dataflow in order for example:</p>
<ul>
<li><p class="first">to replace an actual unit (ex: to wait until it is delivered)</p>
</li>
<li><p class="first">to emulate the context of another unit in order to better test it</p>
</li>
<li><p class="first">to validate an implemented unit against reference input/output datasets</p>
</li>
<li><p class="first">to provide a simpler, less computation-demanding version of a unit (see <a class="reference external" href="https://en.wikipedia.org/wiki/Model_order_reduction">model order reduction</a>, called metamodel in some communities)</p>
<p>In practice, these mock-up units are instances of the <tt class="docutils literal">DataflowMockupUnit</tt> class (or of a child class thereof), which provides a generic mock-up unit able to be fed with data basically describing, in terms of ports, which outputs are to correspond to which inputs.</p>
</li>
</ul>
<p>They are instantiated and managed by a <em>unit manager</em>, just like any <em>processing unit</em> would do. The only difference is that, since their construction parameters are slightly different from classical units, they have to be created by dedicated methods that have been added to the <tt class="docutils literal">DataflowUnitManager</tt> class.</p>
<div class="section" id="definition-of-a-mock-up-unit">
<h2><a class="toc-backref" href="#id139">Definition of a Mock-up Unit</a></h2>
<p>A mock-up unit is specified exactly as any other dataflow unit (ex: with a name, a temporality, a description of its input and output ports), yet it has to replace the inner computation logic that would be included in any standard unit by a (static) <strong>association determining its outputs from its inputs</strong>.</p>
<p>This association can be seen as a <strong>simple function</strong> which, based on a given (optional) simulation time and an <em>input match specification</em> operating on its input ports, tells in which state the output ports of this mock-up unit shall be.</p>
<p>One should note that the result returned by this function (the actual state of the output ports) will depend <strong>only</strong> on its input parameters (the specified time and the input match specs); for example no contextual data can intervene, because this (pure) function is stateless (i.e. it has no memory).</p>
<p>The general form of this mock-up function is:</p>
<pre class="code erlang literal-block">
<span class="nf">f</span><span class="p">(</span><span class="n">time</span><span class="p">(),</span> <span class="n">input_match_spec</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="n">output_state</span><span class="p">()</span>
</pre>
<p>This means that the purpose of this mock-up function is <strong>to tell, for a given simulation time and for a configuration of the input ports that matches the supplied specification, what is the corresponding updated state of at least some of the output ports of that unit</strong>.</p>
<p><strong>Multiple clauses</strong> can be specified in order to fully define that function: at runtime, <strong>at each activation</strong>, each of these clauses will have its time and input specifications matched against the current simulation time and the state of the input ports. <strong>The first clause to match will be the only one executed during this activation</strong>, leading to applying the state changes on the output ports that it specifies. Should no clause match, the mock-up unit will simply stay inactive until the next activation (no specific signal will be sent to the downstream connected blocks).</p>
<p>Examples in the next sections will clarify this mode of operation; let's call from now the mock-up function <tt class="docutils literal">f/2</tt>, i.e. a function named <tt class="docutils literal">f</tt> taking two parameters, respectively the time and the input match spec.</p>
</div>
<div class="section" id="simulation-time-specification">
<h2><a class="toc-backref" href="#id140">Simulation Time Specification</a></h2>
<p>A mock-up function may <strong>react differently at different time steps</strong> of the simulation. So a clause of that function may specify, for its first parameter:</p>
<ul class="simple">
<li>either the precise time step at which it shall be applied, for example <tt class="docutils literal"><span class="pre">f(127,...)-&gt;...</span></tt>, to denote here that this clause corresponds to the simulation step #127</li>
<li>or the <tt class="docutils literal">any_time</tt> atom, to tell that the application of this clause does not depend on simulation time; as a result, <tt class="docutils literal"><span class="pre">f(any_time,...)-&gt;...</span></tt> will match irrespectively of the current time step</li>
</ul>
<p>Of course units (hence mock-up ones) may be atemporal, in which case only timeless clauses (using <tt class="docutils literal">any_time</tt>) would be used.</p>
</div>
<div class="section" id="input-match-specification">
<h2><a class="toc-backref" href="#id141">Input Match Specification</a></h2>
<p>This second parameter of the mock-up function allows to specify the <strong>configuration of input ports to which this clause is meant to match</strong>: the match specification describes the possible states in which the input ports of interest for the mock-up unit shall be, for this clause to be selected. That clause determines in turn the state of the output ports that will be consequently retained.</p>
<p>In practice, an input match spec is an (unordered) list of pairs, whose first element designates an input port, and whose second one specifies the associated state(s) that would match.</p>
<p>This first element is the name of the input port (ex: <tt class="docutils literal">&quot;I1&quot;</tt>), as, in the context of a unit, it is an identifier (it is unique).</p>
<p>The second element of the pair associated to a listed input port is among:</p>
<ul class="simple">
<li>the <tt class="docutils literal">any_state</tt> atom, to specify that the state of this input port will be ignored, i.e. that it may or may not be set (if set, its value will not matter for the clause)</li>
<li>the <tt class="docutils literal">unset</tt> atom, to specify that this input port should <em>not</em> be set</li>
<li>the <tt class="docutils literal">set</tt> atom, telling that this input port may have any value, <em>provided it is set at all</em></li>
<li>a <tt class="docutils literal">{set,V}</tt> pair, requiring that input port to be set exactly to this value <tt class="docutils literal">V</tt></li>
<li>a <tt class="docutils literal">{between,A,B}</tt> pair, requiring that input port to be set to a scalar, numerical value in the <tt class="docutils literal">[A,B]</tt> range (hence including bounds)</li>
<li>a <tt class="docutils literal">{around,V,E}</tt> pair, requiring that input port to be set to a value around <tt class="docutils literal">V</tt>, with a relative error <a class="footnote-reference" href="#id67" id="id66">[33]</a> of up to <tt class="docutils literal">E</tt>; this is a way of better supporting floating-point values - for which strict equality is usually not meaningful</li>
<li>a <tt class="docutils literal">{around,V}</tt> pair, requiring that input port to be set to a value around <tt class="docutils literal">V</tt> with a default relative error of <tt class="docutils literal"><span class="pre">1.0e-6</span></tt></li>
<li>a <tt class="docutils literal"><span class="pre">{among,[V1,V2,..,Vn]}</span></tt> pair, this input port having to be set to one value in that list for the clause to possibly match</li>
</ul>
<table class="docutils footnote" frame="void" id="id67" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id66">[33]</a></td><td>The relative error between X and Y being the absolute value of their difference divided by their average value: <tt class="docutils literal"><span class="pre">2*abs((X-Y)/(X+Y)))</span></tt>, for X different from -Y (otherwise <tt class="docutils literal"><span class="pre">abs(X-Y)</span></tt> is used instead).</td></tr>
</tbody>
</table>
<p>Any input port that is not listed in the spec may be in any state (unset, or set to any value); the <tt class="docutils literal">any_state</tt> atom is therefore a way of specifying the same, yet in an explicit manner.</p>
<p>For example, if a unit has six input ports named <tt class="docutils literal">&quot;I1&quot;</tt>, <tt class="docutils literal">&quot;I2&quot;</tt>, <tt class="docutils literal">&quot;I3&quot;</tt>, <tt class="docutils literal">&quot;I4&quot;</tt>, <tt class="docutils literal">&quot;I5&quot;</tt> and <tt class="docutils literal">&quot;I6&quot;</tt> <a class="footnote-reference" href="#id69" id="id68">[34]</a>, and the input match specification is:</p>
<pre class="code erlang literal-block">
<span class="p">[{</span><span class="s">&quot;I2&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">set</span><span class="p">,</span> <span class="mi">14</span><span class="p">.</span><span class="mi">0</span><span class="p">}},</span> <span class="p">{</span><span class="s">&quot;I5&quot;</span><span class="p">,</span> <span class="n">set</span><span class="p">},</span> <span class="p">{</span><span class="s">&quot;I4&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">between</span><span class="p">,</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">}}},</span>
  <span class="p">{</span><span class="s">&quot;I1&quot;</span><span class="p">,</span> <span class="n">unset</span><span class="p">},</span> <span class="p">{</span><span class="s">&quot;I6&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">among</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">]}}]</span>
</pre>
<table class="docutils footnote" frame="void" id="id69" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id68">[34]</a></td><td>Please note that the coupling layer allows port names to be any string; input ports do not have to be named <tt class="docutils literal">&quot;I1&quot;</tt>, <tt class="docutils literal">&quot;I2&quot;</tt>, etc.; therefore <tt class="docutils literal">&quot;attila woz here&quot;</tt> and <tt class="docutils literal"><span class="pre">&quot;FelixTheCat-1337&quot;</span></tt> would be perfectly suitable (and of course the same applies to the name of output ports as well).</td></tr>
</tbody>
</table>
<p>Then this function will match iff (if and only if), in terms of input ports for that mock-up unit:</p>
<ul class="simple">
<li><tt class="docutils literal">&quot;I1&quot;</tt> is unset (i.e. not set to any value)</li>
<li>and <tt class="docutils literal">&quot;I2&quot;</tt> is (exactly) set to 14.00</li>
<li>and <tt class="docutils literal">&quot;I4&quot;</tt> is set to a value in [2,8]</li>
<li>and <tt class="docutils literal">&quot;I5&quot;</tt> is set (to any value)</li>
<li>and <tt class="docutils literal">&quot;I6&quot;</tt> is set to 3, 4 or 6</li>
</ul>
<p>One can note that the order of the pairs does not matter, and that the input port <tt class="docutils literal">&quot;I3&quot;</tt>, not being listed, can thus be in strictly any state.</p>
</div>
<div class="section" id="output-state-specification">
<h2><a class="toc-backref" href="#id142">Output State Specification</a></h2>
<p>When a given clause is evaluated (implying none of the previous ones could apply), if both its <strong>current time and input specifications are matching the current runtime and state information</strong>, then this clause is selected, and the <strong>output ports of the mock-up unit are then set as this clause specifies</strong>.</p>
<p>An output state is defined as an (unordered) list of pairs, whose first element designates an output port (identified by its name), and whose second one specifies the associated state it should be set to.</p>
<p>Possible specified states are:</p>
<ul class="simple">
<li>the <tt class="docutils literal">reassign</tt> atom to set again this port to the same state, whatever it is</li>
<li>the <tt class="docutils literal">unset</tt> atom, so that the corresponding output port is (becomes or remains) explicitly not set</li>
<li>a <tt class="docutils literal">{set,V}</tt> pair, where <tt class="docutils literal">V</tt> is the value to which this output port shall be set</li>
<li>a <tt class="docutils literal">{state_of,I}</tt> pair, where <tt class="docutils literal">I</tt> is the name of an input port of that unit, in which case the state of the output port will be assigned to the one of the specified input port</li>
</ul>
<p>If an output port is not listed in the specification, then it will be kept in its current state, knowing that all output ports are initially, once created, <tt class="docutils literal">unset</tt>.</p>
<p>The <tt class="docutils literal">reassign</tt> atom is therefore a way to feed again the connected channel with the same value as it held previously. If this port was previously unset, it will simply stay so.</p>
<p>Knowing that the setting of an output port is punctual (i.e. a one-time event is sent, then the output port comes back to its <tt class="docutils literal">unset</tt> base state), we can see that, in a clause, an output port can be considered as always being initially <tt class="docutils literal">unset</tt>. As a consequence, specifying the <tt class="docutils literal">unset</tt> atom for its new status is optional (since not specifying at all that output port does the same).</p>
<p>For example, if the output state specification of a clause is:</p>
<pre class="code erlang literal-block">
<span class="p">[</span> <span class="p">{</span><span class="s">&quot;O7&quot;</span><span class="p">,</span> <span class="n">reassign</span><span class="p">},</span> <span class="p">{</span><span class="s">&quot;O1&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">set</span><span class="p">,</span><span class="mi">6</span><span class="p">}},</span>
  <span class="p">{</span><span class="s">&quot;O2&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">set</span><span class="p">,</span><span class="mi">3</span><span class="p">.</span><span class="mi">14</span><span class="p">}},</span> <span class="p">{</span><span class="s">&quot;O5&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">state_of</span><span class="p">,</span><span class="s">&quot;I2&quot;</span><span class="p">}}</span> <span class="p">]</span>
</pre>
<p>then, should this clause be selected, the output ports of this mock-up unit will be assigned to the following state:</p>
<ul class="simple">
<li><tt class="docutils literal">&quot;O1&quot;</tt> set to 6</li>
<li><tt class="docutils literal">&quot;O2&quot;</tt> set to 3.14</li>
<li><tt class="docutils literal">&quot;O5&quot;</tt> having the same state as input port <tt class="docutils literal">&quot;I2&quot;</tt></li>
<li><tt class="docutils literal">&quot;O7&quot;</tt> staying unchanged</li>
<li>all other ports being inactive (as if they were unset)</li>
</ul>
</div>
<div class="section" id="consistency-and-checking">
<h2><a class="toc-backref" href="#id143">Consistency and Checking</a></h2>
<p>Of course, both the input match specifications and the output state specifications must respect the typing information (the <tt class="docutils literal">T</tt> in <tt class="docutils literal">SUTC</tt>) of the ports that they may reference.</p>
<p>For example:</p>
<ul class="simple">
<li><tt class="docutils literal">{between,1.1,1.7}</tt> cannot apply to an input port typed as a boolean one</li>
<li><tt class="docutils literal">{state_of,I}</tt> should not be specified if the corresponding output port has not the same associated type information as the input port <tt class="docutils literal">I</tt></li>
</ul>
<p>The dataflow infrastructure will perform some basic checking at runtime, yet some care should be taken by the user to inject only legit data.</p>
</div>
<div class="section" id="examples-of-a-mock-up-function">
<h2><a class="toc-backref" href="#id144">Examples of a Mock-up Function</a></h2>
<p id="first-mock-up-function-example">Now such a definition should be quite easy to interpret:</p>
<pre class="code erlang literal-block">
<span class="nf">f</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span> <span class="p">{</span><span class="s">&quot;ip_1&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">set</span><span class="p">,</span><span class="n">true</span><span class="p">}},</span> <span class="p">{</span><span class="s">&quot;ip_3&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">set</span><span class="p">,</span><span class="mi">3</span><span class="p">}}</span> <span class="p">]</span> <span class="p">)</span> <span class="o">-&gt;</span>
   <span class="p">[</span> <span class="p">{</span><span class="s">&quot;op_2&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">set</span><span class="p">,</span><span class="mi">89</span><span class="p">}},</span> <span class="p">{</span><span class="s">&quot;op_4&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">set</span><span class="p">,</span><span class="n">false</span><span class="p">}}</span> <span class="p">];</span>

<span class="nf">f</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[]</span> <span class="p">)</span> <span class="o">-&gt;</span>
   <span class="p">[</span> <span class="p">{</span><span class="s">&quot;op_1&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">set</span><span class="p">,</span><span class="mi">1</span><span class="p">}},</span> <span class="p">{</span><span class="s">&quot;op_2&quot;</span><span class="p">,</span><span class="n">unset</span><span class="p">}</span> <span class="p">];</span>

<span class="nf">f</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[])</span> <span class="o">-&gt;</span>
   <span class="p">[</span> <span class="p">{</span><span class="s">&quot;op_2&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">state_of</span><span class="p">,</span> <span class="s">&quot;ip_7&quot;</span><span class="p">}}</span> <span class="p">];</span>

<span class="nf">f</span><span class="p">(</span> <span class="n">any_time</span><span class="p">,</span> <span class="p">[]</span> <span class="p">)</span> <span class="o">-&gt;</span>
   <span class="p">[</span> <span class="p">{</span><span class="s">&quot;op_4&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">set</span><span class="p">,</span><span class="n">true</span><span class="p">}}</span> <span class="p">].</span>
</pre>
<p>Indeed that mock-up function <tt class="docutils literal">f</tt> is defined thanks to four clauses, to be read as detailed below.</p>
<p>The <strong>first clause</strong> will require, if at time step <tt class="docutils literal">0</tt>, an exact match for both the input ports named <tt class="docutils literal">&quot;ip_1&quot;</tt> (which must be set to <tt class="docutils literal">true</tt>) and <tt class="docutils literal">&quot;ip_3&quot;</tt> (which must be set to <tt class="docutils literal">3</tt>). If this occurs, then the evaluation of <tt class="docutils literal">f</tt> is over and output ports <tt class="docutils literal">&quot;op_2&quot;</tt> and <tt class="docutils literal">&quot;op_4&quot;</tt> will be set respectively to <tt class="docutils literal">89</tt> and <tt class="docutils literal">false</tt>, while the other ones will be unchanged.</p>
<p>Should this first clause not match, the <strong>second one</strong> will be tried. It references the same time step <tt class="docutils literal">0</tt>, yet has an empty input match spec. This means that, for that time step, it will be a &quot;catch-all&quot; clause, i.e. a clause that will match necessarily, regardless of the state of the input ports. In this case <tt class="docutils literal">&quot;op_1&quot;</tt> will be set to <tt class="docutils literal">1</tt>, <tt class="docutils literal">&quot;op_2&quot;</tt> will be explicitly unset, and the state of the other output ports will remain as it is.</p>
<p>As the <strong>third clause</strong> deals with another time step than <tt class="docutils literal">0</tt>, it has a chance to match (the previous clauses covered all possible cases for time step <tt class="docutils literal">0</tt>). We see that it behaves as a catch-all for time step <tt class="docutils literal">1</tt>, resulting in the <tt class="docutils literal">&quot;op_2&quot;</tt> output port having the same state as the <tt class="docutils literal">&quot;ip_7&quot;</tt> input port.</p>
<p>Finally, the <strong>fourth clause</strong> is an universal catch-all, for all time steps and all configurations of input ports. This implies that the corresponding mock-up unit will be able to be evaluated in all possible cases; the role of this particular clause here is only to set the  <tt class="docutils literal">&quot;op_4&quot;</tt> output port to <tt class="docutils literal">true</tt>.</p>
<p>Another example is a very simple one, the universally defined <strong>identity mock-up function</strong>, defined as:</p>
<pre class="code erlang literal-block">
<span class="nf">f</span><span class="p">(</span><span class="n">any_time</span><span class="p">,[])</span> <span class="o">-&gt;</span>
 <span class="p">[].</span>
</pre>
</div>
<div class="section" id="data-based-mock-up-definition">
<h2><a class="toc-backref" href="#id145">Data-Based Mock-up Definition</a></h2>
<p>A mock-up unit can be seen more as data (output sets being matched to input ones) than as code.</p>
<p>Therefore, rather than <em>implementing</em> a mock-up function as done in the previous section, a means is provided in order to define such a function based on an information stream (typically a file).</p>
<p>Defining the syntax of these data is the purpose of our <em>Dataflow Unit Mockup Format</em> (abbreviated as <tt class="docutils literal">DUMF</tt>), described here. As a consequence, we recommend that the file extension for such a content is <tt class="docutils literal">dumf</tt>, like in: <tt class="docutils literal">my_model_v4.dumf</tt>.</p>
<p>Fortunately, the corresponding data-based descriptions are directly similar to the implementations that have been detailed above:</p>
<ul class="simple">
<li>a mock-up function was implemented as a series of clauses, its data counterpart is an (ordered) list of clause definitions</li>
<li>each implemented clause of that function corresponds then to an item of that list, i.e. a clause definition made of two elements:<ul>
<li>the first element is a pair defining the time information and input match specification corresponding to this clause</li>
<li>the second element details the output state definition that will be applied, should the first element match</li>
</ul>
</li>
</ul>
<p></p>
<p>So the full, data-based version of a unit relying on the same clauses as specified in the <a class="reference internal" href="#first-mock-up-function-example">first mock-up function example</a> section may simply be a <tt class="docutils literal">my_mockup_example.dumf</tt> file whose content may read as (note the few ellipses done with &quot;<tt class="docutils literal">...</tt>&quot;, in order to shorten the listing):</p>
<pre class="code erlang literal-block">
<span class="c">% This DUMF data file defines the mock-up version of the
% 'class_MyExampleUnit' unit.
</span>
<span class="c">% First the metadata for this unit:
</span><span class="p">{</span> <span class="n">unit_type</span><span class="p">,</span> <span class="n">'class_MyExampleUnit'</span> <span class="p">}.</span>
<span class="p">{</span> <span class="n">mockup_author</span><span class="p">,</span> <span class="s">&quot;Jiminy Cricket&quot;</span> <span class="p">}.</span>
<span class="p">{</span> <span class="n">mockup_author_contact</span><span class="p">,</span> <span class="s">&quot;jc&#64;fantasy-world.org&quot;</span> <span class="p">}.</span>
<span class="p">{</span> <span class="n">mockup_version</span><span class="p">,</span> <span class="s">&quot;1.0.3&quot;</span> <span class="p">}.</span>
<span class="p">{</span> <span class="n">mockup_date</span><span class="p">,</span> <span class="s">&quot;16/2/2017&quot;</span> <span class="p">}.</span>
<span class="p">{</span> <span class="n">activation_policy</span><span class="p">,</span> <span class="n">activate_when_all_set</span> <span class="p">}.</span>

<span class="c">% Then the definition of its input ports:
</span><span class="p">{</span> <span class="n">input_port_specs</span><span class="p">,</span> <span class="p">[</span>
   <span class="p">[</span>   <span class="p">{</span> <span class="n">input_port_name</span><span class="p">,</span> <span class="s">&quot;ip_1&quot;</span> <span class="p">},</span>
       <span class="p">{</span> <span class="n">value_semantics</span><span class="p">,</span> <span class="n">'http://foo.org/energy'</span> <span class="p">},</span>
       <span class="p">{</span> <span class="n">value_unit</span><span class="p">,</span> <span class="s">&quot;kW.h&quot;</span> <span class="p">},</span>
       <span class="p">{</span> <span class="n">value_type_description</span><span class="p">,</span> <span class="s">&quot;float&quot;</span> <span class="p">},</span>
       <span class="p">{</span> <span class="n">value_constraints</span><span class="p">,</span> <span class="p">[</span> <span class="n">positive</span> <span class="p">]</span> <span class="p">}</span> <span class="p">],</span>
   <span class="p">[</span>   <span class="p">{</span> <span class="n">input_port_name</span><span class="p">,</span> <span class="s">&quot;ip_2&quot;</span> <span class="p">},</span> <span class="p">...</span> <span class="p">],</span>
   <span class="p">[</span>   <span class="p">{</span> <span class="n">input_port_name</span><span class="p">,</span> <span class="s">&quot;ip_3&quot;</span> <span class="p">},</span> <span class="p">...</span> <span class="p">],</span>
   <span class="p">...</span> <span class="p">]</span> <span class="p">}.</span>

<span class="c">% Followed by the definition of its output ports:
</span><span class="p">{</span> <span class="n">output_port_specs</span><span class="p">,</span> <span class="p">[</span>
   <span class="p">[</span>   <span class="p">{</span> <span class="n">output_port_name</span><span class="p">,</span> <span class="s">&quot;op_1&quot;</span> <span class="p">},</span> <span class="p">...</span> <span class="p">],</span>
   <span class="p">[</span>   <span class="p">{</span> <span class="n">output_port_name</span><span class="p">,</span> <span class="s">&quot;op_2&quot;</span> <span class="p">},</span> <span class="p">...</span> <span class="p">],</span>
   <span class="p">...</span> <span class="p">]</span> <span class="p">}.</span>

<span class="c">% Finally we define in which state the output ports of this unit
% shall be, based on the following input match specs:
</span><span class="p">{</span> <span class="n">mockup_clauses</span><span class="p">,</span> <span class="p">[</span>
   <span class="p">{</span> <span class="p">{</span><span class="mi">0</span><span class="p">,[{</span><span class="s">&quot;ip_1&quot;</span><span class="p">,{</span><span class="n">set</span><span class="p">,</span><span class="n">true</span><span class="p">}},{</span><span class="s">&quot;ip_3&quot;</span><span class="p">,{</span><span class="n">set</span><span class="p">,</span><span class="mi">3</span><span class="p">}}]},</span>
        <span class="p">[{</span><span class="s">&quot;op_2&quot;</span><span class="p">,</span><span class="mi">89</span><span class="p">},{</span><span class="s">&quot;op_4&quot;</span><span class="p">,</span><span class="n">false</span><span class="p">}]},</span>
   <span class="p">{</span> <span class="p">{</span><span class="mi">0</span><span class="p">,[]},</span>
        <span class="p">[{</span><span class="s">&quot;op_1&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">},{</span><span class="s">&quot;op_2&quot;</span><span class="p">,</span><span class="n">unset</span><span class="p">}]},</span>
   <span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,[]},</span>
       <span class="p">[{</span><span class="s">&quot;op_2&quot;</span><span class="p">,{</span><span class="n">state_of</span><span class="p">,</span><span class="s">&quot;ip_7&quot;</span><span class="p">}}]},</span>
   <span class="p">{</span> <span class="p">{</span><span class="n">any_time</span><span class="p">,[]},</span>
       <span class="p">[{</span><span class="s">&quot;op_4&quot;</span><span class="p">,</span><span class="n">true</span><span class="p">}]}</span>
 <span class="p">]</span> <span class="p">}.</span>

<span class="c">% End of the mock-up definition.</span>
</pre>
<p>These two forms (these <tt class="docutils literal">mockup_clauses</tt> and the previous function <tt class="docutils literal">f/2</tt>) are basically the same.</p>
<p>As a result, this DUMF file fully describes a mock-up unit that may be represented as:</p>
<p><span class="raw-html"><center><img src="mock-up-unit-example.png" id="responsive-image-medium"></img></center></span>
</p>
<p>Once the clauses are expressed according to this format, one may think of creating mock-up units directly from such a stream of information, without writing any code.</p>
<p>For that, the DUMF format includes not only these clauses, but also all the other informations that a mock-up unit - as any other processing unit - must provide. Namely:</p>
<ul class="simple">
<li>metadata such as its name, the type of this unit (ex: of use for its (unit) manager), etc.</li>
<li>the specification of its input and output ports</li>
</ul>
<p>These three blocks of data, with the final addition of the clauses, form a complete description of a mock-up unit, and thus an operational DUMF stream.</p>
<p>See below an example of conforming file, <tt class="docutils literal">ReferenceExampleMockup.dumf</tt>:</p>
<pre class="code erlang literal-block">
<span class="c">% This DUMF data file defines the mock-up version of the unit named:
% class_MyExampleUnit
%
%
% Please refer to the 'Sim-Diasca Dataflow HOWTO' for more information
% about Mock-up Units.
%
% Generated on 21/03/2017 18:04:31, by user 'jiminy'.
%
</span>
<span class="p">{</span> <span class="n">dumf_version</span><span class="p">,</span> <span class="s">&quot;0.3.1&quot;</span> <span class="p">}.</span>

<span class="p">{</span> <span class="n">unit_type</span><span class="p">,</span> <span class="n">'class_MyExampleUnit'</span> <span class="p">}.</span>

<span class="p">{</span> <span class="n">mockup_author</span><span class="p">,</span> <span class="s">&quot;Jiminy Cricket&quot;</span> <span class="p">}.</span>
<span class="p">{</span> <span class="n">mockup_author_contact</span><span class="p">,</span> <span class="s">&quot;jc&#64;fantasy-world.org&quot;</span> <span class="p">}.</span>

<span class="p">{</span> <span class="n">mockup_version</span><span class="p">,</span> <span class="s">&quot;1.0.0&quot;</span> <span class="p">}.</span>
<span class="p">{</span> <span class="n">mockup_date</span><span class="p">,</span> <span class="s">&quot;16/02/2017&quot;</span> <span class="p">}.</span>

<span class="p">{</span> <span class="n">activation_policy</span><span class="p">,</span> <span class="n">'activate_when_all_set'</span> <span class="p">}.</span>


<span class="p">{</span> <span class="n">input_port_specs</span><span class="p">,</span> <span class="p">[</span>

    <span class="p">[</span>
        <span class="p">{</span> <span class="n">input_port_name</span><span class="p">,</span> <span class="s">&quot;ip_1&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">comment</span><span class="p">,</span> <span class="s">&quot;This is my first input port&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">is_iteration</span><span class="p">,</span> <span class="n">'false'</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_semantics</span><span class="p">,</span> <span class="n">'http://foo.org/energy'</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_unit</span><span class="p">,</span> <span class="s">&quot;kW.h&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_type_description</span><span class="p">,</span> <span class="s">&quot;integer&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_constraints</span><span class="p">,</span> <span class="p">[</span><span class="n">positive</span><span class="p">]</span> <span class="p">}</span>
    <span class="p">],</span>

    <span class="p">[</span>
        <span class="p">{</span> <span class="n">input_port_name</span><span class="p">,</span> <span class="s">&quot;ip_2&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">comment</span><span class="p">,</span> <span class="s">&quot;This is my second input port&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">is_iteration</span><span class="p">,</span> <span class="n">'false'</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_semantics</span><span class="p">,</span> <span class="n">'http://foo.org/pollution'</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_unit</span><span class="p">,</span> <span class="s">&quot;g.cm^-3&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_type_description</span><span class="p">,</span> <span class="s">&quot;float&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_constraints</span><span class="p">,</span> <span class="p">[]</span> <span class="p">}</span>
    <span class="p">],</span>

    <span class="p">[</span>
        <span class="p">{</span> <span class="n">input_port_name</span><span class="p">,</span> <span class="s">&quot;ip_3&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">comment</span><span class="p">,</span> <span class="s">&quot;This is my third input port&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">is_iteration</span><span class="p">,</span> <span class="n">'true'</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_semantics</span><span class="p">,</span> <span class="n">'http://foo.org/length'</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_unit</span><span class="p">,</span> <span class="s">&quot;m&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_type_description</span><span class="p">,</span> <span class="s">&quot;integer&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_constraints</span><span class="p">,</span> <span class="p">[</span><span class="n">non_null</span><span class="p">]</span> <span class="p">}</span>
    <span class="p">]</span>

<span class="p">]</span> <span class="p">}.</span>


<span class="p">{</span> <span class="n">output_port_specs</span><span class="p">,</span> <span class="p">[</span>

    <span class="p">[</span>
        <span class="p">{</span> <span class="n">output_port_name</span><span class="p">,</span> <span class="s">&quot;op_1&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">comment</span><span class="p">,</span> <span class="s">&quot;This is my first output port&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">is_iteration</span><span class="p">,</span> <span class="n">'false'</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_semantics</span><span class="p">,</span> <span class="n">'http://foo.org/adult_count'</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_unit</span><span class="p">,</span> <span class="s">&quot;dimensionless&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_type_description</span><span class="p">,</span> <span class="s">&quot;integer&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_constraints</span><span class="p">,</span> <span class="p">[</span><span class="n">positive</span><span class="p">]</span> <span class="p">}</span>
    <span class="p">],</span>

    <span class="p">[</span>
        <span class="p">{</span> <span class="n">output_port_name</span><span class="p">,</span> <span class="s">&quot;op_2&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">comment</span><span class="p">,</span> <span class="s">&quot;This is my second output port&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">is_iteration</span><span class="p">,</span> <span class="n">'true'</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_semantics</span><span class="p">,</span> <span class="n">'http://foo.org/operation_status'</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_unit</span><span class="p">,</span> <span class="s">&quot;dimensionless&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_type_description</span><span class="p">,</span> <span class="s">&quot;boolean&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_constraints</span><span class="p">,</span> <span class="p">[]</span> <span class="p">}</span>
    <span class="p">],</span>

    <span class="p">[</span>
        <span class="p">{</span> <span class="n">output_port_name</span><span class="p">,</span> <span class="s">&quot;op_3&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">comment</span><span class="p">,</span> <span class="s">&quot;This is my third output port&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">is_iteration</span><span class="p">,</span> <span class="n">'false'</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_semantics</span><span class="p">,</span> <span class="n">'http://foo.org/operation_status'</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_unit</span><span class="p">,</span> <span class="s">&quot;dimensionless&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_type_description</span><span class="p">,</span> <span class="s">&quot;boolean&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_constraints</span><span class="p">,</span> <span class="p">[]</span> <span class="p">}</span>
    <span class="p">],</span>

    <span class="p">[</span>
        <span class="p">{</span> <span class="n">output_port_name</span><span class="p">,</span> <span class="s">&quot;op_4&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">comment</span><span class="p">,</span> <span class="s">&quot;This is my fourth output port&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">is_iteration</span><span class="p">,</span> <span class="n">'false'</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_semantics</span><span class="p">,</span> <span class="n">'http://foo.org/pollution'</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_unit</span><span class="p">,</span> <span class="s">&quot;g.cm^-3&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_type_description</span><span class="p">,</span> <span class="s">&quot;float&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">value_constraints</span><span class="p">,</span> <span class="p">[]</span> <span class="p">}</span>
    <span class="p">]</span>

<span class="p">]</span> <span class="p">}.</span>


<span class="p">{</span> <span class="n">mockup_clauses</span><span class="p">,</span> <span class="p">[</span>

  <span class="p">{</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="p">{</span> <span class="s">&quot;ip_1&quot;</span><span class="p">,</span> <span class="p">{</span> <span class="n">between</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span> <span class="p">}</span> <span class="p">},</span>
        <span class="p">{</span> <span class="s">&quot;ip_3&quot;</span><span class="p">,</span> <span class="p">{</span> <span class="n">set</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">}</span>
    <span class="p">],</span>
    <span class="p">[</span>
        <span class="p">{</span> <span class="s">&quot;op_2&quot;</span><span class="p">,</span> <span class="p">{</span> <span class="n">set</span><span class="p">,</span> <span class="n">false</span> <span class="p">}</span> <span class="p">},</span>
        <span class="p">{</span> <span class="s">&quot;op_4&quot;</span><span class="p">,</span> <span class="p">{</span> <span class="n">set</span><span class="p">,</span> <span class="mi">89</span><span class="p">.</span><span class="mi">5</span> <span class="p">}</span> <span class="p">}</span>
    <span class="p">]</span> <span class="p">},</span>

  <span class="p">{</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="p">{</span> <span class="s">&quot;ip_2&quot;</span><span class="p">,</span> <span class="p">{</span> <span class="n">around</span><span class="p">,</span> <span class="mi">42</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0001</span> <span class="p">}</span> <span class="p">}</span>
    <span class="p">],</span>
    <span class="p">[</span>
        <span class="p">{</span> <span class="s">&quot;op_1&quot;</span><span class="p">,</span> <span class="p">{</span> <span class="n">set</span><span class="p">,</span> <span class="mi">1</span> <span class="p">}</span> <span class="p">},</span>
        <span class="p">{</span> <span class="s">&quot;op_2&quot;</span><span class="p">,</span> <span class="n">unset</span> <span class="p">}</span>
    <span class="p">]</span> <span class="p">},</span>

  <span class="p">{</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="p">{</span> <span class="s">&quot;ip_3&quot;</span><span class="p">,</span> <span class="p">{</span> <span class="n">among</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">}</span> <span class="p">}</span>
    <span class="p">],</span>
    <span class="p">[</span>
        <span class="p">{</span> <span class="s">&quot;op_4&quot;</span><span class="p">,</span>
          <span class="p">{</span> <span class="n">state_of</span><span class="p">,</span> <span class="s">&quot;ip_2&quot;</span> <span class="p">}</span> <span class="p">}</span>
    <span class="p">]</span> <span class="p">},</span>

  <span class="p">{</span> <span class="n">any_time</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="p">{</span> <span class="s">&quot;ip_1&quot;</span><span class="p">,</span> <span class="n">unset</span> <span class="p">}</span>
    <span class="p">],</span>
    <span class="p">[</span>
        <span class="p">{</span> <span class="s">&quot;op_2&quot;</span><span class="p">,</span> <span class="p">{</span> <span class="n">set</span><span class="p">,</span> <span class="n">true</span> <span class="p">}</span> <span class="p">}</span>
    <span class="p">]</span> <span class="p">}</span>

<span class="p">]</span> <span class="p">}.</span>
</pre>
<p>Such a complete description of a mock-up may simply be stored in a file, so that it can be later re-used through the <tt class="docutils literal">read_mockup_unit_spec/1</tt> static method of the <tt class="docutils literal">DataflowMockupUnit</tt> class, allowing a unit manager to create instances of this mock-up unit, for example thanks to the <tt class="docutils literal">create_initial_mockup_units/4</tt> static method of the <tt class="docutils literal">DataflowUnitManager</tt> class.</p>
<p>The concept of mock-up <em>variety</em> is currently purely documentary. Mock-up units are classical processing units to which we attach a set of mock-up clauses (in order to define their behaviour when activated). Thus, it is possible to imagine having two mock-up units sharing all the attributes of a processing unit but acting according to different mock-up clauses: we would then distinguish them as two <em>varieties</em> of a same mock-up unit type <a class="footnote-reference" href="#id71" id="id70">[35]</a>.</p>
<table class="docutils footnote" frame="void" id="id71" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id70">[35]</a></td><td>This vocabulary distinction appears from the fact that we are concerned with emulated models, and each emulated model corresponds to an emulated (mock-up) <tt class="docutils literal">unit_type</tt> in the DUMF specifications (since even more generally in dataflows, with the vocabulary of Sim-Diasca, a model is implemented as a type of processing unit). If we imagine a mock-up designer defining two different sets of clauses in two DUMF files which declare a same <tt class="docutils literal">unit_type</tt> (and share the same values for everything else but the clauses), then we end up with two <em>varieties</em> of this same emulated model (or <em>varieties</em> of this mock-up unit type). If it is not clear enough, we can put it in other words: since a fixed set of clauses leads to instantiate identical mock-up units (a <em>variety</em>), we can instantiate a different kind of mock-up units by just modifying the clauses (then creating other <em>varieties</em>).</td></tr>
</tbody>
</table>
<p>About naming the DUMF file, the basic convention is that if one wants to make a mock-up unit emulating a future real model, say a Python unit that would be named <tt class="docutils literal">VehicleTypeUnit</tt> and which would be implemented in <tt class="docutils literal">vehicle_type_unit.py</tt> for instance, then it should be done in a file named <tt class="docutils literal">VehicleTypeMockup.dumf</tt>.</p>
<p>Of course, in practice, the DUMF format is most probably too low-level, too textual for domain experts or model implementers to make a direct use of it.</p>
<p>Indeed units can easily have several dozens of input and output ports, and mock-up units may have to be defined over a very large number of time steps.</p>
<p>Two approaches were then imagined to ultimately obtain the mock-up data in that targeted format:</p>
<ul class="simple">
<li>defining a <strong>lightweight GUI</strong> in order to ease (and check) the entering of these information, storing them in this mock-up format</li>
<li>defining a <strong>spreadsheet-based template</strong> that would be filled by the persons closer to the models and then automatically translated into a proper mock-up data-based definition<ul>
<li>such a template, compliant with LibreOffice and Microsoft Office, has been devised in order to streamline the specification of mock-up units</li>
<li>the filled templates (saved as OpenDocument file, whose extension is <tt class="docutils literal">*.ods</tt>) can then be automatically translated into their canonical DUMF counterpart (see our <tt class="docutils literal"><span class="pre">spreadsheet-to-dumf.escript</span></tt> script for that)</li>
</ul>
</li>
</ul>
<p>While such a GUI is not implemented yet, it is now possible to write a mock-up definition in a spreadsheet and to convert it in the DUMF format seen above.</p>
</div>
<div class="section" id="mock-up-definition-from-a-spreadsheet">
<h2><a class="toc-backref" href="#id146">Mock-up Definition from a Spreadsheet</a></h2>
<p>The script translating a user-defined spreadsheet to a DUMF file needs the former to stick to a template, which is also provided in the Sim-Diasca repository.</p>
<p>The template spreadsheet was first designed using <a class="reference external" href="https://en.wikipedia.org/wiki/Microsoft_Office">Microsoft Excel</a> 2013 and is named <tt class="docutils literal">MockupReferenceExample.xlsx</tt>. We exported it to the <a class="reference external" href="https://en.wikipedia.org/wiki/OpenDocument">ODF</a> format used for instance by <a class="reference external" href="https://en.wikipedia.org/wiki/LibreOffice">LibreOffice</a> 5, resulting in <tt class="docutils literal">MockupReferenceExample.ods</tt> <a class="footnote-reference" href="#id73" id="id72">[36]</a>.</p>
<p>Both formats are supported by the script.</p>
<table class="docutils footnote" frame="void" id="id73" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id72">[36]</a></td><td>The path to all the mock-up support in Sim-Diasca is <tt class="docutils literal"><span class="pre">sim-diasca/src/core/src/dataflow/mockup_support</span></tt>. The transformation script can be found there, named <tt class="docutils literal">mockup_spreadsheet_to_dumf.escript</tt> and the template spreadsheets are in the <tt class="docutils literal">tests</tt> subdirectory (alongside the previous example of DUMF file).</td></tr>
</tbody>
</table>
<p>One may note that, for general clarity, the previous naming convention should still hold, by simply adapting the file extensions. Hence for a target model <tt class="docutils literal">VehicleTypeUnit</tt>, the Excel version of the mock-up definition file should be <tt class="docutils literal">VehicleTypeMockup.xlsx</tt> and the ODF version should be <tt class="docutils literal">VehicleTypeMockup.ods</tt>.</p>
<p>Here is the reference Excel spreadsheet cited above, consisting of four worksheets, each representing one of the four blocks of data seen in the previous DUMF example <a class="footnote-reference" href="#id75" id="id74">[37]</a>.</p>
<table class="docutils footnote" frame="void" id="id75" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id74">[37]</a></td><td>The overall structure of <tt class="docutils literal">ReferenceExampleMockup.xlsx</tt>, as well as the structures of the individual worksheets, are protected by a password. Currently, this password is <em>dataflow</em>.</td></tr>
</tbody>
</table>
<p>First, the metadata associated to a mock-up unit:</p>
<p><span class="raw-html"><center><img src="excel-mockup-metadata.png" id="responsive-image-full"></img></center></span>
</p>
<p>Second, the definition of its input ports:
<span class="raw-html"><center><img src="excel-mockup-input-port-specs.png" id="responsive-image-full"></img></center></span>
</p>
<p>Third, the definition of its output ports:
<span class="raw-html"><center><img src="excel-mockup-output-port-specs.png" id="responsive-image-full"></img></center></span>
</p>
<p>Finally, the definition of its mock-up clauses, specifying the outputs that shall correspond to specific times and inputs:
<span class="raw-html"><center><img src="excel-mockup-clauses.png" id="responsive-image-full"></img></center></span>
</p>
</div>
<div class="section" id="a-few-supplementary-pieces-of-advice">
<h2><a class="toc-backref" href="#id147">A few Supplementary Pieces of Advice</a></h2>
<ul class="simple">
<li>inside the metadata worksheet, the first version listed (<tt class="docutils literal">Version of the Dataflow Unit Mockup Format</tt>)  is read-only, as it is the current version of the mock-up <em>format</em> (not the version of the particular mock-up being defined; for that see the <tt class="docutils literal">Version of the <span class="pre">mock-up</span></tt> metadata instead); please ensure you are always using a spreadsheet template in the latest, stable version of this DUMF format (otherwise it is bound to be rejected by tools that are in more recent versions)</li>
</ul>
<ul class="simple">
<li>the overall structure of the Excel spreadsheet and each of worksheets are protected (locked by default), to avoid erroneous user-originating changes; they can nevertheless be unlocked thanks to the <tt class="docutils literal">dataflow</tt> password; use it with care!</li>
<li>semantics shall be always specified; a warning is emitted otherwise</li>
<li>exotic, Unicode characters shall be avoided; otherwise a warning will be issued and the corresponding string will be replaced with <tt class="docutils literal"><span class="pre">(non-ASCII</span> string)</tt></li>
<li>when defining a boolean value, it should be specified as following strings: either <tt class="docutils literal">&quot;true&quot;</tt> or <tt class="docutils literal">&quot;false&quot;</tt> (we recommend not to use Excel-defined boolean constants, which are represented as <tt class="docutils literal">TRUE</tt> / <tt class="docutils literal">FALSE</tt>, <tt class="docutils literal">VRAI</tt> / <tt class="docutils literal">FAUX</tt>, etc.)</li>
</ul>
</div>
<div class="section" id="possible-enhancements">
<h2><a class="toc-backref" href="#id148">Possible Enhancements</a></h2>
<ul class="simple">
<li>the patterns recognized could include the state of another input port (ex: <tt class="docutils literal">{I4,I6}</tt> meaning that <tt class="docutils literal">I4</tt> should be in the same state as <tt class="docutils literal">I6</tt>), of course provided that the dependency graph remains acyclic</li>
<li>port names could also be pattern-matched; for example an input match spec could include <tt class="docutils literal"><span class="pre">{&quot;ip_*&quot;,{set,3}}</span></tt> to specify that any input port whose name is prefixed with <tt class="docutils literal">ip_</tt> and that is set to <tt class="docutils literal">3</tt> would validate this part of the match</li>
<li>during a time-step, a given unit might be triggered any number of times (from none to more than once); even if introducing logical moments (i.e. replacing timesteps with a pair made of a timestep and a logical moment, i.e. a diasca) is probably not desirable, maybe specifying whether a unit is allowed to be triggered once (<tt class="docutils literal">once</tt>) or any number of times (<tt class="docutils literal">always</tt>) could be useful</li>
</ul>
<p></p>
</div>
</div>
<div class="section" id="integrating-a-model-as-a-dataflow-a-short-walkthrough">
<h1><a class="toc-backref" href="#id149">Integrating a Model As a Dataflow: a Short Walkthrough</a></h1>
<p>So you've got a <tt class="docutils literal">Foobar</tt> model, maybe pre-existing, maybe just specified, and you want to integrate it in a more general dataflow? Here is a list of simple steps to go through in order to ease that integration.</p>
<p>For the sake of example, let's suppose that this <tt class="docutils literal">Foobar</tt> model performs energy-related assessments in the context of cities.</p>
<div class="section" id="preliminary-step-0-remembering-the-basics">
<h2><a class="toc-backref" href="#id150">Preliminary Step (#0): Remembering the Basics</a></h2>
<p>Let's recap first the general structure that we target and the features we need to support.</p>
<p>A model embodies <strong>computations</strong> of some sorts (for example, here, some energy evaluations) that are <strong>intermingled with others</strong> (ex: there may be interrelated evaluations about waste or transportation), the whole <strong>applying to the state of a system</strong> (ex: a city) and <strong>updating it in turn</strong> (ex: all these evaluations are performed for a given year, and the dynamics they capture will lead to an updated city, available for the next simulated year).</p>
<p>To turn such a simulation into a dataflow, both the <strong>state</strong> of the system and the <strong>computations</strong> performed on it have to be modelled thanks to dataflow constructs.</p>
<p>Here the state is typically modelled based on <strong>Dataflow Objects</strong> (ex: the city as a whole may be hierarchically divided into districts, buildings, households, etc. - each of these urban objects being represented by a dedicated dataflow object instance).</p>
<p>The main role of these dataflow objects is to store, thanks to attributes, the relevant state information of these various parts of the system so that the expected computations can be carried, i.e. so that these computations can be fed with the data they need and so that they can as well update that state with their results. As a consequence, <strong>prior to the integration of the computations, an agreement on the structure</strong> (based on dataflow objects) and <strong>on the content</strong> (based on the attributes of these objects) <strong>of the description of the system at hand shall be found</strong>.</p>
<p>As for the computations (including the ones provided by the <tt class="docutils literal">Foobar</tt> model), they are to be described macroscopically in terms of a set of <strong>Dataflow Processing Units</strong> (ex: a type of unit can correspond to the energy evaluation, whereas another type of unit may take care of waste and transportation).</p>
<p>Of course <strong>multiple instances of a given type of unit may exist</strong> to account for the underlying multiplicities of dataflow objects. For example, if some computations have to be done strictly on a per building basis, then a corresponding processing unit type may be defined, and a bijection (a one-to-one relationship) between buildings and such unit instances should exist.</p>
<p>Moreover one can note that not only a given unit type may be instantiated more than once, but also that <strong>such a unit may have to be created and deleted dynamically</strong>, in the course of the simulation. In our example, on a given simulated year the creation of a building in the city shall result in the creation of a related instance of our unit type; conversely, destroying a building shall imply the deletion of its associated unit instance.</p>
<p>Finally, whether or not urban objects are created or deleted, <em>connections</em> between dataflow elements (processing units and urban objects) are in the general case bound to be modified over simulation time.</p>
<p>These <strong>unit-level operations</strong> (creation, connection, update, deletion, etc.), whether they are done initially or in the course of the simulation, <strong>are to be driven by dedicated unit managers</strong> - whose design and implementation must be planned as well.</p>
</div>
<div class="section" id="step-1-ensure-that-the-overall-simulated-world-can-be-structured-as-a-dataflow">
<h2><a class="toc-backref" href="#id151">Step #1: Ensure that the Overall Simulated World Can be Structured As a Dataflow</a></h2>
<p>In this step we want to retain a clean dataflow approach in order to:</p>
<ul class="simple">
<li>describe the <tt class="docutils literal">Foobar</tt> model as a whole</li>
<li>insert in its context</li>
</ul>
<p>At this step we still see the <tt class="docutils literal">Foobar</tt> model simply as a single, monolithic logical unit. We specify here only what are the &quot;high-level&quot; computation features that each of the units involved in the dataflow offers and the information that each unit requires (not how precisely units are to operate internally).</p>
<p>The purpose of this step is:</p>
<ul class="simple">
<li>to cleanly <strong>separate</strong> the single, consensual description of the system <strong>state</strong> from the usually multiple, diverse <strong>computations</strong> that shall be operated on it; the crucial point is that this state must be defined so that it provides all the information needed by <em>all</em> computations to be operated (those of <tt class="docutils literal">Foobar</tt> and the ones of all other units) - and preferably only them, while keeping these pieces of data orthogonal, i.e. avoiding any duplication of information <a class="footnote-reference" href="#id77" id="id76">[38]</a></li>
<li>to establish how these computations are <strong>organised</strong> - including the ones that are to be taken in charge by this <tt class="docutils literal">Foobar</tt> model</li>
<li>to express the whole uniformly, and <strong>in terms of dataflow constructs</strong> (objects and processing units, and also streams of information)</li>
</ul>
<table class="docutils footnote" frame="void" id="id77" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id76">[38]</a></td><td>For example any needed <em>living space</em> attribute of a (dataflow object) building shall be defined once for all, instead of introducing as many (attribute) variations of it as there will be different unit types requiring such an information. Otherwise the state of dataflow objects would be bound to become increasingly difficult to maintain, if not silently inconsistent (ex: one version of the livable surface being updated while the others not).</td></tr>
</tbody>
</table>
</div>
<div class="section" id="step-2-determine-the-specific-relationships-between-the-dataflow-and-this-model">
<h2><a class="toc-backref" href="#id152">Step #2: Determine the Specific Relationships Between the Dataflow and this Model</a></h2>
<p>At this step we concentrate on the <tt class="docutils literal">Foobar</tt> model and on the units in direct relationship with it.</p>
<p>There will be indeed actual connections between this black box of interest and the rest of the dataflow: the <tt class="docutils literal">Foobar</tt> model is to be <strong>fed by inbound dataflow channels</strong>, and reciprocally <strong>outbound channels are to stem from this box</strong> and feed other elements of the overall dataflow.</p>
<p>This step requires that all dataflow elements in <em>direct</em> interaction with the <tt class="docutils literal">Foobar</tt> model box (whether they are upstream or downstream) are listed and <strong>specified in terms of connectivity</strong> with <tt class="docutils literal">Foobar</tt>: the corresponding channels shall be named and defined, with their multiplicity and their corresponding SUTC information.</p>
<p>The list of <strong>input and output ports that should be ultimately provided</strong> by the logical unit corresponding to <tt class="docutils literal">Foobar</tt> are to be then determined from these channels.</p>
<p>An added bonus of completing this step is that it enables the possibility of defining a mock-up for that <tt class="docutils literal">Foobar</tt> model: now that it is more formally specified as a self-standing component, one is able to devise input and output datasets that can emulate its behaviour as a whole. See the section about <a class="reference internal" href="#mock-up-units">mock-up units</a> for more details.</p>
<p>Alternatively, the completion of the next step might be awaited, so that <em>individual</em> units corresponding to this model can be each represented by a dedicated mock-up.</p>
</div>
<div class="section" id="step-3-break-the-black-box-into-actual-dataflow-units">
<h2><a class="toc-backref" href="#id153">Step #3: Break the Black Box Into Actual Dataflow Units</a></h2>
<p>In the previous steps, the <tt class="docutils literal">Foobar</tt> model was seen as a single black box (one &quot;abstract&quot;, logical unit). Now is the time to break the <tt class="docutils literal">Foobar</tt> black box into pieces, and to express them as a set of actual dataflow blocks.</p>
<p>Indeed, in the general case, for each model <strong>multiple dataflow units are needed</strong> in order to account for the various computational stages and multiplicities that a model must support.</p>
<p>For example, some aggregations (ex: spatial ones) are often to be done before and after the central, domain-specific computations of the model, and for that they need a varying (runtime-determined) number of input and output ports (ex: an instance of the <tt class="docutils literal">Foobar</tt> model may have to accommodate for any number of energy sources).</p>
<p>If simple models may be expressed only thanks to a single processing unit relying on <a class="reference internal" href="#port-iterations">port iterations</a>, more complex models often require to be translated into a <em>set of interlinked dataflow units</em>, some of which taking in charge the bulk of the computations while others are in charge of transforming (ex: aggregating, summing, averaging, converting, routing, etc.) information on their behalf.</p>
<p>So the outcome of this step is to have a <strong>design</strong> of the <tt class="docutils literal">Foobar</tt> model once it has been translated into <strong>a collection of actual dataflow units</strong> whose superposition provides the combined input and output ports that have been determined in the previous step.</p>
</div>
<div class="section" id="step-4-implement-the-corresponding-actual-units">
<h2><a class="toc-backref" href="#id154">Step #4: Implement the Corresponding Actual Units</a></h2>
<p>Now that the <tt class="docutils literal">Foobar</tt> model has been split into real, dataflow units, in the general case <strong>these units</strong> do not exist yet, and thus <strong>have to be implemented</strong> <a class="footnote-reference" href="#id79" id="id78">[39]</a>.</p>
<table class="docutils footnote" frame="void" id="id79" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id78">[39]</a></td><td>Depending on the history of the project, some already available units may be re-used. Similarly, some units may perform fairly standard operations (ex: simple aggregations) and thus may be provided by the dataflow infrastructure as built-in. Usually at least the model-specific computations must be developed.</td></tr>
</tbody>
</table>
<p>Each newly-introduced processing unit can either be a <em>native</em> unit (i.e. written in Erlang and thus directly developed within the dataflow infrastructure), or a unit relying on a <em>language-specific binding</em>.</p>
<p>In this latter case, depending on the programming language that has been preferred, the unit developer will typically rely either on the Python dataflow binding or on the Java one. In both case <strong>the provided dataflow API must be used</strong> in order to define the new unit.</p>
<p>In practice, it boils down simply to:</p>
<ol class="arabic simple">
<li>making this new processing unit <strong>inherit</strong> from the base dataflow unit type</li>
<li>defining the <strong>construction parameters</strong> needed to create a new instance of such a unit</li>
<li>specifying accordingly what its <strong>input and output ports</strong> are (number, name, whether they are iterations, SUTC information, etc.)</li>
<li>defining <strong>how this unit should be activated</strong> (typically whether the setting of any, or all, of its input ports is needed)</li>
<li>defining <strong>what the unit should do when it is activated</strong> (typically read at least some of its input ports that have been set, compute elements from them and from its state, possibly update in turn some of its output ports and its own state)</li>
</ol>
</div>
<div class="section" id="step-5-add-the-corresponding-unit-manager-s">
<h2><a class="toc-backref" href="#id155">Step #5: Add the Corresponding Unit Manager(s)</a></h2>
<p>The previous steps led to the availability of the whole implementation for the <tt class="docutils literal">Foobar</tt> model: now, for this model as well,  the overall <strong>dataflow objects bear all necessary information</strong> (step #1), its <strong>connectivity has been established</strong> (step #2) and <strong>its complete counterpart in terms of dataflow units has been designed and implemented</strong> (respectively step #3 and #4). Therefore we defined how the <tt class="docutils literal">Foobar</tt> model is to be evaluated once properly set-up.</p>
<p>This last step (#5) consists on the definition or update of the <strong>associated unit manager</strong>, in charge of the correct insertion and management of the units corresponding to <tt class="docutils literal">Foobar</tt> in the overall dataflow.</p>
<p>This includes at least how its units shall be created and linked whenever an instance of the <tt class="docutils literal">Foobar</tt> model is needed; various dataflow-level events may have to be supported by a unit manager.</p>
<p>In our example, the <tt class="docutils literal">Foobar</tt> unit manager should be able to be notified that a new building (dataflow object) has been created, so that this manager can create in turn the appropriate new instance of <tt class="docutils literal">Foobar</tt>: the unit manager should ensure that the various units for <tt class="docutils literal">Foobar</tt> are then correctly instantiated and also connected (between themselves and also with the rest of the dataflow).</p>
<p></p>
</div>
</div>
<div class="section" id="requirements-for-the-dataflow-integration-of-a-model">
<h1><a class="toc-backref" href="#id156">Requirements For the Dataflow Integration of a Model</a></h1>
<ul class="simple">
<li><tt class="docutils literal">R1</tt>: a description of the overall dataflow must be defined, in which the target model is represented by a single, abstract, dataflow unit; its inbound and outbound channels shall be specified</li>
<li><tt class="docutils literal">R2</tt>: the target model itself shall be defined in terms of dataflow constructs</li>
<li><tt class="docutils literal">R3</tt>: the general operational rules apply (ex: compliance with the underlying operating system and libraries)</li>
</ul>
<p></p>
</div>
<div class="section" id="implementation-section">
<h1><a class="toc-backref" href="#id157">Implementation Section</a></h1>
<div class="section" id="id80">
<h2><a class="toc-backref" href="#id158">Mode of Operation</a></h2>
<p>As already mentioned and represented in the class diagram below, <strong>processing units</strong> are implemented as instances of the <tt class="docutils literal">DataflowProcessingUnit</tt> class, a child class of the <tt class="docutils literal">DataflowBlock</tt> one, itself a child class of the basic (Sim-Diasca) <tt class="docutils literal">Actor</tt> one (note that, actually, <em>all</em> classes represented on this diagram are child classes - directly or not - of the <tt class="docutils literal">Actor</tt> one).</p>
<p>Most units are <em>passive</em> actors: they will be solely scheduled if/when some of their input ports are triggered, which, depending on their policy, might result in their activation. Some units (ex: source ones) may be <em>active</em>, in the sense that they may choose to develop a spontaneous behaviour (typically to auto-activate periodically).</p>
<p>A special case of unit has been defined, the <tt class="docutils literal">DataflowMockupUnit</tt>. Such <strong>mock-up unit</strong> provides a generic emulation of a unit, associating output values to input ones based on the data (rules) it has been provided with. It is typically used to develop termination plugs that allow to wait until the implementation of the final unit is ready, and to validate it afterwards.</p>
<p><strong>Ports</strong> (input and output ones alike) are mere data-structures (records) held by their block (maintaining an associative table for both of them).</p>
<p>We propose the following convention to name the variables holding a port:</p>
<ul class="simple">
<li>the name of the variable shall reflect the name of the corresponding port (ex: if the port is named <tt class="docutils literal">&quot;My distance&quot;</tt>, the variable name may begin with <tt class="docutils literal">MyDistance</tt></li>
<li>if it is an input port, the variable name may end with <tt class="docutils literal">IPort</tt> (ex: <tt class="docutils literal">MyDistanceIPort</tt>)</li>
<li>if it is an output port, the variable name may end with <tt class="docutils literal">OPort</tt> (ex: <tt class="docutils literal">MyDistanceOPort</tt>)</li>
</ul>
<p>Implementation-wise, <strong>channels</strong> do not exist per se, they are abstracted out thanks to ports.</p>
<p>The static channel-related information (ex: <tt class="docutils literal">SUTC</tt>, for semantics, unit, type, constraints) is held by all endpoints (the output port and its linked input ports); as their metadata are checked for compliance when ports get connected, the exchanged values do not include them, since they are automatically checked in turn for compliance at port sending and receiving.</p>
<p>Dataflow <strong>values</strong> are records that store their accuracy, timestamp and, of course, actual value. As always, they are exchanged through actor messages, managed by the engine.</p>
<p>As for the <strong>dataflow objects</strong>, they unsurprisingly inherit from the <tt class="docutils literal">DataflowObject</tt> class. These actors participate to the description of the simulated world and, thanks to their <strong>dataflow attributes</strong> (special actor attributes that map to a pair of input and output ports), they are ready to be integrated in a dataflow.</p>
<p>Finally, instances of dataflow objects of a given class (ex: <tt class="docutils literal">Building</tt>) are governed by a <strong>dataflow object manager</strong> specific to this class (ex: <tt class="docutils literal">BuildingManager</tt>). All these managers inherit from the <tt class="docutils literal">DataflowObjectManager</tt> base, abstract class.</p>
<p>Similarly, all instances of a given type of unit (ex: <tt class="docutils literal">EnergyDemand</tt>) are governed by a <strong>unit manager</strong> specific to this class (ex: <tt class="docutils literal">EnergyDemandManager</tt>), and all these managers inherit from the <tt class="docutils literal">UnitManager</tt> base, abstract class.</p>
<p>The overall <strong>dataflow</strong> could have remained implicit (in the sense that no specific instance could have been defined in order to designate it as such, a dataflow being just an abstract concept corresponding to a set of actual, interconnected blocks), yet having it in an explicit form (i.e. as an instance of a well-defined <tt class="docutils literal">Dataflow</tt> class) has been deemed more convenient and future-proof.</p>
<p>So we end up with the following dataflow-related class hierarchy:</p>
<p><span class="raw-html"><center><img src="dataflow-class-hierarchy.png" id="responsive-image-large"></img></center></span>
</p>
</div>
<div class="section" id="usage-defining-one-s-dataflow">
<h2><a class="toc-backref" href="#id159">Usage: Defining One's Dataflow</a></h2>
<p>Preferably an overall schema of the dataflow is determined first. One must keep in mind that <em>a dataflow is a graph of computations</em>, i.e. a description of interlinked <em>tasks</em>, processed by units, possibly fueled with information from objects.</p>
<p>Then, for each type of unit (as of course a dataflow may include multiple instances of the same unit), a child class of <tt class="docutils literal">DataflowProcessingUnit</tt> shall be defined.</p>
<p>The actual processing done by that kind of unit is to be implemented by overriding its <tt class="docutils literal">activate/1</tt> method. It will be based on the unit state, including the value carried by its input ports that are set. In some very rare cases, a spontaneous behaviour might be defined as well, if appropriate for that unit.</p>
<p>Any dataflow object used shall also be defined, which mainly consist on defining its (dataflow) attributes.</p>
<p>Once all object and unit classes are available, the target dataflow instance can be built. This is done by creating first the relevant block instances (either from a data stream listing their construction parameters, or programmatically), interconnecting their ports and registering themselves to their federating dataflow.</p>
<p>Then, once the simulation is started, some source blocks are expected to get activated (possibly thanks to active blocks, or to explicit block activation); their triggered ports shall in turn activate other blocks and trigger other ports, animating the whole dataflow so that it performs the processing that is expected from it.</p>
<p>Please refer to the <tt class="docutils literal">Dataflow Urban Example</tt>, whose sources are located in the <tt class="docutils literal"><span class="pre">mock-simulators/dataflow-urban-example</span></tt> directory, for a full source of inspiration.</p>
</div>
<div class="section" id="class-or-instance-level-checking">
<h2><a class="toc-backref" href="#id160">Class or Instance-level Checking</a></h2>
<p>Any given instance dataflow block (ex: a processing unit) may declare ports, statically or not.</p>
<p>Ports created statically are usually the same for all instances of that type of dataflow element. So, instead of performing checks (ex: in terms of semantics or types) for each of these instances (that are potentially very numerous), the verification is better done once, at the class level - based on its declarations.</p>
<p>For example, for units, any of them should preferably declare statically these information so that its unit manager can check them at simulation startup <a class="footnote-reference" href="#id82" id="id81">[40]</a>.</p>
<table class="docutils footnote" frame="void" id="id82" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id81">[40]</a></td><td>See <tt class="docutils literal">class_DataflowElementActor:declare_static_information_for/1</tt>.</td></tr>
</tbody>
</table>
<p>To establish whence semantics and typing information come for a given dataflow element, the following rules apply:</p>
<ul class="simple">
<li>for semantics:<ul>
<li>any kind of semantics can be reported by this type of dataflow element by having it define and export its <tt class="docutils literal">get_declared_semantics/0</tt> static method <a class="footnote-reference" href="#id84" id="id83">[41]</a>; this may be a way of specifying the semantics both for the initial ports and for any other port that may be created in the course of the simulation (if specified, must be exhaustive)</li>
<li>otherwise (if no <tt class="docutils literal">get_declared_semantics/0</tt> method is exported), the semantics may be deduced from its <tt class="docutils literal">get_port_specifications/0</tt> static method, if of course it has been defined and exported</li>
<li>otherwise, the element does not report any semantics</li>
</ul>
</li>
<li>for types, a slightly different logic applies: the <tt class="docutils literal">get_declared_types/0</tt> static method should be used whenever having to introduce new types, especially so that the types mentioned through  <tt class="docutils literal">get_port_specifications/0</tt> can be resolved</li>
</ul>
<table class="docutils footnote" frame="void" id="id84" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id83">[41]</a></td><td>For semantics, their name is also their definition (ex: <tt class="docutils literal">'my semantics'</tt>), whereas types have to be specifically defined (ex: <tt class="docutils literal">my_type</tt> is <tt class="docutils literal">[integer]</tt>) before being used (ex: <tt class="docutils literal">my_value</tt> is of type <tt class="docutils literal">my_type</tt>).</td></tr>
</tbody>
</table>
<p>Defining <tt class="docutils literal">get_port_specifications/0</tt> is recommended, as by design the static information that is reported matches the ports that are initially created. Otherwise explicit checking shall be done when creating the actual initial ports, to ensure their information match any one that would be statically defined thanks to <tt class="docutils literal">get_declared_{semantic,type}s/0</tt>.</p>
<p>Finally, some amount of runtime checking may still be necessary, as ports may be created dynamically.</p>
</div>
<div class="section" id="scheduling-cycle-of-experiments">
<h2><a class="toc-backref" href="#id161">Scheduling Cycle of Experiments</a></h2>
<p>The logical order of the operations involved in the step-by-step evaluation of an experiment has been presented in the section about <a class="reference internal" href="#experiment-progress">Experiment Progress</a>.</p>
<p>However dataflows may be arbitrarily complex computation graphs, with various branches and, potentially, cycles, so detecting when the intra-tick evaluation of a given dataflow is over (i.e. when none of its blocks can be triggered anymore) is not straightforward, as this consists mostly in detecting the <em>absence</em> of an event.</p>
<p>The solution elected here, in technical terms, consists on inducing an offset in this three-stage cycle (experiment entry/dataflow evaluations/experiment exit).</p>
<p>Indeed, at each new tick, the experiment <em>exit</em> point is triggered first (obviously not doing anything for the very first tick); it is the only actor here having a spontaneous behaviour.</p>
<p>It then triggers (as always thanks to an actor message) the experiment <em>entry</em> point, which performs the tick-specific initialisations. This usually leads to the update of various dataflow elements and thus to the evaluation of various dataflow for that tick.</p>
<p>Once none of the dataflow elements set any output port, no other dataflow element can be triggered anymore (no more diasca created), hence the engine determines that this tick is now over, and schedules the next planned one.</p>
<p>Then again the experiment exit point is scheduled and is free to perform any termination action for the dataflow evaluations made at the previous tick. Then it triggers the experiment entry point, which triggers the dataflow evaluations again, and so on.</p>
</div>
<div class="section" id="life-cycle">
<h2><a class="toc-backref" href="#id162">Life Cycle</a></h2>
<p>The goal is to rely on a single, shared evaluation infrastructure (taking in charge by a relevant set of singleton managers) allowing for multiple dataflow instances (each with its own object and unit instances).</p>
<p>As a consequence, the dataflow blocks (i.e. the actual dataflow objects and units) are:</p>
<ul class="simple">
<li><em>referenced</em> by their top-level respective managers (i.e. the world manager and experiment manager, which maintain a per-class list of instances)</li>
<li><em>owned</em> by the dataflow to which they are registered (which may then delete them appropriately)</li>
</ul>
<p>As for the various object and unit managers, they are owned by, respectively, the world manager and the experiment one.</p>
<p>Note that all the classes involved here:</p>
<ul class="simple">
<li><tt class="docutils literal">class_Dataflow</tt></li>
<li><tt class="docutils literal">class_Dataflow{Block,Object,ProcessingUnit}</tt></li>
<li><tt class="docutils literal">class_Dataflow{Object,Unit}Manager</tt></li>
<li><tt class="docutils literal">class_Experiment{Entry,Exit}Point</tt></li>
<li><tt class="docutils literal">class_{Experiment,World}Manager</tt></li>
</ul>
<p>are child classes of the <tt class="docutils literal">class_Actor</tt> one, and as such will have their instances automatically removed at simulation end.</p>
</div>
<div class="section" id="implementation-details">
<h2><a class="toc-backref" href="#id163">Implementation Details</a></h2>
<p>The dataflow constructs are defined, in the code base, in the <tt class="docutils literal"><span class="pre">sim-diasca/src/core/src/dataflow</span></tt> source tree.</p>
<p>Traces sent by the dataflow architecture are available in the <tt class="docutils literal">Core.Dataflow</tt> category and its children categories.</p>
<p>A dataflow initialization file has preferably for extension <tt class="docutils literal">.init</tt> (ex: <tt class="docutils literal"><span class="pre">dataflow-urban-example.init</span></tt>).</p>
<p>It generally lists the creations of:</p>
<ul class="simple">
<li>the relevant base components, i.e. the WM and its dataflow object managers, the EM and its dataflow unit managers</li>
<li>at least one dataflow</li>
<li>the relevant actual instances of dataflow objects and processing units</li>
</ul>
<p></p>
</div>
</div>
<div class="section" id="appendices">
<h1><a class="toc-backref" href="#id164">Appendices</a></h1>
<div class="section" id="annex-1-design-questions">
<h2><a class="toc-backref" href="#id165">Annex 1: Design Questions</a></h2>
<ul class="simple">
<li>Should all output ports of all blocks of the dataflow emit at each diasca a value, even if it did not change (event-based or synchronous)?; if yes, many useless sendings and schedulings, and not all units have the same temporality, so a year-based one, if included in a simulation with a daily one, would have to change its behaviour; so we preferred opting for an <strong>event-based</strong> mode of operation</li>
<li>As not all state changes/operations are instantaneous, should <strong>delays</strong> (in diascas or ticks) induced by a block be managed? (ex: ignition spark received, explosion happening 4 milliseconds afterwards)</li>
<li>Would it be possible and useful that units can be <strong>composed</strong>, i.e. that a given unit can actually be recursively made of sub-units? If such a feature was wanted, then <a class="reference external" href="http://www.eclipse.org/ecoretools/twoapproaches">ecore</a> could be used to define the corresponding system, and two different approaches could be considered:<ul>
<li>either defining, directly at this dataflow level, <em>nested units</em>, and manage the consequences thereof (ex: when the inputs of a &quot;macro&quot; unit would change, its outputs would change in turn accordingly, yet only <em>after some delay in terms of logical moments</em> (i.e. only once some of them elapsed, with state transitions that may be arbitrarily deferred)</li>
<li>or introduce new, higher-level concepts, such as the one of <em>assemblies</em> that can be nested; an assembly would ultimately translate to a basic, non-nested dataflow, by collapsing a (multi-level, compounded, compact) assembly into a (single-layer, uniform, intricate) dataflow; for that assemblies (either user-defined or generated) would be recursively unboxed and expanded into their parts until only standard dataflow blocks are found (a bit like when going from a higher-level electronic schematics to its full, elementary counterpart at the level of the logic gates)</li>
</ul>
</li>
<li>Should large datastructures have to be carried by channels, maybe these data currently pushed by an output port shall be pulled by the input ports instead? (anyway this will most probably lead to a term duplication anyway)</li>
<li>If a model deals with a currency (ex: euros, or US dollars of year 2012), is the best approach to have its unit flagged as <tt class="docutils literal">dimensionless</tt> (hence, not <tt class="docutils literal">euro</tt>) and complement this information at the semantics level?</li>
</ul>
</div>
<div class="section" id="annex-2-possible-overall-improvements">
<h2><a class="toc-backref" href="#id166">Annex 2: Possible Overall Improvements</a></h2>
<ul class="simple">
<li>knowing that a given type of unit, thanks to its constructor, can be <strong>parametrised</strong> (leading to its instances behaving differently), this may be represented graphically: instead of designating a unit type as <tt class="docutils literal">FoobarUnit</tt>, it may be shown as <tt class="docutils literal">FoobarUnit(height,width,color)</tt></li>
<li>a type of bus may be named (defining an ordered list of channel types); afterwards, one may consider bus auto-grouping, i.e. having a transparent translation of a bus-as-a-graphical-symbol (thus with N channels underneath) into a single pseudo-channel conveying a N-element tuple containing the related channel values (thus relying on one sending instead of N)</li>
<li>a group of ports (<em>portset</em>?) may be represented by a unique, conventional graphical element (a portset is to ports what buses are to channels); more specific activation policies could rely on portsets</li>
<li>scale hints could be revamped (as a unit may have one scale, its inputs others, and the same for its outputs)</li>
<li>a consensual, sufficiently expressive language of types should be defined and enforced all the way regarding the values conveyed by the dataflow (such a check is not done currently)</li>
<li>the state changes of a dataflow may be collected by a process (should this feature be enabled), which could either write them in a file according to a conventional format (ex: <tt class="docutils literal"><span class="pre">*.df-state</span></tt>) or make them available through an ad-hoc http server; in both cases, these information could feed a tool representing graphically (according to the conventions listed in <a class="reference internal" href="#annex-3">annex 3</a>) the state of a dataflow (as an image), or the changes over time of the state of a dataflow (as a video made out of frames, generated with as few layout changes as possible from one to the next)</li>
<li>a support for a Python implementation of unit managers (at least the simplest/most classical ones) could be provided</li>
</ul>
</div>
<div class="section" id="annex-3-conventions-for-the-graphical-representation-of-dataflows">
<span id="annex-3"></span><h2><a class="toc-backref" href="#id167">Annex 3: Conventions for the Graphical Representation of Dataflows</a></h2>
<div class="section" id="example-diagrams">
<h3>Example Diagrams</h3>
<p>When having to represent a given dataflow of interest (typically in a design phase), to favour consistency we recommend that one starts from the diagrams we already made for this document and for the base examples.</p>
<p>For that, one shall use <a class="reference external" href="https://sourceforge.net/projects/dia-installer/">Dia</a>, a free software diagram editor.</p>
<p>Our <tt class="docutils literal"><span class="pre">dataflow-diagram-toolbox.zip</span></tt> <a class="footnote-reference" href="#id86" id="id85">[42]</a> archive centralizes the best examples for such a reuse, from which more homogeneous user diagrams can be easily derived.</p>
<table class="docutils footnote" frame="void" id="id86" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id85">[42]</a></td><td>This archive can be generated from <tt class="docutils literal"><span class="pre">sim-diasca/doc/dataflow-howto</span></tt> by running <tt class="docutils literal">make</tt>.</td></tr>
</tbody>
</table>
<p>Later, a specific Dia library for dataflows could be devised (should no higher-level tool be available then).</p>
</div>
<div class="section" id="color-charter">
<h3>Color Charter</h3>
<p>Here are the color definitions that we recommend to respect, for clarity (when two colors are specified, the first is a lighter version of the second):</p>
<p><span class="raw-html"><center></span></p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Elements to Represent Graphically</th>
<th class="head">Associated Color</th>
<th class="head">Color RGB Definition</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Input ports</td>
<td>Dark orange</td>
<td><tt class="docutils literal">ffcd70</tt> / <tt class="docutils literal">ff8900</tt></td>
</tr>
<tr><td>Output ports</td>
<td>Dark green</td>
<td><tt class="docutils literal">688e68</tt> / <tt class="docutils literal">82ae82</tt></td>
</tr>
<tr><td>Channels, buses and port-level meta-data</td>
<td>Pure blue</td>
<td><tt class="docutils literal">0000ff</tt></td>
</tr>
<tr><td>Lines for shapes (ex: units)</td>
<td>Pure black</td>
<td><tt class="docutils literal">000000</tt></td>
</tr>
<tr><td>Default background</td>
<td>Pure white</td>
<td><tt class="docutils literal">ffffff</tt></td>
</tr>
<tr><td>State-related background</td>
<td>Light purple</td>
<td><tt class="docutils literal">f1e3f1</tt></td>
</tr>
<tr><td>Dataflow object</td>
<td>Stronger purple</td>
<td><tt class="docutils literal">cfaecf</tt> / <tt class="docutils literal">a13ba1</tt></td>
</tr>
<tr><td>Computation-related background</td>
<td>Light blue</td>
<td><tt class="docutils literal">e1ebff</tt></td>
</tr>
<tr><td>Dataflow unit</td>
<td>Stronger blue</td>
<td><tt class="docutils literal">96d2e6</tt> / <tt class="docutils literal">0000ff</tt></td>
</tr>
<tr><td>Scale indication background</td>
<td>Light yellow</td>
<td><tt class="docutils literal">faf8b3</tt></td>
</tr>
<tr><td>Probe</td>
<td>Blue</td>
<td><tt class="docutils literal">3838f4</tt></td>
</tr>
<tr><td>Post-it like comment</td>
<td>Lighter yellow</td>
<td><tt class="docutils literal">ffffc8</tt></td>
</tr>
</tbody>
</table>
<p><span class="raw-html"></center></span></p>
<p>Buses (i.e. sets of channels) are represented like channels, yet thicker (generally, their line width is to be equal to 0.10 cm times the number of channels they regroup) and barred with a dash (a bit like in electronics), with the channel count being displayed just above.</p>
<p>Both channels and buses may adopt different colors (preferably blueish, though) to help the reader understanding the overall connectivity.</p>
</div>
</div>
<div class="section" id="annex-4-credits">
<h2><a class="toc-backref" href="#id168">Annex 4: Credits</a></h2>
<p>Many thanks, among others, go to:</p>
<ul class="simple">
<li>Samuel Thiriot, for many inspiring comments and ideas</li>
<li>Omar Benhamid, for rich exchanges about the entry and exit points of a dataflow</li>
<li>Robin Huart, notably for the mock-up units, the language bindings and the platform integration</li>
<li>Karel Redon, for thoughts about the buses and their graphical representation, and for the Python workbench</li>
</ul>
<p><span class="raw-html"><a name="sim_diasca_bottom"></a></span></p>
</div>
</div>
</div>
</body>
</html>
