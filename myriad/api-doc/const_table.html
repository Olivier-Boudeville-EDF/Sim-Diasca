<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module const_table</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module const_table</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>This module allows to generate a <b>read-only associative table whose
 key/value pairs can be read from any number (potentially extremely large) of
 readers very efficiently</b> (possibly the most efficient way in Erlang).


<h2><a name="description">Description</a></h2><p>This module allows to generate a <b>read-only associative table whose
 key/value pairs can be read from any number (potentially extremely large) of
 readers very efficiently</b> (possibly the most efficient way in Erlang).</p>

 <p>No ETS table, replication (ex: per-user table copy) or message sending is 
involved: thanks to meta-programming, a module is generated on-the-fly, 
exporting as many functions as there are different keys in the table of 
interest; calling a function corresponding to a key returns the associated 
value.</p>

 More precisely, a module name (ex: 'foobar') and a <code>table:table(atom(),
 any())</code> are provided to <code>const_table:generate/2</code>; for each key/value pair in
 the specified table (ex: <code>{</code>baz', 42.0}'), a 0-arity function is generated and
 exported in that module, as if we had:<pre> -module(foobar).

 [...]

 -export([baz/0]).

 -spec baz() -&gt; term().
 baz() -&gt;
    42.0.</pre>

 <p>Then third-party code can call for example <code>foobar:baz()</code> and have <code>42.0</code> 
returned. This is presumably the most efficient way of sharing constants in 
Erlang.</p>

 <p>Keys must be atoms, and the table of interest shall be immutable (const), even 
if, thanks to hot code upgrade, one may imagine updating the table at 
will, having any number of successive versions of it.</p>

 However generating a table of the same name more than once should be done with
 care, as if a given table is generated three times, the initial table would
 become 'current', then 'old', and then be removed. Any process that would
 linger in it would then be terminated (see
 <a href="http://www.erlang.org/doc/reference_manual/code_loading.html" target="_top"><tt>http://www.erlang.org/doc/reference_manual/code_loading.html</tt></a>). However, due
 to the nature of these tables (just one-shot fully-qualified calls, no
 recursion or message-waiting construct), this is not expected to happen.

<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#generate-2">generate/2</a></td><td>Generates and loads a pseudo-module sharing the entries of specified 
table by exporting as many functions named according to the keys and returning 
the value corresponding to the selected key.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="generate-2">generate/2</a></h3>
<div class="spec">
<p><tt>generate(ModuleName::<a href="basic_utils.html#type-module_name">basic_utils:module_name()</a>, Table::<a href="table.html#type-table">table:table()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Generates and loads a pseudo-module sharing the entries of specified 
table by exporting as many functions named according to the keys and returning 
the value corresponding to the selected key.</p>

 Note that no actual module file is generated (ex: no 'foobar.beam'), the
 operation remains fully in-memory.
</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
