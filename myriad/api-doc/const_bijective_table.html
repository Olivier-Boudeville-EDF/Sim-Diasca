<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module const_bijective_table</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module const_bijective_table</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>This module allows to generate <b>modules sharing read-only two-way
 (bijective) associative tables whose stored pairs can be read from any number
 (potentially extremely large) of readers very efficiently</b> (possibly the 
most efficient way in Erlang).


<h2><a name="description">Description</a></h2><p>This module allows to generate <b>modules sharing read-only two-way
 (bijective) associative tables whose stored pairs can be read from any number
 (potentially extremely large) of readers very efficiently</b> (possibly the 
most efficient way in Erlang).</p>

 <p>They are especially useful in order to share a single, larger table (specific 
to the generated module), moreover with a low overhead. If multiple tables 
("topics") are to be shared, consider relying on the modules generated by the 
const_bijective_topics module instead, offering a similar API.</p>

 <p>These pairs can be decided at runtime, from any source, and their elements can 
be of any permanent (non-transient) type (not atoms only; the first elements 
can be heterogeneous, they do not have to be of the same type, and the same of 
course applies for the second elements). Specifying a transient type will 
result in a badarg. As two-way conversions are to be performed, for a given 
set of values (first ones or second ones), there must be no duplicated 
elements (otherwise no bijectivity can exist).</p>

 <p>These tables may be kept in-memory only (hence with the corresponding modules 
being generated and used at runtime) and/or be generated and stored in an 
actual BEAM file, for a later direct (re)loading thereof.</p>

 <p>Two ways of performing element look-up are provided: 
- the 'strict' one, based on get_{first,second}_for/1 functions, for which an 
element (first or second) must be found in the table (otherwise an exception 
is thrown) 
- the 'maybe' one, which adds to the 'strict' get_{first,second}_for/1 
functions, the get_maybe_{first,second}_for/1, which return 'undefined' should 
the specified element not be found in the table</p>

 <p>(the 'maybe' one is not enabled unconditionally as it slows down very slightly 
the strict functions, whereas it may be useless)</p>

 <p>No ETS table, replication (ex: per-user table copy) or message sending is 
involved: thanks to metaprogramming (parse transform), a module is generated 
on-the-fly, exporting two functions designed to access either of the elements 
of the entries of interest.</p>

 <p>More precisely, a module name (ex: 'foobar') and a list of <code>{any(), any()}</code>
 entries must be provided to the <code>const_bijective_table:generate*/*</code> functions;
 any element E of any pair in the resulting table (e.g. 42.0 in <code>{</code>baz', 
42.0}') can then be accessed thanks to foobar:get_{first|second}_for/1 
(e.g. baz = foobar:get_first_for(42.0)).</p>

 <p>For that these two 1-arity functions are generated and exported in that 
module, as if we were using a bijective_table() underneath.</p>

 <p>No restriction applies to the elements stored (notably they may be all of 
different types), except the absence of duplicates between first values and 
between second ones..</p>

 <p>This is presumably the most efficient way of sharing constants in Erlang.</p>

 <p>However generating a module of the same name more than once should be done
 with care, as if a given module is generated three times (hence updated/loaded
 twice), the initial module would become 'current', then 'old', and then be
 removed. Any process that would linger in it would then be terminated (see
 <a href="http://www.erlang.org/doc/reference_manual/code_loading.html" target="_top"><tt>http://www.erlang.org/doc/reference_manual/code_loading.html</tt></a>). However, due 
to the nature of these modules (just one-shot fully-qualified calls, no 
recursion or message-waiting construct), this is not expected to happen.</p>

 Refer to:
 - const_bijective_table_test.erl for an usage example and testing thereof
 - bijective_table.erl for a runtime, mutable, term-based bijective table
 - const_bijective_topics.erl, to generate modules able to share multiple
 tables (not a single one like this one)
 - const_table.erl, for a constant, "simple" (oneway) associative table

<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-any_directory_path">any_directory_path()</a></h3>
<p><tt>any_directory_path() = <a href="file_utils.html#type-any_directory_path">file_utils:any_directory_path()</a></tt></p>


<h3 class="typedecl"><a name="type-element_lookup">element_lookup()</a></h3>
<p><tt>element_lookup() = <a href="const_bijective_topics.html#type-element_lookup">const_bijective_topics:element_lookup()</a></tt></p>


<h3 class="typedecl"><a name="type-entries">entries()</a></h3>
<p><tt>entries() = [<a href="#type-entry">entry()</a>]</tt></p>
<p> Entries that can be fed to a const-bijective table.</p>

<h3 class="typedecl"><a name="type-entry">entry()</a></h3>
<p><tt>entry() = {<a href="#type-first_type">first_type()</a>, <a href="#type-second_type">second_type()</a>}</tt></p>
<p> An entry to be fed to a const-bijective table.</p>

<h3 class="typedecl"><a name="type-file_name">file_name()</a></h3>
<p><tt>file_name() = <a href="file_utils.html#type-file_name">file_utils:file_name()</a></tt></p>


<h3 class="typedecl"><a name="type-first_type">first_type()</a></h3>
<p><tt>first_type() = <a href="#type-permanent_term">permanent_term()</a></tt></p>
<p> Designates the first elements of the table pairs.
 A module-based storage cannot hold transient terms.</p>

<h3 class="typedecl"><a name="type-module_name">module_name()</a></h3>
<p><tt>module_name() = <a href="basic_utils.html#type-module_name">basic_utils:module_name()</a></tt></p>


<h3 class="typedecl"><a name="type-permanent_term">permanent_term()</a></h3>
<p><tt>permanent_term() = <a href="type_utils.html#type-permanent_term">type_utils:permanent_term()</a></tt></p>


<h3 class="typedecl"><a name="type-second_type">second_type()</a></h3>
<p><tt>second_type() = <a href="#type-permanent_term">permanent_term()</a></tt></p>
<p> Designates the second elements of the table pairs.
 A module-based storage cannot hold transient terms.</p>

<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#generate_in_file-2">generate_in_file/2</a></td><td>Generates in-file (a BEAM file created in the current directory) a module 
sharing bijectively the specified entries by exporting suitably-generated 
get_{first,second}_for/1 functions ('strict' look-up) in order to access 
either element of the recorded pairs.</td></tr>
<tr><td valign="top"><a href="#generate_in_file-3">generate_in_file/3</a></td><td>Generates in-file (a BEAM file created in the current directory) a module 
sharing bijectively the specified entries by exporting suitably-generated 
functions in order to access either element of the recorded pairs.</td></tr>
<tr><td valign="top"><a href="#generate_in_file-4">generate_in_file/4</a></td><td>Generates in-file (a BEAM file created in the specified directory) a 
module sharing bijectively the specified entries by exporting 
suitably-generated functions in order to access either element of the recorded 
pairs.</td></tr>
<tr><td valign="top"><a href="#generate_in_memory-2">generate_in_memory/2</a></td><td>Generates in memory (only) and loads a module sharing bijectively the 
specified entries by exporting suitably-generated get_{first,second}_for/1 
functions ('strict' look-up) in order to access either element of the recorded 
pairs.</td></tr>
<tr><td valign="top"><a href="#generate_in_memory-3">generate_in_memory/3</a></td><td>Generates in memory (only) and loads a module sharing bijectively the 
specified entries by exporting suitably-generated functions in order to access 
either element of the recorded pairs.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="generate_in_file-2">generate_in_file/2</a></h3>
<div class="spec">
<p><tt>generate_in_file(ModuleName::<a href="#type-module_name">module_name()</a>, Entries::<a href="#type-entries">entries()</a>) -&gt; <a href="#type-file_name">file_name()</a></tt><br></p>
<p> </p>
</div><p><p>Generates in-file (a BEAM file created in the current directory) a module 
sharing bijectively the specified entries by exporting suitably-generated 
get_{first,second}_for/1 functions ('strict' look-up) in order to access 
either element of the recorded pairs.</p>

 <p>For a clearer setting, generated modules may be named as such 
(e.g. 'foobar_generated').</p>

 <p>The resulting module is not loaded by this function.</p>

 Returns the generated filename (not path), for any further reference.
</p>

<h3 class="function"><a name="generate_in_file-3">generate_in_file/3</a></h3>
<div class="spec">
<p><tt>generate_in_file(ModuleName::<a href="#type-module_name">module_name()</a>, Entries::<a href="#type-entries">entries()</a>, ElementLookup::<a href="#type-element_lookup">element_lookup()</a>) -&gt; <a href="#type-file_name">file_name()</a></tt><br></p>
<p> </p>
</div><p><p>Generates in-file (a BEAM file created in the current directory) a module 
sharing bijectively the specified entries by exporting suitably-generated 
functions in order to access either element of the recorded pairs.</p>

 <p>If the 'strict' element look-up is selected, the get_{first,second}_for/1 
functions will be available.</p>

 <p>If the 'maybe' element look-up is selected, additionally to the 'strict' case 
the get_maybe_{first,second}_for/1 functions will be available. Selecting that 
'maybe' element look-up is not recommended if either of the first and second 
sets contains the 'undefined' atom, as it leads to ambiguity.</p>

 <p>For a clearer setting, generated modules may be named as such 
(e.g. 'foobar_generated').</p>

 <p>The resulting module is not loaded by this function.</p>

 Returns the generated filename (not path), for any further reference.
</p>

<h3 class="function"><a name="generate_in_file-4">generate_in_file/4</a></h3>
<div class="spec">
<p><tt>generate_in_file(ModuleName::<a href="#type-module_name">module_name()</a>, Entries::<a href="#type-entries">entries()</a>, ElementLookup::<a href="#type-element_lookup">element_lookup()</a>, TargetDir::<a href="#type-any_directory_path">any_directory_path()</a>) -&gt; <a href="#type-file_name">file_name()</a></tt><br></p>
<p> </p>
</div><p><p>Generates in-file (a BEAM file created in the specified directory) a 
module sharing bijectively the specified entries by exporting 
suitably-generated functions in order to access either element of the recorded 
pairs.</p>

 <p>If the 'strict' element look-up is selected, the get_{first,second}_for/1 
functions will be available.</p>

 <p>If the 'maybe' element look-up is selected, additionally to the 'strict' case 
the get_maybe_{first,second}_for/1 functions will be available. Selecting that 
'maybe' element look-up is not recommended if either of the first and second 
sets contains the 'undefined' atom, as it leads to ambiguity.</p>

 <p>For a clearer setting, generated modules may be named as such 
(e.g. 'foobar_generated').</p>

 <p>The resulting module is not loaded by this function.</p>

 Returns the generated filename (not path), for any further reference.
</p>

<h3 class="function"><a name="generate_in_memory-2">generate_in_memory/2</a></h3>
<div class="spec">
<p><tt>generate_in_memory(ModuleName::<a href="#type-module_name">module_name()</a>, Entries::<a href="#type-entries">entries()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Generates in memory (only) and loads a module sharing bijectively the 
specified entries by exporting suitably-generated get_{first,second}_for/1 
functions ('strict' look-up) in order to access either element of the recorded 
pairs.</p>

 Note that no actual module file is generated (ex: no 'foobar.beam'), the
 operation remains fully in-memory.
</p>

<h3 class="function"><a name="generate_in_memory-3">generate_in_memory/3</a></h3>
<div class="spec">
<p><tt>generate_in_memory(ModuleName::<a href="#type-module_name">module_name()</a>, Entries::<a href="#type-entries">entries()</a>, ElementLookup::<a href="#type-element_lookup">element_lookup()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Generates in memory (only) and loads a module sharing bijectively the 
specified entries by exporting suitably-generated functions in order to access 
either element of the recorded pairs.</p>

 <p>If the 'strict' element look-up is selected, the get_{first,second}_for/1 
functions will be available.</p>

 <p>If the 'maybe' element look-up is selected, additionally to the 'strict' case 
the get_maybe_{first,second}_for/1 functions will be available. Selecting that 
'maybe' element look-up is not recommended if either of the first and second 
sets contains the 'undefined' atom, as it leads to ambiguity.</p>

 Note that no actual module file is generated (ex: no 'foobar.beam'), the
 operation remains fully in-memory.
</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
