<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module net_utils</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module net_utils</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>Gathering of various convenient <b>network-related</b> facilities.


<h2><a name="description">Description</a></h2><p>Gathering of various convenient <b>network-related</b> facilities.</p>

 See net_utils_test.erl for the corresponding test.

<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-any_host_name">any_host_name()</a></h3>
<p><code>any_host_name() = <a href="#type-any_string">any_string()</a></code></p>


<h3 class="typedecl"><a name="type-any_string">any_string()</a></h3>
<p><code>any_string() = <a href="text_utils.html#type-any_string">text_utils:any_string()</a></code></p>


<h3 class="typedecl"><a name="type-atom_fqdn">atom_fqdn()</a></h3>
<p><code>atom_fqdn() = atom()</code></p>


<h3 class="typedecl"><a name="type-atom_host_name">atom_host_name()</a></h3>
<p><code>atom_host_name() = atom()</code></p>


<h3 class="typedecl"><a name="type-atom_node_name">atom_node_name()</a></h3>
<p><code>atom_node_name() = node()</code></p>
<p> We tend to favor atom-based node names (usual in Erlang) to string-based ones.</p>

<h3 class="typedecl"><a name="type-bin_domain_name">bin_domain_name()</a></h3>
<p><code>bin_domain_name() = <a href="#type-bin_string">bin_string()</a></code></p>


<h3 class="typedecl"><a name="type-bin_fqdn">bin_fqdn()</a></h3>
<p><code>bin_fqdn() = <a href="#type-bin_string">bin_string()</a></code></p>


<h3 class="typedecl"><a name="type-bin_host_name">bin_host_name()</a></h3>
<p><code>bin_host_name() = <a href="#type-bin_string">bin_string()</a></code></p>


<h3 class="typedecl"><a name="type-bin_node_name">bin_node_name()</a></h3>
<p><code>bin_node_name() = <a href="#type-bin_string">bin_string()</a></code></p>


<h3 class="typedecl"><a name="type-bin_string">bin_string()</a></h3>
<p><code>bin_string() = <a href="text_utils.html#type-bin_string">text_utils:bin_string()</a></code></p>


<h3 class="typedecl"><a name="type-bin_subdomain">bin_subdomain()</a></h3>
<p><code>bin_subdomain() = <a href="#type-bin_string">bin_string()</a></code></p>


<h3 class="typedecl"><a name="type-check_duration">check_duration()</a></h3>
<p><code>check_duration() = non_neg_integer()</code></p>


<h3 class="typedecl"><a name="type-check_node_timing">check_node_timing()</a></h3>
<p><code>check_node_timing() = <a href="#type-check_duration">check_duration()</a> | immediate | with_waiting</code></p>


<h3 class="typedecl"><a name="type-command">command()</a></h3>
<p><code>command() = <a href="system_utils.html#type-command">system_utils:command()</a></code></p>


<h3 class="typedecl"><a name="type-cookie">cookie()</a></h3>
<p><code>cookie() = atom()</code></p>


<h3 class="typedecl"><a name="type-count">count()</a></h3>
<p><code>count() = <a href="basic_utils.html#type-count">basic_utils:count()</a></code></p>


<h3 class="typedecl"><a name="type-directory_path">directory_path()</a></h3>
<p><code>directory_path() = <a href="file_utils.html#type-directory_path">file_utils:directory_path()</a></code></p>


<h3 class="typedecl"><a name="type-domain_name">domain_name()</a></h3>
<p><code>domain_name() = nonempty_string()</code></p>
<p> A domain name (e.g. "foo.baz.org").</p>

<h3 class="typedecl"><a name="type-environment">environment()</a></h3>
<p><code>environment() = <a href="system_utils.html#type-environment">system_utils:environment()</a></code></p>


<h3 class="typedecl"><a name="type-ephemeral_port">ephemeral_port()</a></h3>
<p><code>ephemeral_port() = <a href="#type-net_port">net_port()</a></code></p>
<p> The RFC 6056 says that the range for ephemeral ports should be 1024-65535.</p>

<h3 class="typedecl"><a name="type-erlang_naming_type">erlang_naming_type()</a></h3>
<p><code>erlang_naming_type() = shortnames | longnames</code></p>
<p> No standard definition of NameType found in net_kernel or elsewhere.</p>

<h3 class="typedecl"><a name="type-file_path">file_path()</a></h3>
<p><code>file_path() = <a href="file_utils.html#type-file_path">file_utils:file_path()</a></code></p>


<h3 class="typedecl"><a name="type-fqdn">fqdn()</a></h3>
<p><code>fqdn() = <a href="#type-atom_fqdn">atom_fqdn()</a> | <a href="#type-string_fqdn">string_fqdn()</a> | <a href="#type-bin_fqdn">bin_fqdn()</a></code></p>


<h3 class="typedecl"><a name="type-host_identifier">host_identifier()</a></h3>
<p><code>host_identifier() = <a href="#type-string_host_name">string_host_name()</a> | <a href="#type-ip_address">ip_address()</a></code></p>


<h3 class="typedecl"><a name="type-host_name">host_name()</a></h3>
<p><code>host_name() = <a href="#type-atom_host_name">atom_host_name()</a> | <a href="#type-string_host_name">string_host_name()</a> | <a href="#type-bin_host_name">bin_host_name()</a></code></p>


<h3 class="typedecl"><a name="type-ip_address">ip_address()</a></h3>
<p><code>ip_address() = <a href="#type-ip_v4_address">ip_v4_address()</a> | <a href="#type-ip_v6_address">ip_v6_address()</a></code></p>


<h3 class="typedecl"><a name="type-ip_v4_address">ip_v4_address()</a></h3>
<p><code>ip_v4_address() = {byte(), byte(), byte(), byte()}</code></p>


<h3 class="typedecl"><a name="type-ip_v6_address">ip_v6_address()</a></h3>
<p><code>ip_v6_address() = {byte(), byte(), byte(), byte(), byte(), byte()}</code></p>


<h3 class="typedecl"><a name="type-listening_socket">listening_socket()</a></h3>
<p><code>listening_socket() = <a href="http://www.erlang.org/edoc/doc/kernel/doc/socket.html#type-socket">socket:socket()</a></code></p>
<p> A (low-level, NIF-based) TCP/IP socket used to listen to incoming connections.</p>

<h3 class="typedecl"><a name="type-lookup_info">lookup_info()</a></h3>
<p><code>lookup_info() = {<a href="#type-lookup_tool">lookup_tool()</a>, <a href="file_utils.html#type-executable_path">file_utils:executable_path()</a>}</code></p>


<h3 class="typedecl"><a name="type-lookup_outcome">lookup_outcome()</a></h3>
<p><code>lookup_outcome() = <a href="#type-string_host_name">string_host_name()</a> | unknown_dns | no_dns_lookup_executable_found</code></p>


<h3 class="typedecl"><a name="type-lookup_tool">lookup_tool()</a></h3>
<p><code>lookup_tool() = dig | drill | host</code></p>


<h3 class="typedecl"><a name="type-milliseconds">milliseconds()</a></h3>
<p><code>milliseconds() = <a href="unit_utils.html#type-milliseconds">unit_utils:milliseconds()</a></code></p>


<h3 class="typedecl"><a name="type-net_port">net_port()</a></h3>
<p><code>net_port() = non_neg_integer()</code></p>
<p> A port number is a 16-bit unsigned integer, thus ranging from 0 to 65535. For
 TCP, port number 0 is reserved and cannot be used, while for UDP, the source
 port is optional and a value of zero means no port.</p>

<h3 class="typedecl"><a name="type-node_name">node_name()</a></h3>
<p><code>node_name() = <a href="#type-atom_node_name">atom_node_name()</a> | <a href="#type-string_node_name">string_node_name()</a> | <a href="#type-bin_node_name">bin_node_name()</a></code></p>


<h3 class="typedecl"><a name="type-node_naming_mode">node_naming_mode()</a></h3>
<p><code>node_naming_mode() = long_name | short_name</code></p>
<p> How Erlang nodes are to be named to locate each other, according to our
 conventions.</p>

<h3 class="typedecl"><a name="type-node_type">node_type()</a></h3>
<p><code>node_type() = visible | hidden | all</code></p>
<p> See net_kernel:monitor_nodes/2 for more information.</p>

<h3 class="typedecl"><a name="type-possibly_local_bin_hostname">possibly_local_bin_hostname()</a></h3>
<p><code>possibly_local_bin_hostname() = localhost | <a href="#type-bin_host_name">bin_host_name()</a></code></p>
<p> For situations where the local host shall be discriminated from all others.</p>

<h3 class="typedecl"><a name="type-possibly_local_hostname">possibly_local_hostname()</a></h3>
<p><code>possibly_local_hostname() = localhost | <a href="#type-string_host_name">string_host_name()</a></code></p>
<p> For situations where the local host shall be discriminated from all others.</p>

<h3 class="typedecl"><a name="type-string_fqdn">string_fqdn()</a></h3>
<p><code>string_fqdn() = nonempty_string()</code></p>


<h3 class="typedecl"><a name="type-string_host_name">string_host_name()</a></h3>
<p><code>string_host_name() = nonempty_string()</code></p>


<h3 class="typedecl"><a name="type-string_node_name">string_node_name()</a></h3>
<p><code>string_node_name() = nonempty_string()</code></p>


<h3 class="typedecl"><a name="type-subdomain">subdomain()</a></h3>
<p><code>subdomain() = nonempty_string()</code></p>
<p> An element of a domain name (e.g. "foo" in "bar.foo.baz.org").</p>

<h3 class="typedecl"><a name="type-tcp_port">tcp_port()</a></h3>
<p><code>tcp_port() = <a href="#type-net_port">net_port()</a></code></p>


<h3 class="typedecl"><a name="type-tcp_port_range">tcp_port_range()</a></h3>
<p><code>tcp_port_range() = {<a href="#type-tcp_port">tcp_port()</a>, <a href="#type-tcp_port">tcp_port()</a>}</code></p>


<h3 class="typedecl"><a name="type-tcp_port_restriction">tcp_port_restriction()</a></h3>
<p><code>tcp_port_restriction() = no_restriction | <a href="#type-tcp_port_range">tcp_port_range()</a></code></p>


<h3 class="typedecl"><a name="type-time_out">time_out()</a></h3>
<p><code>time_out() = <a href="time_utils.html#type-time_out">time_utils:time_out()</a></code></p>


<h3 class="typedecl"><a name="type-udp_port">udp_port()</a></h3>
<p><code>udp_port() = <a href="#type-net_port">net_port()</a></code></p>


<h3 class="typedecl"><a name="type-udp_port_range">udp_port_range()</a></h3>
<p><code>udp_port_range() = {<a href="#type-udp_port">udp_port()</a>, <a href="#type-udp_port">udp_port()</a>}</code></p>


<h3 class="typedecl"><a name="type-ustring">ustring()</a></h3>
<p><code>ustring() = <a href="text_utils.html#type-ustring">text_utils:ustring()</a></code></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#bin_localhost-0">bin_localhost/0</a></td><td>Returns an appropriate DNS name for the local host (as a binary string), 
or throws an exception.</td></tr>
<tr><td valign="top"><a href="#bin_localhost-1">bin_localhost/1</a></td><td>Returns an appropriate DNS name (either a FQDN - Fully Qualified Domain
 Name - or a short host name) for the local host (as a binary string), or
 throws an exception.</td></tr>
<tr><td valign="top"><a href="#check_ephemeral_port-1">check_ephemeral_port/1</a></td><td>Checks that the specified port is a valid ephemeral port (typically UDP
 or TCP), and returns it.</td></tr>
<tr><td valign="top"><a href="#check_node_availability-1">check_node_availability/1</a></td><td>Returns immediately whether the specified Erlang node is found available.</td></tr>
<tr><td valign="top"><a href="#check_node_availability-2">check_node_availability/2</a></td><td>Tells whether the specified Erlang node is available: returns 
{IsAvailable,Duration} where IsAvailable is a boolean and Duration is the 
number of milliseconds that was used to determine it.</td></tr>
<tr><td valign="top"><a href="#check_port-1">check_port/1</a></td><td>Checks that the specified port is a valid port (typically UDP or TCP),
 and returns it.</td></tr>
<tr><td valign="top"><a href="#enable_distribution_mode-2">enable_distribution_mode/2</a></td><td>Enables the distribution on the current node, supposedly not already 
distributed (otherwise the operation will fail).</td></tr>
<tr><td valign="top"><a href="#enable_preferred_distribution_mode-2">enable_preferred_distribution_mode/2</a></td><td>Returns the distribution naming mode that could be enabled (if any) on 
the current node, based on the mode(s) that were specified in decreasing order 
of interest, or returns an error.</td></tr>
<tr><td valign="top"><a href="#generate_valid_node_name_from-1">generate_valid_node_name_from/1</a></td><td>Returns a name (as a string) that is a legal name for an Erlang node,
 forged from the specified name.</td></tr>
<tr><td valign="top"><a href="#get_all_connected_nodes-0">get_all_connected_nodes/0</a></td><td>Returns the list of all connected nodes (each being designated by an
 atom, like 'foo@bar.org'), including the local node.</td></tr>
<tr><td valign="top"><a href="#get_basic_node_launching_command-5">get_basic_node_launching_command/5</a></td><td>Returns a basic command line (as a plain string) and its related
 environment in order to launch an Erlang node (interpreter) with the specified
 settings.</td></tr>
<tr><td valign="top"><a href="#get_complete_node_name-1">get_complete_node_name/1</a></td><td>Returns the complete name of the specified node (as a string), which has 
to be used to target it from another node, with respect to the local hostname 
and node naming conventions.</td></tr>
<tr><td valign="top"><a href="#get_complete_node_name-3">get_complete_node_name/3</a></td><td>Returns the complete name of the specified node (as a string), which has 
to be used to target it from another node, with respect to the specified node 
naming conventions.</td></tr>
<tr><td valign="top"><a href="#get_cookie-0">get_cookie/0</a></td><td>Returns the Erlang cookie of the current node if that node is alive,
 otherwise the 'nocookie' atom.</td></tr>
<tr><td valign="top"><a href="#get_cookie_option-0">get_cookie_option/0</a></td><td>Returns the command-line option (a plain string) to be used to run a new
 Erlang node with the same cookie as the current node, whether or not it is
 alive.</td></tr>
<tr><td valign="top"><a href="#get_default_epmd_port-0">get_default_epmd_port/0</a></td><td>Returns the default Erlang-level EPMD TCP port (not necessarily the one
 being currently used, not necessarily the one in the default Myriad settings
 either; refer to the EPMD_PORT variable in myriad/GNUmakevars.inc).</td></tr>
<tr><td valign="top"><a href="#get_epmd_environment-1">get_epmd_environment/1</a></td><td>Returns the command-line option (a plain string) to be used to run a new 
Erlang node with the specified EPMD port specification, which can be either 
the 'undefined' atom or the TCP port number.</td></tr>
<tr><td valign="top"><a href="#get_hostname-1">get_hostname/1</a></td><td>Returns, from the specified arbitrary hostname (either a FQDN or just an 
hostname), the corresponding actual "atomic" hostname (that is with no domain 
involved), as a plain string.</td></tr>
<tr><td valign="top"><a href="#get_hostname_from_node_name-1">get_hostname_from_node_name/1</a></td><td>Returns the hostname (as a plain string) that corresponds to the
 specified node name (as an atom).</td></tr>
<tr><td valign="top"><a href="#get_local_ip_address-0">get_local_ip_address/0</a></td><td>Returns the "main" potentially usable non-local network interface on this
 host.</td></tr>
<tr><td valign="top"><a href="#get_local_ip_addresses-0">get_local_ip_addresses/0</a></td><td>Returns a list of the potentially usable non-local network interfaces on 
this host, trying to put in first position the "main" one, if any.</td></tr>
<tr><td valign="top"><a href="#get_naming_compliant_hostname-1">get_naming_compliant_hostname/1</a></td><td>Returns a transformed version (as a string) of the local hostname, so 
that it is compliant with the specified node naming convention.</td></tr>
<tr><td valign="top"><a href="#get_naming_compliant_hostname-2">get_naming_compliant_hostname/2</a></td><td>Returns a transformed version (as a string) of the specified FQDN 
hostname (itself specified as a string) so that it is compliant with the 
specified node naming convention.</td></tr>
<tr><td valign="top"><a href="#get_node_name_option-2">get_node_name_option/2</a></td><td>Returns the command-line option (a plain string) to be used to run a new
 Erlang node with the node name (specified as a string) and node naming mode
 (short or long name, specified thanks to atoms).</td></tr>
<tr><td valign="top"><a href="#get_node_naming_mode-0">get_node_naming_mode/0</a></td><td>Returns the naming mode of this node, either 'short_name' or 'long_name',
 provided that the current node is a distributed one.</td></tr>
<tr><td valign="top"><a href="#get_reverse_lookup_info-0">get_reverse_lookup_info/0</a></td><td>Returns information to perform a reverse DNS lookup.</td></tr>
<tr><td valign="top"><a href="#get_tcp_port_range_option-1">get_tcp_port_range_option/1</a></td><td>Returns the command-line option (a plain string) to be used to run a new 
Erlang node with the specified TCP port restriction, which can be either the 
'no_restriction' atom or a pair of integers {MinTCPPort,MaxTCPPort}.</td></tr>
<tr><td valign="top"><a href="#host_to_string-1">host_to_string/1</a></td><td>Returns a string describing the specified host.</td></tr>
<tr><td valign="top"><a href="#ipv4_to_string-1">ipv4_to_string/1</a></td><td>Returns a string describing the specified IPv4 address.</td></tr>
<tr><td valign="top"><a href="#ipv4_to_string-2">ipv4_to_string/2</a></td><td>Returns a string describing the specified IPv4 address and port.</td></tr>
<tr><td valign="top"><a href="#ipv6_to_string-1">ipv6_to_string/1</a></td><td>Returns a string describing the specified IPv6 address.</td></tr>
<tr><td valign="top"><a href="#ipv6_to_string-2">ipv6_to_string/2</a></td><td>Returns a string describing the specified IPv6 address and port.</td></tr>
<tr><td valign="top"><a href="#is_local_service_running_at-1">is_local_service_running_at/1</a></td><td>Tells whether a service (socket) is running on the local host at the
 specified TCP port.</td></tr>
<tr><td valign="top"><a href="#is_routable-1">is_routable/1</a></td><td>Tells whether the specified IPv4 address is routable.</td></tr>
<tr><td valign="top"><a href="#is_service_running_at-2">is_service_running_at/2</a></td><td>Tells whether a service (socket) is running on the specified host, at the
 specified TCP port, using a default time-out.</td></tr>
<tr><td valign="top"><a href="#is_service_running_at-3">is_service_running_at/3</a></td><td>Tells whether a service (socket) is running on the specified host, at the 
specified TCP port, based on the specified time-out.</td></tr>
<tr><td valign="top"><a href="#launch_epmd-0">launch_epmd/0</a></td><td>Launches as a daemon (in the background) an EPMD instance on the Erlang 
standard port, if needed.</td></tr>
<tr><td valign="top"><a href="#launch_epmd-1">launch_epmd/1</a></td><td>Launches as a daemon (in the background) an EPMD instance on the 
specified port, if needed.</td></tr>
<tr><td valign="top"><a href="#localhost-0">localhost/0</a></td><td>Returns an appropriate DNS name for the local host (as a plain string), 
or throws an exception.</td></tr>
<tr><td valign="top"><a href="#localhost-1">localhost/1</a></td><td>Returns an appropriate DNS name (either a FQDN - Fully Qualified Domain
 Name - or a short host name) for the local host (as a plain string), or throws
 an exception.</td></tr>
<tr><td valign="top"><a href="#localhost_for_node_name-0">localhost_for_node_name/0</a></td><td>Returns a hostname of the local host that is suitable to be included in a 
node name (in compliance with the current short/long name setting), assuming 
the current node is a distributed one.</td></tr>
<tr><td valign="top"><a href="#localnode-0">localnode/0</a></td><td>Returns the name of the local node, as an atom.</td></tr>
<tr><td valign="top"><a href="#localnode_as_binary-0">localnode_as_binary/0</a></td><td>Returns the name of the local node, as a binary string.</td></tr>
<tr><td valign="top"><a href="#ping-1">ping/1</a></td><td>Pings the specified hostname, and returns true iff it could be ping'd.</td></tr>
<tr><td valign="top"><a href="#receive_file-1">receive_file/1</a></td><td>Receives specified file out of band (through a dedicated TCP socket, not 
thanks to Erlang messages), the emitter being supposed to use send_file/2.</td></tr>
<tr><td valign="top"><a href="#receive_file-2">receive_file/2</a></td><td>Receives specified file out of band (through a dedicated TCP socket, not 
thanks to Erlang messages) into specified pre-existing directory, the emitter 
being supposed to use send_file/2.</td></tr>
<tr><td valign="top"><a href="#receive_file-3">receive_file/3</a></td><td>Receives specified file out of band (through a dedicated TCP socket, not 
thanks to Erlang messages) into specified pre-existing directory, the emitter 
being supposed to use send_file/2.</td></tr>
<tr><td valign="top"><a href="#receive_file-4">receive_file/4</a></td><td>Receives specified file out of band (through a dedicated TCP socket - not 
thanks to Erlang messages) into specified pre-existing directory, the emitter 
being supposed to use send_file/2.</td></tr>
<tr><td valign="top"><a href="#reverse_lookup-1">reverse_lookup/1</a></td><td>Returns a string telling the DNS name corresponding to the specified IPv4
 address {N1, N2, N3, N4}, or an atom describing why it failed.</td></tr>
<tr><td valign="top"><a href="#reverse_lookup-2">reverse_lookup/2</a></td><td>Returns a string telling the DNS name corresponding to the specified IPv4
 address {N1, N2, N3, N4}, or an atom describing why it failed.</td></tr>
<tr><td valign="top"><a href="#secure_distribution-1">secure_distribution/1</a></td><td>Tries to enable the distribution on the current node with the specified 
name, trying first to use long names, otherwise short names, doing its best to 
avoid that the operation fails; in case of success, returns the enabled naming 
mode, otherwise throws an exception.</td></tr>
<tr><td valign="top"><a href="#send_file-2">send_file/2</a></td><td>Sends the specified file (most probably over the network) to the 
specified recipient PID, supposed to have already called one of the 
receive_file/{1,2,3} functions.</td></tr>
<tr><td valign="top"><a href="#set_cookie-1">set_cookie/1</a></td><td>Sets the Erlang cookie for the current node, as well as for the one of
 all unknown nodes.</td></tr>
<tr><td valign="top"><a href="#set_cookie-2">set_cookie/2</a></td><td>Sets the Erlang cookie for the specified node.</td></tr>
<tr><td valign="top"><a href="#set_unique_node_name-0">set_unique_node_name/0</a></td><td>Sets the name of the current node, expected to be already a distributed 
one, to a name expected to be unique.</td></tr>
<tr><td valign="top"><a href="#shutdown_node-0">shutdown_node/0</a></td><td>Shutdowns current node, and never returns (unlike init:stop/0): it is a 
reliable and synchronous operation.</td></tr>
<tr><td valign="top"><a href="#shutdown_node-1">shutdown_node/1</a></td><td>Shutdowns specified node (specified as a string or an atom), and returns 
only when it cannot be ping'ed anymore: it is a reliable and synchronous 
operation.</td></tr>
<tr><td valign="top"><a href="#split_fqdn-1">split_fqdn/1</a></td><td>Returns, from the specified FQDN, the corresponding actual host and its 
full domain if possible, otherwise jsut 'none_found'.</td></tr>
<tr><td valign="top"><a href="#wait_unavailable-3">wait_unavailable/3</a></td><td>Waits until specified node is unavailable, for the specified number of
 attempts between which the specified duration will be waited .</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="bin_localhost-0">bin_localhost/0</a></h3>
<div class="spec">
<p><code>bin_localhost() -&gt; <a href="#type-bin_host_name">bin_host_name()</a></code><br></p>
<p> </p>
</div><p><p>Returns an appropriate DNS name for the local host (as a binary string), 
or throws an exception.</p>

 Tries to collect a FQDN (Fully Qualified Domain Name).
</p>

<h3 class="function"><a name="bin_localhost-1">bin_localhost/1</a></h3>
<div class="spec">
<p><code>bin_localhost(Type::fqdn | short) -&gt; <a href="#type-bin_host_name">bin_host_name()</a></code><br></p>
<p> </p>
</div><p>Returns an appropriate DNS name (either a FQDN - Fully Qualified Domain
 Name - or a short host name) for the local host (as a binary string), or
 throws an exception.
</p>

<h3 class="function"><a name="check_ephemeral_port-1">check_ephemeral_port/1</a></h3>
<div class="spec">
<p><code>check_ephemeral_port(I::term()) -&gt; <a href="#type-ephemeral_port">ephemeral_port()</a></code><br></p>
<p> </p>
</div><p>Checks that the specified port is a valid ephemeral port (typically UDP
 or TCP), and returns it.
</p>

<h3 class="function"><a name="check_node_availability-1">check_node_availability/1</a></h3>
<div class="spec">
<p><code>check_node_availability(NodeName::<a href="#type-node_name">node_name()</a>) -&gt; boolean()</code><br></p>
<p> </p>
</div><p><p>Returns immediately whether the specified Erlang node is found available.</p>

 NodeName can be an atom or a string.
</p>

<h3 class="function"><a name="check_node_availability-2">check_node_availability/2</a></h3>
<div class="spec">
<p><code>check_node_availability(NodeName::<a href="#type-node_name">node_name()</a>, Timing::<a href="#type-check_node_timing">check_node_timing()</a>) -&gt; {boolean(), <a href="#type-check_duration">check_duration()</a>}</code><br></p>
<p> </p>
</div><p><p>Tells whether the specified Erlang node is available: returns 
{IsAvailable,Duration} where IsAvailable is a boolean and Duration is the 
number of milliseconds that was used to determine it.</p>

 <p>Parameters:</p>

 <p>- NodeName is an atom or a string corresponding to the name of the target node</p>

 <p>- Timing is either 'immediate', 'with_waiting' or a positive number of 
attempts with exponential back-off:</p>

   <p>- if 'immediate', the target node will be deemed available or not, as soon   
as the first and only ping attempted returns a result</p>

   <p>- if 'with_waiting', a fixed, default number of attempts with some   
exponential waiting in-between will be performed, for a standard duration</p>

   <p>- if it is an integer, it will be used as a duration, i.e. the number of   
milliseconds to be waited for, based on look-ups to be made with exponential   
waiting in-between until a threshold duration is reached; this checking   
should last no less than the specified duration, and not much more</p>

 This is useful so that, if the node is being launched in the background, it is
 waited for while returning as soon as possible.
</p>

<h3 class="function"><a name="check_port-1">check_port/1</a></h3>
<div class="spec">
<p><code>check_port(I::term()) -&gt; <a href="#type-net_port">net_port()</a></code><br></p>
<p> </p>
</div><p>Checks that the specified port is a valid port (typically UDP or TCP),
 and returns it.
</p>

<h3 class="function"><a name="enable_distribution_mode-2">enable_distribution_mode/2</a></h3>
<div class="spec">
<p><code>enable_distribution_mode(NodeName::<a href="#type-node_name">node_name()</a>, NamingMode::<a href="#type-node_naming_mode">node_naming_mode()</a>) -&gt; <a href="#type-void">void()</a></code><br></p>
<p> </p>
</div><p><p>Enables the distribution on the current node, supposedly not already 
distributed (otherwise the operation will fail).</p>

 <p>Note: an EPMD instance is expected to be already running; see 
launch_epmd/{0,1} in this module for that; apparently no race condition 
happens, hence initially no need for a wait-and-retry mechanism was seen here.</p>

 <p>Otherwise following messages might be output:  
- 'Protocol: "inet_tcp": register/listen error: econnrefused'  
- '{distribution_enabling_failed,foobar,long_name,{{shutdown,         
{failed_to_start_child,net_kernel,{'EXIT',nodistribution}}},...</p>

 <p>In some cases yet (first time an Erlang program is run after boot?), a 
distribution_enabling_failed exception is raised, like in:</p>

 <p>{"init terminating in do_boot",{{nocatch,{distribution_enabling_failed, 
'A_NODE_NAME',long_name,{{{shutdown,{failed_to_start_child,net_kernel, 
{'EXIT',nodistribution}}},{child,undefined,net_sup_dynamic, 
{erl_distribution,start_link,[['A_NODE_NAME',longnames],false]},permanent, 
1000,supervisor,[erl_distribution]}},'nonode@nohost'}}},[...]</p>

 <p>This does not seem to be linked to a race condition with EPMD, as killing EPMD 
and re-running the program does not fail anymore.</p>

 So a (tiny) second-chance mechanism has been introduced.
</p>

<h3 class="function"><a name="enable_preferred_distribution_mode-2">enable_preferred_distribution_mode/2</a></h3>
<div class="spec">
<p><code>enable_preferred_distribution_mode(NodeName::<a href="#type-node_name">node_name()</a>, NamingModes::[<a href="#type-node_naming_mode">node_naming_mode()</a>]) -&gt; <a href="#type-fallible">fallible</a>(<a href="#type-node_naming_mode">node_naming_mode()</a>)</code><br></p>
<p> </p>
</div><p><p>Returns the distribution naming mode that could be enabled (if any) on 
the current node, based on the mode(s) that were specified in decreasing order 
of interest, or returns an error.</p>

 <p>The current node is supposedly not already distributed (otherwise the 
operation will fail).</p>

 See enable_distribution_mode/2 for more information.
</p>

<h3 class="function"><a name="generate_valid_node_name_from-1">generate_valid_node_name_from/1</a></h3>
<div class="spec">
<p><code>generate_valid_node_name_from(Name::iolist()) -&gt; <a href="#type-string_node_name">string_node_name()</a></code><br></p>
<p> </p>
</div><p>Returns a name (as a string) that is a legal name for an Erlang node,
 forged from the specified name.
</p>

<h3 class="function"><a name="get_all_connected_nodes-0">get_all_connected_nodes/0</a></h3>
<div class="spec">
<p><code>get_all_connected_nodes() -&gt; [<a href="#type-atom_node_name">atom_node_name()</a>]</code><br></p>
<p> </p>
</div><p>Returns the list of all connected nodes (each being designated by an
 atom, like 'foo@bar.org'), including the local node.
</p>

<h3 class="function"><a name="get_basic_node_launching_command-5">get_basic_node_launching_command/5</a></h3>
<div class="spec">
<p><code>get_basic_node_launching_command(NodeName::<a href="#type-node_name">node_name()</a>, NodeNamingMode::<a href="#type-node_naming_mode">node_naming_mode()</a>, EpmdSettings::<a href="#type-maybe">maybe</a>(<a href="#type-tcp_port">tcp_port()</a>), TCPSettings::no_restriction | <a href="#type-tcp_port_range">tcp_port_range()</a>, AdditionalOptions::<a href="#type-ustring">ustring()</a>) -&gt; {<a href="#type-command">command()</a>, <a href="#type-environment">environment()</a>}</code><br></p>
<p> </p>
</div><p>Returns a basic command line (as a plain string) and its related
 environment in order to launch an Erlang node (interpreter) with the specified
 settings.
</p>

<h3 class="function"><a name="get_complete_node_name-1">get_complete_node_name/1</a></h3>
<div class="spec">
<p><code>get_complete_node_name(NodeName::<a href="#type-string_node_name">string_node_name()</a>) -&gt; <a href="#type-atom_node_name">atom_node_name()</a></code><br></p>
<p> </p>
</div><p><p>Returns the complete name of the specified node (as a string), which has 
to be used to target it from another node, with respect to the local hostname 
and node naming conventions.</p>

 For example for a node name "foo", the local hostname may be determined as
 "bar.org", and with short names, we may specify "foo@bar" to target the
 corresponding node with these conventions (neither with a mere "foo" nor with
 "foo@bar.org").
</p>

<h3 class="function"><a name="get_complete_node_name-3">get_complete_node_name/3</a></h3>
<div class="spec">
<p><code>get_complete_node_name(NodeName::<a href="#type-string_node_name">string_node_name()</a>, Hostname::<a href="#type-string_host_name">string_host_name()</a>, NodeNamingMode::<a href="#type-node_naming_mode">node_naming_mode()</a>) -&gt; <a href="#type-atom_node_name">atom_node_name()</a></code><br></p>
<p> </p>
</div><p><p>Returns the complete name of the specified node (as a string), which has 
to be used to target it from another node, with respect to the specified node 
naming conventions.</p>

 For example for a node name "foo", a hostname "bar.org", with short names, we
 may specify "foo@bar" to target the corresponding node with these conventions
 (not a mere "foo", neither "foo@bar.org").
</p>

<h3 class="function"><a name="get_cookie-0">get_cookie/0</a></h3>
<div class="spec">
<p><code>get_cookie() -&gt; <a href="#type-cookie">cookie()</a> | nocookie</code><br></p>
<p> </p>
</div><p>Returns the Erlang cookie of the current node if that node is alive,
 otherwise the 'nocookie' atom.
</p>

<h3 class="function"><a name="get_cookie_option-0">get_cookie_option/0</a></h3>
<div class="spec">
<p><code>get_cookie_option() -&gt; <a href="#type-ustring">ustring()</a></code><br></p>
<p> </p>
</div><p>Returns the command-line option (a plain string) to be used to run a new
 Erlang node with the same cookie as the current node, whether or not it is
 alive.
</p>

<h3 class="function"><a name="get_default_epmd_port-0">get_default_epmd_port/0</a></h3>
<div class="spec">
<p><code>get_default_epmd_port() -&gt; <a href="#type-tcp_port">tcp_port()</a></code><br></p>
<p> </p>
</div><p>Returns the default Erlang-level EPMD TCP port (not necessarily the one
 being currently used, not necessarily the one in the default Myriad settings
 either; refer to the EPMD_PORT variable in myriad/GNUmakevars.inc).
</p>

<h3 class="function"><a name="get_epmd_environment-1">get_epmd_environment/1</a></h3>
<div class="spec">
<p><code>get_epmd_environment(EpmdPort::<a href="#type-maybe">maybe</a>(<a href="#type-tcp_port">tcp_port()</a>)) -&gt; <a href="#type-environment">environment()</a></code><br></p>
<p> </p>
</div><p><p>Returns the command-line option (a plain string) to be used to run a new 
Erlang node with the specified EPMD port specification, which can be either 
the 'undefined' atom or the TCP port number.</p>

 Note that if a non-default EPMD port is specified for a new node, this implies
 that the current node usually has to itself respect the same non-standard
 convention (e.g. see the FIREWALL_OPT make option in myriad/GNUmakevars.inc),
 otherwise available nodes will not be found.
</p>

<h3 class="function"><a name="get_hostname-1">get_hostname/1</a></h3>
<div class="spec">
<p><code>get_hostname(AnyHostname::<a href="#type-any_host_name">any_host_name()</a>) -&gt; <a href="#type-string_host_name">string_host_name()</a></code><br></p>
<p> </p>
</div><p><p>Returns, from the specified arbitrary hostname (either a FQDN or just an 
hostname), the corresponding actual "atomic" hostname (that is with no domain 
involved), as a plain string.</p>

 For example "garfield" = get_hostname("garfield.baz.foobar.org")
                = get_hostname("garfield").
</p>

<h3 class="function"><a name="get_hostname_from_node_name-1">get_hostname_from_node_name/1</a></h3>
<div class="spec">
<p><code>get_hostname_from_node_name(NodeName::<a href="#type-atom_node_name">atom_node_name()</a>) -&gt; <a href="#type-string_host_name">string_host_name()</a></code><br></p>
<p> </p>
</div><p>Returns the hostname (as a plain string) that corresponds to the
 specified node name (as an atom).
</p>

<h3 class="function"><a name="get_local_ip_address-0">get_local_ip_address/0</a></h3>
<div class="spec">
<p><code>get_local_ip_address() -&gt; <a href="#type-ip_v4_address">ip_v4_address()</a></code><br></p>
<p> </p>
</div><p>Returns the "main" potentially usable non-local network interface on this
 host.
</p>

<h3 class="function"><a name="get_local_ip_addresses-0">get_local_ip_addresses/0</a></h3>
<div class="spec">
<p><code>get_local_ip_addresses() -&gt; [<a href="#type-ip_v4_address">ip_v4_address()</a>]</code><br></p>
<p> </p>
</div><p><p>Returns a list of the potentially usable non-local network interfaces on 
this host, trying to put in first position the "main" one, if any.</p>

 Note: IPv6 support should be added.
</p>

<h3 class="function"><a name="get_naming_compliant_hostname-1">get_naming_compliant_hostname/1</a></h3>
<div class="spec">
<p><code>get_naming_compliant_hostname(NamingMode::<a href="#type-node_naming_mode">node_naming_mode()</a>) -&gt; <a href="#type-string_host_name">string_host_name()</a></code><br></p>
<p> </p>
</div><p><p>Returns a transformed version (as a string) of the local hostname, so 
that it is compliant with the specified node naming convention.</p>

 For example, if the short_name convention is specified, then a "bar.baz.org"
 local hostname will result into "bar".
</p>

<h3 class="function"><a name="get_naming_compliant_hostname-2">get_naming_compliant_hostname/2</a></h3>
<div class="spec">
<p><code>get_naming_compliant_hostname(Hostname::<a href="#type-string_host_name">string_host_name()</a>, NamingMode::<a href="#type-node_naming_mode">node_naming_mode()</a>) -&gt; <a href="#type-string_host_name">string_host_name()</a></code><br></p>
<p> </p>
</div><p><p>Returns a transformed version (as a string) of the specified FQDN 
hostname (itself specified as a string) so that it is compliant with the 
specified node naming convention.</p>

 For example, if the short_name convention is specified, then a "bar.baz.org"
 hostname will result into "bar".
</p>

<h3 class="function"><a name="get_node_name_option-2">get_node_name_option/2</a></h3>
<div class="spec">
<p><code>get_node_name_option(NodeName::<a href="#type-string_node_name">string_node_name()</a>, NodeNamingMode::<a href="#type-node_naming_mode">node_naming_mode()</a>) -&gt; <a href="#type-ustring">ustring()</a></code><br></p>
<p> </p>
</div><p>Returns the command-line option (a plain string) to be used to run a new
 Erlang node with the node name (specified as a string) and node naming mode
 (short or long name, specified thanks to atoms).
</p>

<h3 class="function"><a name="get_node_naming_mode-0">get_node_naming_mode/0</a></h3>
<div class="spec">
<p><code>get_node_naming_mode() -&gt; <a href="#type-maybe">maybe</a>(<a href="#type-node_naming_mode">node_naming_mode()</a>)</code><br></p>
<p> </p>
</div><p>Returns the naming mode of this node, either 'short_name' or 'long_name',
 provided that the current node is a distributed one.
</p>

<h3 class="function"><a name="get_reverse_lookup_info-0">get_reverse_lookup_info/0</a></h3>
<div class="spec">
<p><code>get_reverse_lookup_info() -&gt; <a href="#type-maybe">maybe</a>(<a href="#type-lookup_info">lookup_info()</a>)</code><br></p>
<p> </p>
</div><p>Returns information to perform a reverse DNS lookup.</p>

<h3 class="function"><a name="get_tcp_port_range_option-1">get_tcp_port_range_option/1</a></h3>
<div class="spec">
<p><code>get_tcp_port_range_option(X1::no_restriction | <a href="#type-tcp_port_range">tcp_port_range()</a>) -&gt; <a href="#type-ustring">ustring()</a></code><br></p>
<p> </p>
</div><p><p>Returns the command-line option (a plain string) to be used to run a new 
Erlang node with the specified TCP port restriction, which can be either the 
'no_restriction' atom or a pair of integers {MinTCPPort,MaxTCPPort}.</p>

 If using a specific TCP/IP port range for a new node, the current node may
 have to respect this constraint as well (see the FIREWALL_OPT make option in
 myriad/GNUmakevars.inc), otherwise inter-node communication could fail.
</p>

<h3 class="function"><a name="host_to_string-1">host_to_string/1</a></h3>
<div class="spec">
<p><code>host_to_string(IPv4::<a href="#type-host_identifier">host_identifier()</a>) -&gt; <a href="#type-ustring">ustring()</a></code><br></p>
<p> </p>
</div><p>Returns a string describing the specified host.</p>

<h3 class="function"><a name="ipv4_to_string-1">ipv4_to_string/1</a></h3>
<div class="spec">
<p><code>ipv4_to_string(X1::<a href="#type-ip_v4_address">ip_v4_address()</a>) -&gt; <a href="#type-ustring">ustring()</a></code><br></p>
<p> </p>
</div><p>Returns a string describing the specified IPv4 address.</p>

<h3 class="function"><a name="ipv4_to_string-2">ipv4_to_string/2</a></h3>
<div class="spec">
<p><code>ipv4_to_string(X1::<a href="#type-ip_v4_address">ip_v4_address()</a>, Port::<a href="#type-net_port">net_port()</a>) -&gt; <a href="#type-ustring">ustring()</a></code><br></p>
<p> </p>
</div><p>Returns a string describing the specified IPv4 address and port.</p>

<h3 class="function"><a name="ipv6_to_string-1">ipv6_to_string/1</a></h3>
<div class="spec">
<p><code>ipv6_to_string(X1::<a href="#type-ip_v6_address">ip_v6_address()</a>) -&gt; <a href="#type-ustring">ustring()</a></code><br></p>
<p> </p>
</div><p>Returns a string describing the specified IPv6 address.</p>

<h3 class="function"><a name="ipv6_to_string-2">ipv6_to_string/2</a></h3>
<div class="spec">
<p><code>ipv6_to_string(Ipv6::<a href="#type-ip_v6_address">ip_v6_address()</a>, Port::<a href="#type-net_port">net_port()</a>) -&gt; <a href="#type-ustring">ustring()</a></code><br></p>
<p> </p>
</div><p>Returns a string describing the specified IPv6 address and port.</p>

<h3 class="function"><a name="is_local_service_running_at-1">is_local_service_running_at/1</a></h3>
<div class="spec">
<p><code>is_local_service_running_at(TCPPort::<a href="#type-tcp_port">tcp_port()</a>) -&gt; boolean()</code><br></p>
<p> </p>
</div><p>Tells whether a service (socket) is running on the local host at the
 specified TCP port.
</p>

<h3 class="function"><a name="is_routable-1">is_routable/1</a></h3>
<div class="spec">
<p><code>is_routable(X1::<a href="#type-ip_v4_address">ip_v4_address()</a>) -&gt; boolean()</code><br></p>
<p> </p>
</div><p><p>Tells whether the specified IPv4 address is routable.</p>

 Note: the loopback ({127,0,0,1}, or {0,0,0,0,0,0,0,1}) is deemed routable.
</p>

<h3 class="function"><a name="is_service_running_at-2">is_service_running_at/2</a></h3>
<div class="spec">
<p><code>is_service_running_at(TargetHostname::<a href="#type-any_host_name">any_host_name()</a>, TCPPort::<a href="#type-tcp_port">tcp_port()</a>) -&gt; boolean()</code><br></p>
<p> </p>
</div><p>Tells whether a service (socket) is running on the specified host, at the
 specified TCP port, using a default time-out.
</p>

<h3 class="function"><a name="is_service_running_at-3">is_service_running_at/3</a></h3>
<div class="spec">
<p><code>is_service_running_at(TargetHostname::<a href="#type-any_host_name">any_host_name()</a>, TCPPort::<a href="#type-tcp_port">tcp_port()</a>, Timeout::<a href="#type-time_out">time_out()</a>) -&gt; boolean()</code><br></p>
<p> </p>
</div><p><p>Tells whether a service (socket) is running on the specified host, at the 
specified TCP port, based on the specified time-out.</p>

 Not that null or even very short time-outs (e.g. 1 ms) may trigger
 econnrefused (and thus report that the service is not running) whereas a
 suitable service exists. According to our tests, a 10-millisecond timeout
 seems already reliable.
</p>

<h3 class="function"><a name="launch_epmd-0">launch_epmd/0</a></h3>
<div class="spec">
<p><code>launch_epmd() -&gt; <a href="#type-void">void()</a></code><br></p>
<p> </p>
</div><p><p>Launches as a daemon (in the background) an EPMD instance on the Erlang 
standard port, if needed.</p>

 If an EPMD instance is already launched for that port, no extra instance will
 be launched, the former one remaining the active one (possibly with different
 other settings); there is up to one EPMD instance per port.
</p>

<h3 class="function"><a name="launch_epmd-1">launch_epmd/1</a></h3>
<div class="spec">
<p><code>launch_epmd(Port::<a href="#type-net_port">net_port()</a>) -&gt; <a href="#type-void">void()</a></code><br></p>
<p> </p>
</div><p><p>Launches as a daemon (in the background) an EPMD instance on the 
specified port, if needed.</p>

 <p>If an EPMD instance is already launched for that port, no extra instance will 
be launched, the former one remaining the active one (possibly with different 
other settings); there is up to one EPMD instance per port.</p>

 The actual EPMD port configured for Myriad (refer to the EPMD_PORT make
 variable) does not seem to be easily available from an Erlang program.
</p>

<h3 class="function"><a name="localhost-0">localhost/0</a></h3>
<div class="spec">
<p><code>localhost() -&gt; <a href="#type-string_host_name">string_host_name()</a></code><br></p>
<p> </p>
</div><p><p>Returns an appropriate DNS name for the local host (as a plain string), 
or throws an exception.</p>

 Tries to collect a FQDN (Fully Qualified Domain Name).
</p>

<h3 class="function"><a name="localhost-1">localhost/1</a></h3>
<div class="spec">
<p><code>localhost(X1::fqdn | short) -&gt; <a href="#type-string_host_name">string_host_name()</a></code><br></p>
<p> </p>
</div><p>Returns an appropriate DNS name (either a FQDN - Fully Qualified Domain
 Name - or a short host name) for the local host (as a plain string), or throws
 an exception.
</p>

<h3 class="function"><a name="localhost_for_node_name-0">localhost_for_node_name/0</a></h3>
<div class="spec">
<p><code>localhost_for_node_name() -&gt; <a href="#type-string_host_name">string_host_name()</a></code><br></p>
<p> </p>
</div><p><p>Returns a hostname of the local host that is suitable to be included in a 
node name (in compliance with the current short/long name setting), assuming 
the current node is a distributed one.</p>

 We have had our deal of problems regarding systems whose local hostnames
 resolved in varied, sometimes variable, potentially unresolvable values.
</p>

<h3 class="function"><a name="localnode-0">localnode/0</a></h3>
<div class="spec">
<p><code>localnode() -&gt; <a href="#type-atom_node_name">atom_node_name()</a> | local_node</code><br></p>
<p> </p>
</div><p><p>Returns the name of the local node, as an atom.</p>

 It is either a specific node name, or the atom 'local_node' (preferred to
 'nonode@nohost') - which unfortunately are both atoms...
</p>

<h3 class="function"><a name="localnode_as_binary-0">localnode_as_binary/0</a></h3>
<div class="spec">
<p><code>localnode_as_binary() -&gt; <a href="#type-bin_node_name">bin_node_name()</a></code><br></p>
<p> </p>
</div><p><p>Returns the name of the local node, as a binary string.</p>

 It is either a specific node name, or <code>&lt;&lt;"local_node"&gt;&gt;</code>.
</p>

<h3 class="function"><a name="ping-1">ping/1</a></h3>
<div class="spec">
<p><code>ping(Hostname::<a href="#type-any_host_name">any_host_name()</a>) -&gt; boolean()</code><br></p>
<p> </p>
</div><p><p>Pings the specified hostname, and returns true iff it could be ping'd.</p>

 <p>Note: command-line based call, used that way as there is no Erlang ICMP stack.</p>

 A port could be used also.
</p>

<h3 class="function"><a name="receive_file-1">receive_file/1</a></h3>
<div class="spec">
<p><code>receive_file(EmitterPid::pid()) -&gt; <a href="#type-file_path">file_path()</a></code><br></p>
<p> </p>
</div><p><p>Receives specified file out of band (through a dedicated TCP socket, not 
thanks to Erlang messages), the emitter being supposed to use send_file/2.</p>

 <p>The file will be written in current directory, and the default TCP port will 
be used.</p>

 Returns the full path to the received file.
</p>

<h3 class="function"><a name="receive_file-2">receive_file/2</a></h3>
<div class="spec">
<p><code>receive_file(EmitterPid::pid(), TargetDir::<a href="#type-directory_path">directory_path()</a>) -&gt; <a href="#type-file_path">file_path()</a></code><br></p>
<p> </p>
</div><p><p>Receives specified file out of band (through a dedicated TCP socket, not 
thanks to Erlang messages) into specified pre-existing directory, the emitter 
being supposed to use send_file/2.</p>

 <p>The default TCP port will be used.</p>

 Returns the full path to the received file.
</p>

<h3 class="function"><a name="receive_file-3">receive_file/3</a></h3>
<div class="spec">
<p><code>receive_file(EmitterPid::pid(), TargetDir::<a href="#type-directory_path">directory_path()</a>, TCPPort::<a href="#type-tcp_port">tcp_port()</a>) -&gt; <a href="#type-file_path">file_path()</a></code><br></p>
<p> </p>
</div><p><p>Receives specified file out of band (through a dedicated TCP socket, not 
thanks to Erlang messages) into specified pre-existing directory, the emitter 
being supposed to use send_file/2.</p>

 The specified TCP port will be used for that.
</p>

<h3 class="function"><a name="receive_file-4">receive_file/4</a></h3>
<div class="spec">
<p><code>receive_file(EmitterPid::pid(), TargetDir::<a href="#type-directory_path">directory_path()</a>, MinTCPPort::<a href="#type-tcp_port">tcp_port()</a>, MaxTCPPort::<a href="#type-tcp_port">tcp_port()</a>) -&gt; <a href="#type-file_path">file_path()</a></code><br></p>
<p> </p>
</div><p><p>Receives specified file out of band (through a dedicated TCP socket - not 
thanks to Erlang messages) into specified pre-existing directory, the emitter 
being supposed to use send_file/2.</p>

 A TCP port in the specified range (min included, max excluded) will be used
 for that (useful to comply with some firewall rules).
</p>

<h3 class="function"><a name="reverse_lookup-1">reverse_lookup/1</a></h3>
<div class="spec">
<p><code>reverse_lookup(IPAddress::<a href="#type-ip_v4_address">ip_v4_address()</a>) -&gt; <a href="#type-lookup_outcome">lookup_outcome()</a></code><br></p>
<p> </p>
</div><p>Returns a string telling the DNS name corresponding to the specified IPv4
 address {N1, N2, N3, N4}, or an atom describing why it failed.
</p>

<h3 class="function"><a name="reverse_lookup-2">reverse_lookup/2</a></h3>
<div class="spec">
<p><code>reverse_lookup(IPAddress::<a href="#type-ip_v4_address">ip_v4_address()</a>, LookupInfo::<a href="#type-lookup_info">lookup_info()</a>) -&gt; <a href="#type-lookup_outcome">lookup_outcome()</a></code><br></p>
<p> </p>
</div><p>Returns a string telling the DNS name corresponding to the specified IPv4
 address {N1, N2, N3, N4}, or an atom describing why it failed.
</p>

<h3 class="function"><a name="secure_distribution-1">secure_distribution/1</a></h3>
<div class="spec">
<p><code>secure_distribution(NodeName::<a href="#type-node_name">node_name()</a>) -&gt; <a href="#type-node_naming_mode">node_naming_mode()</a></code><br></p>
<p> </p>
</div><p><p>Tries to enable the distribution on the current node with the specified 
name, trying first to use long names, otherwise short names, doing its best to 
avoid that the operation fails; in case of success, returns the enabled naming 
mode, otherwise throws an exception.</p>

 <p>Especially useful in the context of continuous integration and/or from within 
a container facility such as Docker or Singularity, where enabling the 
distribution of nodes may fail for varied reasons.</p>

 See enable_distribution_mode/2 for more details.
</p>

<h3 class="function"><a name="send_file-2">send_file/2</a></h3>
<div class="spec">
<p><code>send_file(FilePath::<a href="#type-file_path">file_path()</a>, RecipientPid::pid()) -&gt; <a href="#type-void">void()</a></code><br></p>
<p> </p>
</div><p><p>Sends the specified file (most probably over the network) to the 
specified recipient PID, supposed to have already called one of the 
receive_file/{1,2,3} functions.</p>

 The operation will be done filesystem-to-filesystem, hence no specific return
 is made.
</p>

<h3 class="function"><a name="set_cookie-1">set_cookie/1</a></h3>
<div class="spec">
<p><code>set_cookie(Cookie::<a href="#type-cookie">cookie()</a>) -&gt; <a href="#type-void">void()</a></code><br></p>
<p> </p>
</div><p>Sets the Erlang cookie for the current node, as well as for the one of
 all unknown nodes.
</p>

<h3 class="function"><a name="set_cookie-2">set_cookie/2</a></h3>
<div class="spec">
<p><code>set_cookie(Cookie::<a href="#type-cookie">cookie()</a>, Node::<a href="#type-atom_node_name">atom_node_name()</a>) -&gt; <a href="#type-void">void()</a></code><br></p>
<p> </p>
</div><p>Sets the Erlang cookie for the specified node.</p>

<h3 class="function"><a name="set_unique_node_name-0">set_unique_node_name/0</a></h3>
<div class="spec">
<p><code>set_unique_node_name() -&gt; <a href="#type-void">void()</a></code><br></p>
<p> </p>
</div><p><p>Sets the name of the current node, expected to be already a distributed 
one, to a name expected to be unique.</p>

 <p>Useful to allow multiple instances of a given application to run concurrently 
(otherwise beside the first, their node cannot be created).</p>

 Restarts the distribution node with long names - however it is generally *not*
 expected to succeed. Anyway an often better solution is not running a
 networked (distributed) node at the first place (see NODE_NAMING="--nn") and
 (iff needed) to execute enable_distribution_mode/2 afterwards.
</p>

<h3 class="function"><a name="shutdown_node-0">shutdown_node/0</a></h3>
<div class="spec">
<p><code>shutdown_node() -&gt; no_return()</code><br></p>
<p> </p>
</div><p><p>Shutdowns current node, and never returns (unlike init:stop/0): it is a 
reliable and synchronous operation.</p>

 Throws an exception if not able to terminate it.
</p>

<h3 class="function"><a name="shutdown_node-1">shutdown_node/1</a></h3>
<div class="spec">
<p><code>shutdown_node(NodeName::<a href="#type-node_name">node_name()</a>) -&gt; <a href="#type-void">void()</a></code><br></p>
<p> </p>
</div><p><p>Shutdowns specified node (specified as a string or an atom), and returns 
only when it cannot be ping'ed anymore: it is a reliable and synchronous 
operation.</p>

 Throws an exception if not able to terminate it.
</p>

<h3 class="function"><a name="split_fqdn-1">split_fqdn/1</a></h3>
<div class="spec">
<p><code>split_fqdn(FQDNStr::<a href="#type-string_fqdn">string_fqdn()</a>) -&gt; none_found | {<a href="#type-host_name">host_name()</a>, <a href="#type-domain_name">domain_name()</a>}</code><br></p>
<p> </p>
</div><p><p>Returns, from the specified FQDN, the corresponding actual host and its 
full domain if possible, otherwise jsut 'none_found'.</p>

 For example {"garfield", "baz.foobar.org"} =
 split_fqdn("garfield.baz.foobar.org")
</p>

<h3 class="function"><a name="wait_unavailable-3">wait_unavailable/3</a></h3>
<div class="spec">
<p><code>wait_unavailable(NodeName::<a href="#type-atom_node_name">atom_node_name()</a>, AttemptCount::<a href="#type-count">count()</a>, Duration::<a href="#type-milliseconds">milliseconds()</a>) -&gt; <a href="#type-void">void()</a></code><br></p>
<p> </p>
</div><p>Waits until specified node is unavailable, for the specified number of
 attempts between which the specified duration will be waited .
</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
