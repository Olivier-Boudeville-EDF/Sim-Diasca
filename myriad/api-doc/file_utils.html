<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module file_utils</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module file_utils</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>Gathering of various facilities regarding <b>files and other filesystem
 elements</b>.


<h2><a name="description">Description</a></h2><p>Gathering of various facilities regarding <b>files and other filesystem
 elements</b>.</p>

 See file_utils_test.erl for the corresponding test.

<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-abs_directory_path">abs_directory_path()</a></h3>
<p><tt>abs_directory_path() = <a href="#type-directory_path">directory_path()</a></tt></p>
<p> Sometimes useful.</p>

<h3 class="typedecl"><a name="type-any_app_info">any_app_info()</a></h3>
<p><tt>any_app_info() = <a href="app_facilities.html#type-any_app_info">app_facilities:any_app_info()</a></tt></p>


<h3 class="typedecl"><a name="type-any_device_path">any_device_path()</a></h3>
<p><tt>any_device_path() = <a href="#type-device_path">device_path()</a> | <a href="#type-bin_device_path">bin_device_path()</a></tt></p>
<p> Designates any type of path to a device (including its device name), e.g.
 "/dev/ttyUSB0".</p>

<h3 class="typedecl"><a name="type-any_directory_name">any_directory_name()</a></h3>
<p><tt>any_directory_name() = <a href="#type-directory_name">directory_name()</a> | <a href="#type-bin_directory_name">bin_directory_name()</a></tt></p>


<h3 class="typedecl"><a name="type-any_directory_path">any_directory_path()</a></h3>
<p><tt>any_directory_path() = <a href="#type-directory_path">directory_path()</a> | <a href="#type-bin_directory_path">bin_directory_path()</a></tt></p>


<h3 class="typedecl"><a name="type-any_executable_path">any_executable_path()</a></h3>
<p><tt>any_executable_path() = <a href="#type-executable_path">executable_path()</a> | <a href="#type-bin_executable_path">bin_executable_path()</a></tt></p>
<p> Any type of path to an executable.</p>

<h3 class="typedecl"><a name="type-any_file_name">any_file_name()</a></h3>
<p><tt>any_file_name() = <a href="#type-file_name">file_name()</a> | <a href="#type-bin_file_name">bin_file_name()</a></tt></p>
<p> Could also be the more general file:name_all().</p>

<h3 class="typedecl"><a name="type-any_file_path">any_file_path()</a></h3>
<p><tt>any_file_path() = <a href="#type-file_path">file_path()</a> | <a href="#type-bin_file_path">bin_file_path()</a></tt></p>


<h3 class="typedecl"><a name="type-any_link_path">any_link_path()</a></h3>
<p><tt>any_link_path() = <a href="#type-link_path">link_path()</a> | <a href="#type-bin_file_path">bin_file_path()</a></tt></p>
<p> Any type of path for a (symbolic) link.</p>

<h3 class="typedecl"><a name="type-any_path">any_path()</a></h3>
<p><tt>any_path() = <a href="#type-path">path()</a> | <a href="#type-bin_path">bin_path()</a></tt></p>
<p> We do not believe that atoms shall be legit paths.</p>

<h3 class="typedecl"><a name="type-any_path_element">any_path_element()</a></h3>
<p><tt>any_path_element() = <a href="#type-path_element">path_element()</a> | <a href="#type-bin_path_element">bin_path_element()</a></tt></p>
<p><p> Any (legit) type of a part of a path (e.g. <code>&lt;&lt;"local"&gt;&gt;</code> in 
"/usr/local/share"); preferably without whitespaces.</p>

 ".." / <code>&lt;&lt;".."&gt;&gt;</code> means the parent directory.</p>

<h3 class="typedecl"><a name="type-any_string">any_string()</a></h3>
<p><tt>any_string() = <a href="text_utils.html#type-any_string">text_utils:any_string()</a></tt></p>


<h3 class="typedecl"><a name="type-any_suffix">any_suffix()</a></h3>
<p><tt>any_suffix() = <a href="#type-any_string">any_string()</a></tt></p>
<p> The suffix (final part) in a path element (e.g. "share" in
 "/usr/local/share").</p>

<h3 class="typedecl"><a name="type-bin_device_path">bin_device_path()</a></h3>
<p><tt>bin_device_path() = <a href="#type-bin_path">bin_path()</a></tt></p>
<p> Designates a (binary) path to a device (including its device name), e.g.
 <code>"/dev/ttyUSB0"</code>.</p>

<h3 class="typedecl"><a name="type-bin_directory_name">bin_directory_name()</a></h3>
<p><tt>bin_directory_name() = <a href="#type-bin_string">bin_string()</a></tt></p>


<h3 class="typedecl"><a name="type-bin_directory_path">bin_directory_path()</a></h3>
<p><tt>bin_directory_path() = <a href="#type-bin_string">bin_string()</a></tt></p>


<h3 class="typedecl"><a name="type-bin_executable_path">bin_executable_path()</a></h3>
<p><tt>bin_executable_path() = <a href="#type-bin_file_path">bin_file_path()</a></tt></p>
<p> Designates a path to an executable, as a binary.</p>

<h3 class="typedecl"><a name="type-bin_file_name">bin_file_name()</a></h3>
<p><tt>bin_file_name() = <a href="#type-bin_string">bin_string()</a></tt></p>


<h3 class="typedecl"><a name="type-bin_file_path">bin_file_path()</a></h3>
<p><tt>bin_file_path() = <a href="#type-bin_string">bin_string()</a></tt></p>


<h3 class="typedecl"><a name="type-bin_link_path">bin_link_path()</a></h3>
<p><tt>bin_link_path() = <a href="#type-bin_file_path">bin_file_path()</a></tt></p>
<p> The (binary) path of a (symbolic) link.</p>

<h3 class="typedecl"><a name="type-bin_path">bin_path()</a></h3>
<p><tt>bin_path() = <a href="#type-bin_string">bin_string()</a></tt></p>


<h3 class="typedecl"><a name="type-bin_path_element">bin_path_element()</a></h3>
<p><tt>bin_path_element() = <a href="#type-bin_string">bin_string()</a></tt></p>
<p> A (legit) part of a path (e.g. <code>&lt;&lt;"local"&gt;&gt;</code> in "/usr/local/share");
 preferably without whitespaces.</p>

<h3 class="typedecl"><a name="type-bin_script_path">bin_script_path()</a></h3>
<p><tt>bin_script_path() = <a href="#type-bin_file_path">bin_file_path()</a></tt></p>
<p> Designates a path to an (executable) script, as a binary.</p>

<h3 class="typedecl"><a name="type-bin_string">bin_string()</a></h3>
<p><tt>bin_string() = <a href="text_utils.html#type-bin_string">text_utils:bin_string()</a></tt></p>


<h3 class="typedecl"><a name="type-compression_format">compression_format()</a></h3>
<p><tt>compression_format() = zip | bzip2 | xz</tt></p>
<p> The supported compression formats.</p>

<h3 class="typedecl"><a name="type-device_path">device_path()</a></h3>
<p><tt>device_path() = <a href="#type-path">path()</a></tt></p>
<p> Designates a path to a device (including its device name), e.g.
 "/dev/ttyUSB0".</p>

<h3 class="typedecl"><a name="type-directory_name">directory_name()</a></h3>
<p><tt>directory_name() = <a href="#type-path">path()</a></tt></p>


<h3 class="typedecl"><a name="type-directory_path">directory_path()</a></h3>
<p><tt>directory_path() = <a href="#type-path">path()</a></tt></p>


<h3 class="typedecl"><a name="type-dotted_extension">dotted_extension()</a></h3>
<p><tt>dotted_extension() = <a href="#type-ustring">ustring()</a></tt></p>
<p> A dot followed by the extension of a filename, either unitary (e.g. ".baz", in
 "foobar.baz.json") or composed (e.g. ".tar.gz" in "hello.tar.gz").</p>

<h3 class="typedecl"><a name="type-entry_type">entry_type()</a></h3>
<p><tt>entry_type() = device | directory | other | regular | symlink</tt></p>
<p> All known types of file entries.</p>

<h3 class="typedecl"><a name="type-executable_name">executable_name()</a></h3>
<p><tt>executable_name() = <a href="#type-file_name">file_name()</a></tt></p>
<p> Designates an executable, generally without a path (e.g. "foobar").</p>

<h3 class="typedecl"><a name="type-executable_path">executable_path()</a></h3>
<p><tt>executable_path() = <a href="#type-file_path">file_path()</a></tt></p>
<p> Designates a path to an executable; e.g. "../my_dir/other/run.exe").</p>

<h3 class="typedecl"><a name="type-extension">extension()</a></h3>
<p><tt>extension() = <a href="#type-ustring">ustring()</a></tt></p>
<p><p> An extension in a filename, either unitary (e.g. "baz", in "foobar.baz.json") 
or composed (e.g. "tar.gz" in "hello.tar.gz").</p>

 An extension by itself does not include the leading dot (e.g. "gz", not
 ".gz").</p>

<h3 class="typedecl"><a name="type-file">file()</a></h3>
<p><tt>file() = <a href="http://www.erlang.org/edoc/doc/kernel/doc/file.html#type-io_device">file:io_device()</a></tt></p>
<p> Corresponds to the handle to an open file (typically a file descriptor
 counterpart), but also, possibly, 'standard_io' (for standard output,
 descriptor 1), 'standard_error' (for standard error, descriptor 2), a
 registered name (as an atom), or any PID handling the I/O protocols.</p>

<h3 class="typedecl"><a name="type-file_info">file_info()</a></h3>
<p><tt>file_info() = #file_info{size = non_neg_integer() | undefined, type = device | directory | other | regular | symlink | undefined, access = read | write | read_write | none | undefined, atime = <a href="http://www.erlang.org/edoc/doc/kernel/doc/file.html#type-date_time">file:date_time()</a> | non_neg_integer() | undefined, mtime = <a href="http://www.erlang.org/edoc/doc/kernel/doc/file.html#type-date_time">file:date_time()</a> | non_neg_integer() | undefined, ctime = <a href="http://www.erlang.org/edoc/doc/kernel/doc/file.html#type-date_time">file:date_time()</a> | non_neg_integer() | undefined, mode = non_neg_integer() | undefined, links = non_neg_integer() | undefined, major_device = non_neg_integer() | undefined, minor_device = non_neg_integer() | undefined, inode = non_neg_integer() | undefined, uid = non_neg_integer() | undefined, gid = non_neg_integer() | undefined}</tt></p>


<h3 class="typedecl"><a name="type-file_name">file_name()</a></h3>
<p><tt>file_name() = <a href="#type-path">path()</a></tt></p>
<p> Designates a filename, generally without a path (e.g. "foobar.txt").</p>

<h3 class="typedecl"><a name="type-file_open_mode">file_open_mode()</a></h3>
<p><tt>file_open_mode() = tuple() | atom() | ram</tt></p>
<p><p> Relevant flags when opening a file (e.g. read, write, append, exclusive, raw, 
etc.).</p>

 <p>See <a href="http://erlang.org/doc/man/file.html#open-2" target="_top"><tt>http://erlang.org/doc/man/file.html#open-2</tt></a> for their detailed 
description.</p>

 (file:mode() not exported currently unfortunately, see
 lib/kernel/src/file.erl)</p>

<h3 class="typedecl"><a name="type-file_path">file_path()</a></h3>
<p><tt>file_path() = <a href="#type-path">path()</a></tt></p>
<p> Designates a path to a file (including its filename),
 e.g. "../my_dir/other/foobar.txt".</p>

<h3 class="typedecl"><a name="type-filename">filename()</a></h3>
<p><tt>filename() = <a href="#type-file_name">file_name()</a></tt></p>
<p> Just a convenience alias.</p>

<h3 class="typedecl"><a name="type-filename_radix">filename_radix()</a></h3>
<p><tt>filename_radix() = <a href="#type-ustring">ustring()</a></tt></p>
<p> The part of a filename before the dot of the first extension.
 For example the filename radix of "hello.tar.gz" is "hello".</p>

<h3 class="typedecl"><a name="type-filepath_radix">filepath_radix()</a></h3>
<p><tt>filepath_radix() = <a href="#type-ustring">ustring()</a></tt></p>
<p><p> The part of a file path before the dot of the first extension.</p>

 For example the filepath radix of "/home/bond/hello.tar.gz" is
 "/home/bond/hello".</p>

<h3 class="typedecl"><a name="type-format_string">format_string()</a></h3>
<p><tt>format_string() = <a href="text_utils.html#type-format_string">text_utils:format_string()</a></tt></p>


<h3 class="typedecl"><a name="type-format_values">format_values()</a></h3>
<p><tt>format_values() = <a href="#type-format_values">format_values()</a></tt></p>


<h3 class="typedecl"><a name="type-improper_encoding_action">improper_encoding_action()</a></h3>
<p><tt>improper_encoding_action() = throw | warn | ignore | include</tt></p>


<h3 class="typedecl"><a name="type-leaf_name">leaf_name()</a></h3>
<p><tt>leaf_name() = <a href="#type-path_element">path_element()</a></tt></p>
<p><p> A leaf name, i.e. the final element of a path (possibly a file or directory).</p>

 For example in 'aaa/bbb/ccc', 'aaa' is the root, and 'ccc' is the leaf.</p>

<h3 class="typedecl"><a name="type-link_name">link_name()</a></h3>
<p><tt>link_name() = <a href="#type-ustring">ustring()</a></tt></p>
<p> The name of a (symbolic) link.</p>

<h3 class="typedecl"><a name="type-link_path">link_path()</a></h3>
<p><tt>link_path() = <a href="#type-file_path">file_path()</a></tt></p>
<p> The path of a (symbolic) link.</p>

<h3 class="typedecl"><a name="type-parent_creation">parent_creation()</a></h3>
<p><tt>parent_creation() = create_no_parent | create_parents</tt></p>
<p> Tells whether parent directories shall be created.</p>

<h3 class="typedecl"><a name="type-path">path()</a></h3>
<p><tt>path() = <a href="#type-ustring">ustring()</a></tt></p>
<p> A path may designate either a file or a directory (in both case with leading,
 root directories possibly specified).</p>

<h3 class="typedecl"><a name="type-path_element">path_element()</a></h3>
<p><tt>path_element() = <a href="#type-ustring">ustring()</a></tt></p>
<p> A (legit) part of a path (e.g. "local" in "/usr/local/share"); preferably
 without whitespaces.</p>

<h3 class="typedecl"><a name="type-permission">permission()</a></h3>
<p><tt>permission() = owner_read | owner_write | owner_execute | group_read | group_write | group_execute | other_read | other_write | other_execute | set_user_id | set_group_id</tt></p>
<p> The various permissions that can be combined for file-like elements.</p>

<h3 class="typedecl"><a name="type-permission_mask">permission_mask()</a></h3>
<p><tt>permission_mask() = non_neg_integer()</tt></p>
<p> The binary mask corresponding to a filesystem permission.</p>

<h3 class="typedecl"><a name="type-possibly_resolvable_path">possibly_resolvable_path()</a></h3>
<p><tt>possibly_resolvable_path() = <a href="#type-resolvable_path">resolvable_path()</a> | <a href="#type-any_path">any_path()</a></tt></p>
<p> Any kind of path, resolvable or not.</p>

<h3 class="typedecl"><a name="type-resolvable_path">resolvable_path()</a></h3>
<p><tt>resolvable_path() = [<a href="#type-resolvable_path_element">resolvable_path_element()</a>]</tt></p>
<p><p> A path that is resolved at runtime, all its elements being joined accordingly.</p>

 <p>For example <code>[home, "Project", lang, &lt;&lt;"simulation"&gt;&gt;</code>, user] being translated 
to the "/home/bond/Project/en_GB.utf8/simulation/bond" path.</p>

 See resolve_path/1.</p>

<h3 class="typedecl"><a name="type-resolvable_path_element">resolvable_path_element()</a></h3>
<p><tt>resolvable_path_element() = <a href="#type-any_path">any_path()</a> | <a href="#type-resolvable_token_path">resolvable_token_path()</a></tt></p>
<p> An element of a resolvable path.</p>

<h3 class="typedecl"><a name="type-resolvable_token_path">resolvable_token_path()</a></h3>
<p><tt>resolvable_token_path() = user_name | user_id | group_name | group_id | home | locale_charset | fqdn | short_hostname</tt></p>


<h3 class="typedecl"><a name="type-script_path">script_path()</a></h3>
<p><tt>script_path() = <a href="#type-file_path">file_path()</a></tt></p>
<p> Designates a path to an (executable) script; e.g. "../my_dir/other/run.sh").</p>

<h3 class="typedecl"><a name="type-ustring">ustring()</a></h3>
<p><tt>ustring() = <a href="text_utils.html#type-ustring">text_utils:ustring()</a></tt></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#any_join-1">any_join/1</a></td><td>Joins the specified list of path elements; returns a corresponding binary 
string if at least one element is a binary string itself, otherwise returns a 
plain string.</td></tr>
<tr><td valign="top"><a href="#any_join-2">any_join/2</a></td><td>Joins the two specified path elements; returns a corresponding binary 
string if at least one element is a binary string itself, otherwise returns a 
plain string.</td></tr>
<tr><td valign="top"><a href="#append_file-2">append_file/2</a></td><td>Appends, at the end of the first specified file, the content of the
 second specified one: concatenates the second with the first one.</td></tr>
<tr><td valign="top"><a href="#bin_join-1">bin_join/1</a></td><td>Joins the specified list of path elements, returns a corresponding binary 
string.</td></tr>
<tr><td valign="top"><a href="#bin_join-2">bin_join/2</a></td><td>Joins the two specified path elements, returns a corresponding binary 
string.</td></tr>
<tr><td valign="top"><a href="#change_permissions-2">change_permissions/2</a></td><td>Changes the permissions ("chmod") of specified filesystem element.</td></tr>
<tr><td valign="top"><a href="#close-1">close/1</a></td><td>Closes the specified file reference.</td></tr>
<tr><td valign="top"><a href="#close-2">close/2</a></td><td>Closes the specified file reference.</td></tr>
<tr><td valign="top"><a href="#compress-1">compress/1</a></td><td>Compresses the specified file: creates a compressed version thereof 
(using the most efficient, compacity-wise, compression tool available), whose 
filename, established based on usual conventions, is returned.</td></tr>
<tr><td valign="top"><a href="#compress-2">compress/2</a></td><td>Compresses the specified file: creates a compressed version thereof, 
whose filename, established based on usual conventions, is returned.</td></tr>
<tr><td valign="top"><a href="#convert_to_filename-1">convert_to_filename/1</a></td><td>Converts the specified name into an acceptable filename, filesystem-wise.</td></tr>
<tr><td valign="top"><a href="#copy_as_regular_file_in-2">copy_as_regular_file_in/2</a></td><td>Copies the actual regular file specified - either directly a regular 
file, or a regular file ultimately pointed to by any specified symbolic link - 
in the specified destination directory, overwriting any previous file, and 
returning the full path of the copied file.</td></tr>
<tr><td valign="top"><a href="#copy_file-2">copy_file/2</a></td><td>Copies the specified file to a given destination filename (not a 
directory name, see copy_file_in/2 for that), overwriting any previous file.</td></tr>
<tr><td valign="top"><a href="#copy_file_if_existing-2">copy_file_if_existing/2</a></td><td>Copies the specified file to a given destination iff this source file is 
already existing.</td></tr>
<tr><td valign="top"><a href="#copy_file_in-2">copy_file_in/2</a></td><td>Copies the specified file in the specified destination directory, 
overwriting any previous file, and returning the full path of the copied file.</td></tr>
<tr><td valign="top"><a href="#copy_tree-2">copy_tree/2</a></td><td>Copies the specified source tree in specified target directory.</td></tr>
<tr><td valign="top"><a href="#create_directory-1">create_directory/1</a></td><td>Creates the specified directory ("mkdir"), without creating any 
intermediate (parent) directory that would not exist.</td></tr>
<tr><td valign="top"><a href="#create_directory-2">create_directory/2</a></td><td>Creates the specified directory.</td></tr>
<tr><td valign="top"><a href="#create_directory_if_not_existing-1">create_directory_if_not_existing/1</a></td><td>Creates the specified directory (but not any parent thereof), if not 
already existing.</td></tr>
<tr><td valign="top"><a href="#create_directory_if_not_existing-2">create_directory_if_not_existing/2</a></td><td>Creates the specified directory (and, if specified, any needed parent as 
well), if not already existing.</td></tr>
<tr><td valign="top"><a href="#create_empty_file-1">create_empty_file/1</a></td><td>Creates an empty file bearing the specified filename (other use of 
touch).</td></tr>
<tr><td valign="top"><a href="#create_link-2">create_link/2</a></td><td>Creates a symbolic link pointing to the specified target path, at the 
specified new (link) path.</td></tr>
<tr><td valign="top"><a href="#create_non_clashing_file-0">create_non_clashing_file/0</a></td><td>Creates on the filesystem a file whose path is guaranteed not to clash 
with any other.</td></tr>
<tr><td valign="top"><a href="#create_preserving-2">create_preserving/2</a></td><td>Opens for a creation from scratch the specified file with the specified
 options (the 'write' one being implied and automatically added here); if the
 target file already exists, renames it first by suffixing '.previous' to its
 name (then overwriting any identically-named file that would already exist),
 before performing the creation.</td></tr>
<tr><td valign="top"><a href="#create_preserving-3">create_preserving/3</a></td><td>Opens for a creation from scratch the specified file with the specified
 options (the 'write' one being implied and automatically added here); if the
 target file already exists, renames it first based on the specified suffix
 (then overwriting any identically-named file that would already exist), before
 performing the creation.</td></tr>
<tr><td valign="top"><a href="#create_temporary_directory-0">create_temporary_directory/0</a></td><td>Creates a non-previously existing temporary directory, and returns its 
full path.</td></tr>
<tr><td valign="top"><a href="#decompress-1">decompress/1</a></td><td>Decompresses the specified compressed file, expected to bear the 
extension corresponding to the implicit, most compact format: recreates the 
original, decompressed version thereof, whose filename, established based on 
usual conventions, is returned: the name of the input file without its 
extension.</td></tr>
<tr><td valign="top"><a href="#decompress-2">decompress/2</a></td><td>Decompresses the specified compressed file, expected to bear the 
extension corresponding to the specified format: recreates the original, 
decompressed version thereof, whose filename, established based on usual 
conventions, is returned: the name of the input file without its extension.</td></tr>
<tr><td valign="top"><a href="#ensure_path_is_absolute-1">ensure_path_is_absolute/1</a></td><td>Returns an absolute, normalised path corresponding to the specified path.</td></tr>
<tr><td valign="top"><a href="#ensure_path_is_absolute-2">ensure_path_is_absolute/2</a></td><td>Returns an absolute, normalised path corresponding to the specified 
target path, using base path as root directory (this must be an absolute path) 
if the target path is not absolute.</td></tr>
<tr><td valign="top"><a href="#escape_path-1">escape_path/1</a></td><td>Escapes specified path so that it can safely be included as a seralised 
(string) content.</td></tr>
<tr><td valign="top"><a href="#exists-1">exists/1</a></td><td>Tells whether specified file entry exists, regardless of its type.</td></tr>
<tr><td valign="top"><a href="#file_to_zipped_term-1">file_to_zipped_term/1</a></td><td>Reads in memory the file specified from its filename, zips the 
corresponding term, and returns it, as a compressed binary.</td></tr>
<tr><td valign="top"><a href="#files_to_zipped_term-1">files_to_zipped_term/1</a></td><td>Reads in memory the files specified from their filenames (as plain 
strings), zips the corresponding term, and returns it.</td></tr>
<tr><td valign="top"><a href="#files_to_zipped_term-2">files_to_zipped_term/2</a></td><td>Reads in memory the files specified from their filenames (as plain 
strings), assuming their path is relative to the specified base directory, 
zips the corresponding term, and returns it.</td></tr>
<tr><td valign="top"><a href="#filter_by_excluded_suffixes-2">filter_by_excluded_suffixes/2</a></td><td>Returns a list containing all paths in the specified list (in an
 unspecified order) that do not match any of the specified suffixes.</td></tr>
<tr><td valign="top"><a href="#filter_by_extension-2">filter_by_extension/2</a></td><td>Returns a list containing all elements of the Filenames list whose
 extension is the specified one (e.g.</td></tr>
<tr><td valign="top"><a href="#filter_by_extensions-2">filter_by_extensions/2</a></td><td>Returns a list containing all elements of Filenames list whose extension
 corresponds to one of the specified extensions (e.g.</td></tr>
<tr><td valign="top"><a href="#filter_by_included_suffixes-2">filter_by_included_suffixes/2</a></td><td>Returns a list containing all paths in the specified list (in an
 unspecified order) that match any of the specified suffixes.</td></tr>
<tr><td valign="top"><a href="#find_directories_from-1">find_directories_from/1</a></td><td>Returns a list of all directories found from the root, in the whole 
subtree (that is recursively).</td></tr>
<tr><td valign="top"><a href="#find_files_from-1">find_files_from/1</a></td><td>Returns a list of all files (regular ones and symlinks) found from the 
root, in the whole subtree (that is recursively).</td></tr>
<tr><td valign="top"><a href="#find_files_from-2">find_files_from/2</a></td><td>Returns a list of all files (regular ones and, if requested, symlinks) 
found from the root, in the whole subtree (that is recursively).</td></tr>
<tr><td valign="top"><a href="#find_files_from-3">find_files_from/3</a></td><td>Returns a list of all files (regular ones and, if requested, symlinks) 
found from the root, in the whole subtree (that is recursively).</td></tr>
<tr><td valign="top"><a href="#find_files_with_excluded_dirs-2">find_files_with_excluded_dirs/2</a></td><td>Returns a list of all files (regular ones and symlinks) found from the 
root, in the whole subtree (that is recursively), with specified directories 
excluded.</td></tr>
<tr><td valign="top"><a href="#find_files_with_excluded_dirs-3">find_files_with_excluded_dirs/3</a></td><td>Returns a list of all files (regular ones and, if requested, symlinks) 
found from the root, in the whole subtree (that is recursively), with 
specified directories excluded.</td></tr>
<tr><td valign="top"><a href="#find_files_with_excluded_dirs-4">find_files_with_excluded_dirs/4</a></td><td>Returns a list of all files (regular ones and, if requested, symlinks) 
found from the root, in the whole subtree (that is recursively), with 
specified directories excluded.</td></tr>
<tr><td valign="top"><a href="#find_files_with_excluded_dirs_and_suffixes-3">find_files_with_excluded_dirs_and_suffixes/3</a></td><td>Returns a list of all files (regular ones and symlinks) found from the 
root, in the whole subtree (that is recursively), with specified directories 
and suffixes excluded.</td></tr>
<tr><td valign="top"><a href="#find_files_with_excluded_suffixes-2">find_files_with_excluded_suffixes/2</a></td><td>Returns a list of all files (regular ones and symlinks) found from the 
root which do not match any of the specified suffixes, in the whole subtree 
(that is recursively).</td></tr>
<tr><td valign="top"><a href="#find_files_with_excluded_suffixes-3">find_files_with_excluded_suffixes/3</a></td><td>Returns a list of all files (regular ones and symlinks) found from the 
root which do not match any of the specified suffixes, in the whole subtree 
(that is recursively).</td></tr>
<tr><td valign="top"><a href="#find_files_with_extension_from-2">find_files_with_extension_from/2</a></td><td>Returns a list of all files (regular ones and symlinks) found from the 
root with specified extension, in the whole subtree (that is recursively).</td></tr>
<tr><td valign="top"><a href="#find_files_with_extension_from-3">find_files_with_extension_from/3</a></td><td>Returns a list of all files (regular ones and symlinks) found from the 
root with specified extension, in the whole subtree (that is recursively).</td></tr>
<tr><td valign="top"><a href="#find_links_from-1">find_links_from/1</a></td><td>Returns a list of all symlinks found from the root, in the whole subtree 
(that is recursively).</td></tr>
<tr><td valign="top"><a href="#find_links_from-2">find_links_from/2</a></td><td>Returns a list of all symlinks found from the root, in the whole subtree 
(that is recursively).</td></tr>
<tr><td valign="top"><a href="#find_regular_files_from-1">find_regular_files_from/1</a></td><td>Returns a list of all regular files (hence not including symlinks) found 
from the root, in the whole subtree (that is recursively).</td></tr>
<tr><td valign="top"><a href="#from_permission_mask-1">from_permission_mask/1</a></td><td>Decodes the specified permission mask into a list of the corresponding
 permissions.</td></tr>
<tr><td valign="top"><a href="#get_base_path-1">get_base_path/1</a></td><td>Returns the complete leading, "directory" part of specified path, 
that is the one with all its element but the last one.</td></tr>
<tr><td valign="top"><a href="#get_bin_current_directory-0">get_bin_current_directory/0</a></td><td>Returns the current directory, as a binary string.</td></tr>
<tr><td valign="top"><a href="#get_cache_directory-1">get_cache_directory/1</a></td><td>Returns the path location intended for the storage of transient data
 files that the specified application may perform on the local machine, that is
 any cache that it may use.</td></tr>
<tr><td valign="top"><a href="#get_configuration_directory-1">get_configuration_directory/1</a></td><td>Returns the path location intended for the storage of persistent
 configuration files that the specified application may perform on the local
 machine.</td></tr>
<tr><td valign="top"><a href="#get_current_directory-0">get_current_directory/0</a></td><td>Returns the current directory, as a plain string.</td></tr>
<tr><td valign="top"><a href="#get_data_directory-1">get_data_directory/1</a></td><td>Returns the path location intended for the storage of persistent data
 files that the specified application may perform on the local machine.</td></tr>
<tr><td valign="top"><a href="#get_default_encoding-0">get_default_encoding/0</a></td><td>Returns the default recommended encoding, for example when needing to 
open a file for writing.</td></tr>
<tr><td valign="top"><a href="#get_default_encoding_option-0">get_default_encoding_option/0</a></td><td>Returns the default recommended option encoding option, for example when 
needing to open a file for writing - should such an option be used.</td></tr>
<tr><td valign="top"><a href="#get_dotted_extension_for-1">get_dotted_extension_for/1</a></td><td>Returns the dotted file extension (e.g.</td></tr>
<tr><td valign="top"><a href="#get_extension-1">get_extension/1</a></td><td>Returns the (last) extension of the specified file path.</td></tr>
<tr><td valign="top"><a href="#get_extension_for-1">get_extension_for/1</a></td><td>Returns the file extension corresponding to filenames compressed with
 specified format.</td></tr>
<tr><td valign="top"><a href="#get_extensions-1">get_extensions/1</a></td><td>Returns the (ordered) extension(s) of the specified file path.</td></tr>
<tr><td valign="top"><a href="#get_extra_configuration_directories-1">get_extra_configuration_directories/1</a></td><td>Returns the extra path locations intended for the storage of persistent
 configuration files that the specified application may perform on the local
 machine.</td></tr>
<tr><td valign="top"><a href="#get_extra_data_directories-1">get_extra_data_directories/1</a></td><td>Returns the extra path locations intended for the storage of persistent
 data files that the specified application may perform on the local machine.</td></tr>
<tr><td valign="top"><a href="#get_first_existing_directory_in-1">get_first_existing_directory_in/1</a></td><td>Returns the first (if any) existing directory found in the specified 
list, or throws an exception if none is found.</td></tr>
<tr><td valign="top"><a href="#get_group_of-1">get_group_of/1</a></td><td>Returns the group identifier (gid) of the group of the specified file
 entry.</td></tr>
<tr><td valign="top"><a href="#get_image_extensions-0">get_image_extensions/0</a></td><td>Returns a list of the known file extensions that refer to image files.</td></tr>
<tr><td valign="top"><a href="#get_image_file_gif-1">get_image_file_gif/1</a></td><td>Returns the image path corresponding to the specified file.</td></tr>
<tr><td valign="top"><a href="#get_image_file_png-1">get_image_file_png/1</a></td><td>Returns the image path corresponding to the specified file.</td></tr>
<tr><td valign="top"><a href="#get_last_modification_time-1">get_last_modification_time/1</a></td><td>Returns the last time at which the content of specified file entry was 
modified (not counting attribute or permission changes), according to the 
filesystem.</td></tr>
<tr><td valign="top"><a href="#get_last_path_element-1">get_last_path_element/1</a></td><td>Returns the final, "file" part of specified path, that is its last 
element, as a one-element path, corresponding either to a file or a directory.</td></tr>
<tr><td valign="top"><a href="#get_log_directory-1">get_log_directory/1</a></td><td>Returns the path location intended for the storage of transient log files
 that the specified application may perform on the local machine.</td></tr>
<tr><td valign="top"><a href="#get_longest_common_path-1">get_longest_common_path/1</a></td><td>Returns a pair made of the longest path common to all specified directory 
paths, and the corresponding suffixes, that is an (unordered) list of the 
input paths (as binaries) once the common prefix elements have been removed.</td></tr>
<tr><td valign="top"><a href="#get_non_clashing_entry_name_from-1">get_non_clashing_entry_name_from/1</a></td><td>Returns a path deriving from the specified one (and of the same type) so 
that it is unique, meaning that it does not clash with any pre-existing entry.</td></tr>
<tr><td valign="top"><a href="#get_owner_of-1">get_owner_of/1</a></td><td>Returns the user identifier (uid) of the owner of the specified file
 entry.</td></tr>
<tr><td valign="top"><a href="#get_permissions_of-1">get_permissions_of/1</a></td><td>Returns the (UNIX) permissions associated to the specified filesystem
 entry.</td></tr>
<tr><td valign="top"><a href="#get_shortest_unique_ending_paths-2">get_shortest_unique_ending_paths/2</a></td><td>Returns a pair made of the shortest ending paths that allows to 
discriminate between the specified paths (expected to be of the same string 
type).</td></tr>
<tr><td valign="top"><a href="#get_size-1">get_size/1</a></td><td>Returns the size, in bytes, of the specified file.</td></tr>
<tr><td valign="top"><a href="#get_type_of-1">get_type_of/1</a></td><td>Returns the (direct) type of the specified file entry (hence may return 
'symlink' if the path of a symbolic link is specified).</td></tr>
<tr><td valign="top"><a href="#has_matching_suffix-2">has_matching_suffix/2</a></td><td>Tells whether specified path matches one of the specified suffixes.</td></tr>
<tr><td valign="top"><a href="#hide-1">hide/1</a></td><td>Hides the specified file: renames it to a conventionally-deriving name, 
to have it out of the way; throws an exception if the resulting file already 
exists.</td></tr>
<tr><td valign="top"><a href="#hide-2">hide/2</a></td><td>Hides the specified file: renames it based on the specified suffix, to 
have it out of the way; throws an exception if the resulting file already 
exists.</td></tr>
<tr><td valign="top"><a href="#hide_overwriting-1">hide_overwriting/1</a></td><td>Hides the specified file: renames it to a conventionally-deriving name, 
to have it out of the way; if the resulting file already exists, it is 
overwritten.</td></tr>
<tr><td valign="top"><a href="#hide_overwriting-2">hide_overwriting/2</a></td><td>Hides the specified file: renames it to a conventionally-deriving name, 
to have it out of the way; if the resulting file already exists, it is 
overwritten.</td></tr>
<tr><td valign="top"><a href="#is_absolute_path-1">is_absolute_path/1</a></td><td>Tells whether the specified path is an absolute one.</td></tr>
<tr><td valign="top"><a href="#is_directory-1">is_directory/1</a></td><td>Returns whether the specified path entry, supposedly existing, is a 
directory.</td></tr>
<tr><td valign="top"><a href="#is_existing_directory-1">is_existing_directory/1</a></td><td>Returns whether the specified path entry exists and is a directory.</td></tr>
<tr><td valign="top"><a href="#is_existing_directory_or_link-1">is_existing_directory_or_link/1</a></td><td>Returns whether the specified path entry exists and is a directory or a 
symbolic link.</td></tr>
<tr><td valign="top"><a href="#is_existing_file-1">is_existing_file/1</a></td><td>Returns whether the specified path entry exists and is a regular file.</td></tr>
<tr><td valign="top"><a href="#is_existing_file_or_link-1">is_existing_file_or_link/1</a></td><td>Returns whether the specified path entry exists and is either a regular 
file or a symbolic link.</td></tr>
<tr><td valign="top"><a href="#is_existing_link-1">is_existing_link/1</a></td><td>Returns whether the specified path entry exists and is a symbolic file.</td></tr>
<tr><td valign="top"><a href="#is_file-1">is_file/1</a></td><td>Returns whether the specified path entry, supposedly existing, is a 
regular file.</td></tr>
<tr><td valign="top"><a href="#is_file_reference-1">is_file_reference/1</a></td><td>Tells whether the specified term is a file reference (pseudo-guard).</td></tr>
<tr><td valign="top"><a href="#is_leaf_among-2">is_leaf_among/2</a></td><td>Tells whether specified basename (e.g.</td></tr>
<tr><td valign="top"><a href="#is_link-1">is_link/1</a></td><td>Returns whether the specified path entry, supposedly existing, is a 
symbolic file.</td></tr>
<tr><td valign="top"><a href="#is_owner_executable-1">is_owner_executable/1</a></td><td>Returns whether the specified path entry (can be either a regular file or 
a symbolic link) exists and is executable for its current owner - not telling 
anything about whether the current user can execute it.</td></tr>
<tr><td valign="top"><a href="#is_owner_readable-1">is_owner_readable/1</a></td><td>Returns whether the specified path entry (can be either a regular file or 
a symbolic link) exists and is readable for its current owner - not telling 
anything about whether the current user can read it.</td></tr>
<tr><td valign="top"><a href="#is_owner_writable-1">is_owner_writable/1</a></td><td>Returns whether the specified path entry (can be either a regular file or 
a symbolic link) exists and is writable for its current owner) - not telling 
anything about whether the current user can write it.</td></tr>
<tr><td valign="top"><a href="#is_user_executable-1">is_user_executable/1</a></td><td>Returns whether the specified path entry exists and is executable for the 
current user (can be either a regular file or a symbolic link).</td></tr>
<tr><td valign="top"><a href="#is_user_readable-1">is_user_readable/1</a></td><td>Returns whether the specified path entry (can be either a regular file or 
a symbolic link) exists and is readable for the current user .</td></tr>
<tr><td valign="top"><a href="#is_user_writable-1">is_user_writable/1</a></td><td>Returns whether the specified path entry (can be either a regular file or 
a symbolic link) exists and is writable for the current user.</td></tr>
<tr><td valign="top"><a href="#join-1">join/1</a></td><td>Joins the specified list of path elements.</td></tr>
<tr><td valign="top"><a href="#join-2">join/2</a></td><td>Joins the two specified path elements, returns a corresponding plain 
string.</td></tr>
<tr><td valign="top"><a href="#latin1_file_to_unicode-1">latin1_file_to_unicode/1</a></td><td>Converts in-place the specified file, whose current encoding is expected
 to be Latin1, to Unicode.</td></tr>
<tr><td valign="top"><a href="#list_dir_elements-1">list_dir_elements/1</a></td><td>Returns a tuple containing five lists corresponding to the per-type 
dispatching of all filesystem elements local to specified directory (hence not 
recursively traversed), namely: {RegularFiles, Symlinks, Directories, 
OtherFiles, Devices}.</td></tr>
<tr><td valign="top"><a href="#list_dir_elements-2">list_dir_elements/2</a></td><td>Returns a tuple containing five lists corresponding to the per-type 
dispatching of all filesystem elements local to specified directory (hence not 
recursively traversed), namely: {RegularFiles, Symlinks, Directories, 
OtherFiles, Devices}.</td></tr>
<tr><td valign="top"><a href="#list_permission_pairs-0">list_permission_pairs/0</a></td><td>Lists all known permission types, as {Perm,Mask} pairs.</td></tr>
<tr><td valign="top"><a href="#make_relative-1">make_relative/1</a></td><td>Returns a version of the specified path that is relative to the current
 directory; returns the same type (plain or binary string) as the one of the
 specified path.</td></tr>
<tr><td valign="top"><a href="#make_relative-2">make_relative/2</a></td><td>Returns a version of the first specified path that is relative to the
 specified second reference directory; returns the same type (plain or binary
 string) as the one of the first specified path.</td></tr>
<tr><td valign="top"><a href="#move_file-2">move_file/2</a></td><td>Moves the specified file or symbolic link so that it is now designated by 
specified path.</td></tr>
<tr><td valign="top"><a href="#normalise_path-1">normalise_path/1</a></td><td>Normalises specified path (canonicalises it), by translating it so that 
no intermediate, superfluous '.' or '..' is present afterwards.</td></tr>
<tr><td valign="top"><a href="#open-2">open/2</a></td><td>Opens the file corresponding to the specified path, with the specified
 list of options (as listed for file:open/2 in
 <a href="http://erlang.org/doc/man/file.html#open-2" target="_top"><tt>http://erlang.org/doc/man/file.html#open-2</tt></a>, that is: read, write, append, 
exclusive, raw, etc).</td></tr>
<tr><td valign="top"><a href="#open-3">open/3</a></td><td>Opens the file corresponding to the specified path (first parameter) with
 the specified list of options (second parameter; refer to file:open/2 for
 detailed documentation, see <a href="http://erlang.org/doc/man/file.html#open-2" target="_top"><tt>http://erlang.org/doc/man/file.html#open-2</tt></a>).</td></tr>
<tr><td valign="top"><a href="#path_to_variable_name-1">path_to_variable_name/1</a></td><td>Converts specified path (full filename, like '/home/jack/test.txt' or 
'./media/test.txt') into a variable name licit in most programming languages 
(e.g.</td></tr>
<tr><td valign="top"><a href="#path_to_variable_name-2">path_to_variable_name/2</a></td><td>Converts specified path (full filename, like '/home/jack/test.txt' or 
'./media/test.txt') into a variable name licit in most programming languages 
(e.g.</td></tr>
<tr><td valign="top"><a href="#read-2">read/2</a></td><td>Reads the specified number of bytes/characters from the specified file.</td></tr>
<tr><td valign="top"><a href="#read_etf_file-1">read_etf_file/1</a></td><td>Reads the specified file, supposedly in ETF format (Erlang Term Format): 
tries to parse a list of terms (one per line, terminating with a dot) from it 
(as file:consult/1 does), and returns it.</td></tr>
<tr><td valign="top"><a href="#read_lines-1">read_lines/1</a></td><td>Reads the content of the specified file, expected to be a text one, based 
on its filename specified as any kind of string (plain, binary, atom, etc) and 
returns its content as a list of plain strings, or throws an exception on 
failure.</td></tr>
<tr><td valign="top"><a href="#read_terms-1">read_terms/1</a></td><td>Reads the specified file supposedly in ETF format (Erlang Term Format): 
tries to parse a list of terms (one per line, terminating with a dot) from it 
(as file:consult/1 does), and returns it.</td></tr>
<tr><td valign="top"><a href="#read_whole-1">read_whole/1</a></td><td>Reads the content of the specified file, based on its filename specified 
as any kind of string (plain, binary, atom, etc), and returns the 
corresponding binary, or throws an exception on failure.</td></tr>
<tr><td valign="top"><a href="#remove_directories-1">remove_directories/1</a></td><td>Removes the specified (possibly non-empty) directories as a whole 
(i.e.</td></tr>
<tr><td valign="top"><a href="#remove_directories_if_existing-1">remove_directories_if_existing/1</a></td><td>Removes, if they exist, the specified (possibly non-empty) directories as 
a whole (i.e.</td></tr>
<tr><td valign="top"><a href="#remove_directory-1">remove_directory/1</a></td><td>Removes the specified (possibly non-empty) directory as a whole 
(i.e.</td></tr>
<tr><td valign="top"><a href="#remove_directory_if_existing-1">remove_directory_if_existing/1</a></td><td>Removes, if it exists, the specified (possibly non-empty) directory as a 
whole (i.e.</td></tr>
<tr><td valign="top"><a href="#remove_empty_directory-1">remove_empty_directory/1</a></td><td>Removes the specified directory, which must be empty (so: behaves mostly
 like the 'rmdir' shell command).</td></tr>
<tr><td valign="top"><a href="#remove_empty_path-1">remove_empty_path/1</a></td><td>Removes all (supposedly) empty directories pertaining to the specified 
local, relative directory path, that is this path (e.g.</td></tr>
<tr><td valign="top"><a href="#remove_empty_tree-1">remove_empty_tree/1</a></td><td>Removes all (supposedly) empty directories found from specified
 directory, expected to be the root of a tree that contains only (possibly
 nested) directories (and no other kind of filesystem entry).</td></tr>
<tr><td valign="top"><a href="#remove_extension-1">remove_extension/1</a></td><td>Removes the (last) extension (regardless of its actual value) of the 
specified file path.</td></tr>
<tr><td valign="top"><a href="#remove_extension-2">remove_extension/2</a></td><td>Checks that the (last) extension of the specified file path is the 
specified one, and returns that path once this extension has been removed.</td></tr>
<tr><td valign="top"><a href="#remove_file-1">remove_file/1</a></td><td>Removes (deletes) the specified file (be them regular files or symbolic 
links), specified as any kind of string.</td></tr>
<tr><td valign="top"><a href="#remove_file_if_existing-1">remove_file_if_existing/1</a></td><td>Removes the specified regular file, specified as any kind of string, iff
 it is already existing, otherwise does nothing.</td></tr>
<tr><td valign="top"><a href="#remove_file_or_link_if_existing-1">remove_file_or_link_if_existing/1</a></td><td>Removes (deletes) the specified file (regular or symbolic link), 
specified as any kind of string, iff it is already existing, otherwise does 
nothing.</td></tr>
<tr><td valign="top"><a href="#remove_files-1">remove_files/1</a></td><td>Removes (deletes) the specified files (be them regular files or symbolic 
links), specified as a list of any kind of strings.</td></tr>
<tr><td valign="top"><a href="#remove_files_if_existing-1">remove_files_if_existing/1</a></td><td>Removes each of the specified regular files, in the specified list of any
 kind of strings, iff it is already existing.</td></tr>
<tr><td valign="top"><a href="#remove_symlink-1">remove_symlink/1</a></td><td>Removes (deletes) the specified symbolic link, specified as any kind of 
string.</td></tr>
<tr><td valign="top"><a href="#remove_symlink_if_existing-1">remove_symlink_if_existing/1</a></td><td>Removes (deletes) the specified symbolic link, specified as any kind of 
string, iff it is already existing, otherwise does nothing.</td></tr>
<tr><td valign="top"><a href="#remove_upper_levels_and_extension-1">remove_upper_levels_and_extension/1</a></td><td>Removes all upper levels of a path (absolute or not), as well as the 
extension of the resulting file name.</td></tr>
<tr><td valign="top"><a href="#rename-2">rename/2</a></td><td>Renames the specified file.</td></tr>
<tr><td valign="top"><a href="#rename_preserving-2">rename_preserving/2</a></td><td>Renames the specified file; if the destination file already exists, 
renames it first by suffixing '.previous' to its name (then overwriting any 
identically-named file that would already exist), before performing the 
renaming.</td></tr>
<tr><td valign="top"><a href="#rename_preserving-3">rename_preserving/3</a></td><td>Renames the specified file; if the destination file already exists, 
renames it first by adding the specified suffix to its name (then overwriting 
any identically-named file that would already exist), before performing the 
renaming.</td></tr>
<tr><td valign="top"><a href="#replace_extension-3">replace_extension/3</a></td><td>Returns a new file path whose extension has been updated.</td></tr>
<tr><td valign="top"><a href="#resolve_any_path-1">resolve_any_path/1</a></td><td>Resolves the specified path - either a standard one or a resolvable one -
 in all cases as a plain, standard path.</td></tr>
<tr><td valign="top"><a href="#resolve_path-1">resolve_path/1</a></td><td>Resolves the specified resolvable path as a standard path.</td></tr>
<tr><td valign="top"><a href="#resolve_symlink_fully-1">resolve_symlink_fully/1</a></td><td>Resolves fully the specified symbolic link: returns the entry it points
 ultimately to (therefore this entry cannot be a symbolic link), or throws an
 exception (including if exceeding a larger link depth, which happens most
 probably because these links form a cycle; throwing arbitrarily an exception
 is better than looping for ever).</td></tr>
<tr><td valign="top"><a href="#resolve_symlink_once-1">resolve_symlink_once/1</a></td><td>Resolves the specified symbolic link once: returns the entry (potentially
 another symbolic link) it points to.</td></tr>
<tr><td valign="top"><a href="#resolve_type_of-1">resolve_type_of/1</a></td><td>Returns the actual, ultimate type of the specified file entry (hence may 
not return 'symlink').</td></tr>
<tr><td valign="top"><a href="#set_current_directory-1">set_current_directory/1</a></td><td>Sets the specified directory as current directory.</td></tr>
<tr><td valign="top"><a href="#split-1">split/1</a></td><td>Splits the specified path in elements, returned as a list.</td></tr>
<tr><td valign="top"><a href="#split_path-1">split_path/1</a></td><td>Splits the specified path into a full base directory path and a final 
entry (filename or directory name).</td></tr>
<tr><td valign="top"><a href="#to_permission_mask-1">to_permission_mask/1</a></td><td>Encodes the specified symbolic permission(s) into its/their low-level
 counterpart mask(s).</td></tr>
<tr><td valign="top"><a href="#touch-1">touch/1</a></td><td>Updates the modification time (the last time at which its content was 
reported as modified according to the filesystem) of the specified file entry, 
which must already exist.</td></tr>
<tr><td valign="top"><a href="#try_copy_file-2">try_copy_file/2</a></td><td>Copies the specified file to a given destination filename (not a 
directory name, see copy_file_in/2 for that), overwriting any previous file.</td></tr>
<tr><td valign="top"><a href="#update_with_keywords-3">update_with_keywords/3</a></td><td>Updates the specified file with the specified keywords, that is copies 
the original file into a target, updated one (supposedly non-already 
existing), in which all the specified keywords (the keys of the translation 
table) have been replaced by their associated value (that is the value in 
table corresponding to that key).</td></tr>
<tr><td valign="top"><a href="#update_with_keywords-4">update_with_keywords/4</a></td><td>Updates the specified file with the specified keywords, that is copies 
the original file into a target, updated one (supposedly non-already 
existing), in which all the specified keywords (the keys of the translation 
table) have been replaced by their associated value (that is the value in 
table corresponding to that key).</td></tr>
<tr><td valign="top"><a href="#write-2">write/2</a></td><td>Writes the specified byte-oriented content in the specified file.</td></tr>
<tr><td valign="top"><a href="#write_direct_terms-2">write_direct_terms/2</a></td><td>Writes directly the specified terms int the specified already opened 
file, in the ETF format.</td></tr>
<tr><td valign="top"><a href="#write_etf_file-2">write_etf_file/2</a></td><td>Writes the specified terms in the specified file, in the ETF format, with 
no specific header or footer.</td></tr>
<tr><td valign="top"><a href="#write_etf_file-4">write_etf_file/4</a></td><td>Writes the specified terms in the specified file, in the ETF format, with 
the specified header and footer.</td></tr>
<tr><td valign="top"><a href="#write_terms-2">write_terms/2</a></td><td>Writes the specified terms in the specified file, in the ETF format, with 
no specific header or footer.</td></tr>
<tr><td valign="top"><a href="#write_terms-4">write_terms/4</a></td><td>Writes the specified terms in the specified file, in the ETF format, with 
the specified header and footer.</td></tr>
<tr><td valign="top"><a href="#write_ustring-2">write_ustring/2</a></td><td>Writes the specified Unicode string in the specified file.</td></tr>
<tr><td valign="top"><a href="#write_ustring-3">write_ustring/3</a></td><td>Writes the specified formatted content in the specified file.</td></tr>
<tr><td valign="top"><a href="#write_whole-2">write_whole/2</a></td><td>Writes the specified content in the specified file, whose path is 
specified as any kind of string, using a default encoding if a plain string is 
specified.</td></tr>
<tr><td valign="top"><a href="#write_whole-3">write_whole/3</a></td><td>Writes the specified content in the file whose path is specified as any 
kind of string, using the specified modes options, and applying before a 
default encoding if a plain string is specified.</td></tr>
<tr><td valign="top"><a href="#write_whole_in_non_clashing-1">write_whole_in_non_clashing/1</a></td><td>Writes the specified content in a new file, whose path is chosen not to 
clash with any other (typically a temporary file), and returns that path.</td></tr>
<tr><td valign="top"><a href="#zipped_term_to_unzipped_file-1">zipped_term_to_unzipped_file/1</a></td><td>Reads the specified binary, extracts the zipped file in it and writes it 
on disk, in the current directory.</td></tr>
<tr><td valign="top"><a href="#zipped_term_to_unzipped_file-2">zipped_term_to_unzipped_file/2</a></td><td>Reads the specified binary, extracts the zipped file in it and writes it 
on disk, in the current directory, under the specified filename instead of 
under the filename stored in the zip archive.</td></tr>
<tr><td valign="top"><a href="#zipped_term_to_unzipped_files-1">zipped_term_to_unzipped_files/1</a></td><td>Reads the specified binary, extracts the zipped files stored in it and 
writes them on disk, in the current directory.</td></tr>
<tr><td valign="top"><a href="#zipped_term_to_unzipped_files-2">zipped_term_to_unzipped_files/2</a></td><td>Reads the specified binary, extracts the zipped files in it and writes 
them on disk, in the specified directory.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="any_join-1">any_join/1</a></h3>
<div class="spec">
<p><tt>any_join(ComponentList::[<a href="#type-any_path_element">any_path_element()</a>]) -&gt; <a href="#type-any_path">any_path()</a></tt><br></p>
<p> </p>
</div><p><p>Joins the specified list of path elements; returns a corresponding binary 
string if at least one element is a binary string itself, otherwise returns a 
plain string.</p>

 <p>Never attempts a binary-to-string conversion; introduced to promote to binary 
string only when necessary.</p>

 <p>See join/1 for API details.</p>

 <p>Plain and binary strings can be freely used as arguments.</p>

 See split/1 for the reverse operation.
</p>

<h3 class="function"><a name="any_join-2">any_join/2</a></h3>
<div class="spec">
<p><tt>any_join(FirstPath::<a href="#type-any_path">any_path()</a>, SecondPath::<a href="#type-any_path">any_path()</a>) -&gt; <a href="#type-any_path">any_path()</a></tt><br></p>
<p> </p>
</div><p><p>Joins the two specified path elements; returns a corresponding binary 
string if at least one element is a binary string itself, otherwise returns a 
plain string.</p>

 Never attempts a binary-to-string conversion; introduced to promote to binary
 string only when necessary.
</p>

<h3 class="function"><a name="append_file-2">append_file/2</a></h3>
<div class="spec">
<p><tt>append_file(TargetFilename::<a href="#type-file_name">file_name()</a>, ToAppendFilename::<a href="#type-file_name">file_name()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p>Appends, at the end of the first specified file, the content of the
 second specified one: concatenates the second with the first one.
</p>

<h3 class="function"><a name="bin_join-1">bin_join/1</a></h3>
<div class="spec">
<p><tt>bin_join(ComponentList::[<a href="#type-any_path_element">any_path_element()</a>]) -&gt; <a href="#type-bin_path">bin_path()</a></tt><br></p>
<p> </p>
</div><p><p>Joins the specified list of path elements, returns a corresponding binary 
string.</p>

 <p>See join/1 for API details.</p>

 <p>Plain and binary strings can be freely used as arguments, and a binary string 
is returned in all cases.</p>

 See split/1 for the reverse operation.
</p>

<h3 class="function"><a name="bin_join-2">bin_join/2</a></h3>
<div class="spec">
<p><tt>bin_join(FirstPath::<a href="#type-any_path">any_path()</a>, SecondPath::<a href="#type-any_path">any_path()</a>) -&gt; <a href="#type-bin_path">bin_path()</a></tt><br></p>
<p> </p>
</div><p><p>Joins the two specified path elements, returns a corresponding binary 
string.</p>

 <p>Never attempts a binary-to-string conversion.</p>

 Introduced to support the case where at least one argument is an
 improperly-encoded Unicode binary path: any operation implying a conversion to
 string of it will fail, so the operation must take place exclusively among
 binaries.
</p>

<h3 class="function"><a name="change_permissions-2">change_permissions/2</a></h3>
<div class="spec">
<p><tt>change_permissions(Path::<a href="#type-any_path">any_path()</a>, NewPermissions::<a href="#type-permission">permission()</a> | [<a href="#type-permission">permission()</a>]) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Changes the permissions ("chmod") of specified filesystem element.</p>

 Note: erases any prior permissions, i.e. if specifying [other_read] then a
 corresponding file will end up with (exactly) a -------r-- permission.
</p>

<h3 class="function"><a name="close-1">close/1</a></h3>
<div class="spec">
<p><tt>close(File::<a href="#type-file">file()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Closes the specified file reference.</p>

 Throws an exception on failure.
</p>

<h3 class="function"><a name="close-2">close/2</a></h3>
<div class="spec">
<p><tt>close(File::<a href="#type-file">file()</a>, FailureMode::overcome_failure | throw_if_failed) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Closes the specified file reference.</p>

 Throws an exception on failure or not, depending on specified failure mode.
</p>

<h3 class="function"><a name="compress-1">compress/1</a></h3>
<div class="spec">
<p><tt>compress(Filename::<a href="#type-file_name">file_name()</a>) -&gt; <a href="#type-file_name">file_name()</a></tt><br></p>
<p> </p>
</div><p><p>Compresses the specified file: creates a compressed version thereof 
(using the most efficient, compacity-wise, compression tool available), whose 
filename, established based on usual conventions, is returned. If a file with 
that name already exists, it will be overwritten.</p>

 <p>For example, compress("hello.png") will generate a "hello.png.xz" file.</p>

 <p>The original file remain as is.</p>

 Note: this function just takes care of compressing a single file, even if some
 compressors (e.g. zip) include features to create an archive of multiple files
 first.
</p>

<h3 class="function"><a name="compress-2">compress/2</a></h3>
<div class="spec">
<p><tt>compress(Filename::<a href="#type-file_name">file_name()</a>, CompressionFormat::<a href="#type-compression_format">compression_format()</a>) -&gt; <a href="#type-file_name">file_name()</a></tt><br></p>
<p> </p>
</div><p><p>Compresses the specified file: creates a compressed version thereof, 
whose filename, established based on usual conventions, is returned. If a file 
with that name already exists, it will be overwritten.</p>

 <p>For example, compress("hello.png", zip) will generate a "hello.png.zip" file.</p>

 <p>The original file remain as is.</p>

 Note: this function just takes care of compressing a single file, even if some
 compressors (e.g. zip) include features to create an archive of multiple files
 first.
</p>

<h3 class="function"><a name="convert_to_filename-1">convert_to_filename/1</a></h3>
<div class="spec">
<p><tt>convert_to_filename(BinName::<a href="#type-any_string">any_string()</a>) -&gt; <a href="#type-any_file_name">any_file_name()</a></tt><br></p>
<p> </p>
</div><p><p>Converts the specified name into an acceptable filename, filesystem-wise.</p>

 Returns the same type of string as the provided one.
</p>

<h3 class="function"><a name="copy_as_regular_file_in-2">copy_as_regular_file_in/2</a></h3>
<div class="spec">
<p><tt>copy_as_regular_file_in(SourcePath::<a href="#type-any_file_path">any_file_path()</a>, DestinationDirectory::<a href="#type-any_directory_name">any_directory_name()</a>) -&gt; <a href="#type-any_file_path">any_file_path()</a></tt><br></p>
<p> </p>
</div><p><p>Copies the actual regular file specified - either directly a regular 
file, or a regular file ultimately pointed to by any specified symbolic link - 
in the specified destination directory, overwriting any previous file, and 
returning the full path of the copied file.</p>

 Note: content is copied and permissions are preserved (e.g. the copy of an
 executable file will be itself executable, like for the other permissions -
 and unlike /bin/cp, which relies on umask).
</p>

<h3 class="function"><a name="copy_file-2">copy_file/2</a></h3>
<div class="spec">
<p><tt>copy_file(SourceFilePath::<a href="#type-any_file_path">any_file_path()</a>, DestinationFilePath::<a href="#type-any_file_path">any_file_path()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Copies the specified file to a given destination filename (not a 
directory name, see copy_file_in/2 for that), overwriting any previous file.</p>

 Note: content is copied and permissions are preserved (e.g. the copy of an
 executable file will be itself executable, and other permissions as well,
 unlike /bin/cp that relies on umask).
</p>

<h3 class="function"><a name="copy_file_if_existing-2">copy_file_if_existing/2</a></h3>
<div class="spec">
<p><tt>copy_file_if_existing(SourceFilePath::<a href="#type-any_file_path">any_file_path()</a>, DestinationFilePath::<a href="#type-any_file_path">any_file_path()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Copies the specified file to a given destination iff this source file is 
already existing.</p>

 Note: content is copied and permissions are preserved (e.g. the copy of an
 executable file will be itself executable, likz for the other permissions -
 and unlike /bin/cp, which relies on umask).
</p>

<h3 class="function"><a name="copy_file_in-2">copy_file_in/2</a></h3>
<div class="spec">
<p><tt>copy_file_in(SourcePath::<a href="#type-any_file_path">any_file_path()</a>, DestinationDirectory::<a href="#type-any_directory_name">any_directory_name()</a>) -&gt; <a href="#type-any_file_path">any_file_path()</a></tt><br></p>
<p> </p>
</div><p><p>Copies the specified file in the specified destination directory, 
overwriting any previous file, and returning the full path of the copied file.</p>

 Note: content is copied and permissions are preserved (e.g. the copy of an
 executable file will be itself executable, like for the other permissions -
 and unlike /bin/cp, which relies on umask).
</p>

<h3 class="function"><a name="copy_tree-2">copy_tree/2</a></h3>
<div class="spec">
<p><tt>copy_tree(SourceTreePath::<a href="#type-any_directory_path">any_directory_path()</a>, TargetDirectory::<a href="#type-any_directory_path">any_directory_path()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p>Copies the specified source tree in specified target directory.</p>

<h3 class="function"><a name="create_directory-1">create_directory/1</a></h3>
<div class="spec">
<p><tt>create_directory(AnyDirPath::<a href="#type-any_directory_path">any_directory_path()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Creates the specified directory ("mkdir"), without creating any 
intermediate (parent) directory that would not exist.</p>

 Throws an exception if the operation failed, for example if the directory is
 already existing ({create_directory_failed, "foobar", eexist}).
</p>

<h3 class="function"><a name="create_directory-2">create_directory/2</a></h3>
<div class="spec">
<p><tt>create_directory(AnyDirPath::<a href="#type-any_directory_path">any_directory_path()</a>, X2::<a href="#type-parent_creation">parent_creation()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Creates the specified directory.</p>

 <p>If 'create_no_parent' is specified, no intermediate (parent) directory will be 
created.</p>

 <p>If 'create_parents' is specified, any non-existing intermediate (parent) 
directory will be created.</p>

 Throws an exception if the operation fails, for example if the directory is
 already existing ({create_directory_failed, "foobar", eexist}).
</p>

<h3 class="function"><a name="create_directory_if_not_existing-1">create_directory_if_not_existing/1</a></h3>
<div class="spec">
<p><tt>create_directory_if_not_existing(AnyDirPath::<a href="#type-any_directory_path">any_directory_path()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Creates the specified directory (but not any parent thereof), if not 
already existing.</p>

 Throws an exception if the operation fails.
</p>

<h3 class="function"><a name="create_directory_if_not_existing-2">create_directory_if_not_existing/2</a></h3>
<div class="spec">
<p><tt>create_directory_if_not_existing(AnyDirPath::<a href="#type-any_directory_path">any_directory_path()</a>, ParentCreation::<a href="#type-parent_creation">parent_creation()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Creates the specified directory (and, if specified, any needed parent as 
well), if not already existing.</p>

 Throws an exception if the operation fails.
</p>

<h3 class="function"><a name="create_empty_file-1">create_empty_file/1</a></h3>
<div class="spec">
<p><tt>create_empty_file(AnyFilePath::<a href="#type-any_file_path">any_file_path()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Creates an empty file bearing the specified filename (other use of 
touch).</p>

 <p>Potentially useful as a last-resort debugging tool (when no console output or 
applicative trace can be relied upon, we can at least leave side-effects on 
the filesystem).</p>

 <p>Note: of course a simple 'os:cmd("/bin/touch ~/my-message.debug").' may be 
of use as well.</p>

 See also: touch/1.
</p>

<h3 class="function"><a name="create_link-2">create_link/2</a></h3>
<div class="spec">
<p><tt>create_link(TargetPath::<a href="#type-any_path">any_path()</a>, NewLinkPath::<a href="#type-link_path">link_path()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Creates a symbolic link pointing to the specified target path, at the 
specified new (link) path.</p>

 For example create_link("Projects/SomeProject", "/home/joe/my-link") will
 create a "/home/joe/my-link" symlink pointing to "Projects/SomeProject" (thus
 relatively to "/home/joe/"), whether or not this
 "/home/joe/Projects/SomeProject" target exists (so the current directory does
 not matter here).
</p>

<h3 class="function"><a name="create_non_clashing_file-0">create_non_clashing_file/0</a></h3>
<div class="spec">
<p><tt>create_non_clashing_file() -&gt; <a href="#type-file_path">file_path()</a></tt><br></p>
<p> </p>
</div><p><p>Creates on the filesystem a file whose path is guaranteed not to clash 
with any other.</p>

 <p>Typically useful to create a temporary file.</p>

 <p>An empty file is created for that name, whose path is returned.</p>

 May for example return "/tmp/tmp.QgHRjzI2TZ".
</p>

<h3 class="function"><a name="create_preserving-2">create_preserving/2</a></h3>
<div class="spec">
<p><tt>create_preserving(AnyFilePath::<a href="#type-any_file_path">any_file_path()</a>, Options::[<a href="#type-file_open_mode">file_open_mode()</a>]) -&gt; <a href="#type-file">file()</a></tt><br></p>
<p> </p>
</div><p>Opens for a creation from scratch the specified file with the specified
 options (the 'write' one being implied and automatically added here); if the
 target file already exists, renames it first by suffixing '.previous' to its
 name (then overwriting any identically-named file that would already exist),
 before performing the creation.
</p>

<h3 class="function"><a name="create_preserving-3">create_preserving/3</a></h3>
<div class="spec">
<p><tt>create_preserving(AnyFilePath::<a href="#type-any_file_path">any_file_path()</a>, HidingSuffix::<a href="#type-ustring">ustring()</a>, Options::[<a href="#type-file_open_mode">file_open_mode()</a>]) -&gt; <a href="#type-file">file()</a></tt><br></p>
<p> </p>
</div><p>Opens for a creation from scratch the specified file with the specified
 options (the 'write' one being implied and automatically added here); if the
 target file already exists, renames it first based on the specified suffix
 (then overwriting any identically-named file that would already exist), before
 performing the creation.
</p>

<h3 class="function"><a name="create_temporary_directory-0">create_temporary_directory/0</a></h3>
<div class="spec">
<p><tt>create_temporary_directory() -&gt; <a href="#type-directory_path">directory_path()</a></tt><br></p>
<p> </p>
</div><p><p>Creates a non-previously existing temporary directory, and returns its 
full path.</p>

 See also: system_utils:get_default_temporary_directory/0
</p>

<h3 class="function"><a name="decompress-1">decompress/1</a></h3>
<div class="spec">
<p><tt>decompress(Filename::<a href="#type-file_name">file_name()</a>) -&gt; <a href="#type-file_name">file_name()</a></tt><br></p>
<p> </p>
</div><p><p>Decompresses the specified compressed file, expected to bear the 
extension corresponding to the implicit, most compact format: recreates the 
original, decompressed version thereof, whose filename, established based on 
usual conventions, is returned: the name of the input file without its 
extension.</p>

 <p>This function works in pair with compress/2, and as such expects that each 
compressed file contains exactly one file, bear the same filename except the 
compressor extension.</p>

 <p>Typically, when a format MY_FORMAT is specified, converts a compressed file 
name foo.extension_of(MY_FORMAT) into an uncompressed version of it named 
'foo'.</p>

 <p>So, for example, decompress( "foo.xz" ) will generate a "foo" file.</p>

 <p>If a file with that name already exists, it will be overwritten.</p>

 The compressed file remains as is.
</p>

<h3 class="function"><a name="decompress-2">decompress/2</a></h3>
<div class="spec">
<p><tt>decompress(ZipFilename::<a href="#type-file_name">file_name()</a>, CompressionFormat::<a href="#type-compression_format">compression_format()</a>) -&gt; <a href="#type-file_name">file_name()</a></tt><br></p>
<p> </p>
</div><p><p>Decompresses the specified compressed file, expected to bear the 
extension corresponding to the specified format: recreates the original, 
decompressed version thereof, whose filename, established based on usual 
conventions, is returned: the name of the input file without its extension.</p>

 <p>This function works in pair with compress/2, and as such expects that each 
compressed file contains exactly one file, bear the same filename except the 
compressor extension.</p>

 <p>Typically, when a format MY_FORMAT is specified, converts a compressed file 
name foo.extension_of(MY_FORMAT) into an uncompressed version of it named 
'foo'.</p>

 <p>So, for example, decompress("foo.xz", xz) will generate a "foo" file.</p>

 <p>If a file with that name already exists, it will be overwritten.</p>

 The compressed file remains as is.
</p>

<h3 class="function"><a name="ensure_path_is_absolute-1">ensure_path_is_absolute/1</a></h3>
<div class="spec">
<p><tt>ensure_path_is_absolute(Path::<a href="#type-path">path()</a>) -&gt; <a href="#type-path">path()</a></tt><br></p><p><tt>ensure_path_is_absolute(Path::<a href="#type-bin_path">bin_path()</a>) -&gt; <a href="#type-bin_path">bin_path()</a></tt><br></p>
<p> </p>
<p> </p>
</div><p><p>Returns an absolute, normalised path corresponding to the specified path.</p>

 <p>Returns a string of the same type as the specified one.</p>

 If it is not already absolute, it will made so by using the current working
 directory.
</p>

<h3 class="function"><a name="ensure_path_is_absolute-2">ensure_path_is_absolute/2</a></h3>
<div class="spec">
<p><tt>ensure_path_is_absolute(TargetPath::<a href="#type-any_path">any_path()</a>, BasePath::<a href="#type-any_path">any_path()</a>) -&gt; <a href="#type-any_path">any_path()</a></tt><br></p>
<p> </p>
</div><p><p>Returns an absolute, normalised path corresponding to the specified 
target path, using base path as root directory (this must be an absolute path) 
if the target path is not absolute.</p>

 <p>Returns a plain string iff both specified ones are plain, otherwise returns a 
binary.</p>

 For example ensure_path_is_absolute("tmp/foo", "/home/dalton") will return
 "/home/dalton/tmp/foo".
</p>

<h3 class="function"><a name="escape_path-1">escape_path/1</a></h3>
<div class="spec">
<p><tt>escape_path(Path::<a href="#type-any_path">any_path()</a>) -&gt; <a href="#type-any_string">any_string()</a></tt><br></p>
<p> </p>
</div><p><p>Escapes specified path so that it can safely be included as a seralised 
(string) content.</p>

 Returns the same type of string as the specified one.
</p>

<h3 class="function"><a name="exists-1">exists/1</a></h3>
<div class="spec">
<p><tt>exists(EntryName::<a href="#type-any_path">any_path()</a>) -&gt; boolean()</tt><br></p>
<p> </p>
</div><p>Tells whether specified file entry exists, regardless of its type.</p>

<h3 class="function"><a name="file_to_zipped_term-1">file_to_zipped_term/1</a></h3>
<div class="spec">
<p><tt>file_to_zipped_term(Filename::<a href="#type-file_name">file_name()</a>) -&gt; binary()</tt><br></p>
<p> </p>
</div><p><p>Reads in memory the file specified from its filename, zips the 
corresponding term, and returns it, as a compressed binary.</p>

 <p>Note: useful for network transfers of small files.</p>

 <p>Larger ones should be transferred with TCP/IP and by chunks.</p>

 Returns a binary.
</p>

<h3 class="function"><a name="files_to_zipped_term-1">files_to_zipped_term/1</a></h3>
<div class="spec">
<p><tt>files_to_zipped_term(FilenameList::[<a href="#type-file_name">file_name()</a>]) -&gt; binary()</tt><br></p>
<p> </p>
</div><p><p>Reads in memory the files specified from their filenames (as plain 
strings), zips the corresponding term, and returns it.</p>

 Note: useful for network transfers of small files. Larger ones should be
 transferred with TCP/IP / send_file and by chunks.
</p>

<h3 class="function"><a name="files_to_zipped_term-2">files_to_zipped_term/2</a></h3>
<div class="spec">
<p><tt>files_to_zipped_term(FilenameList::[<a href="#type-file_name">file_name()</a>], BaseDirectory::<a href="#type-any_directory_name">any_directory_name()</a>) -&gt; binary()</tt><br></p>
<p> </p>
</div><p><p>Reads in memory the files specified from their filenames (as plain 
strings), assuming their path is relative to the specified base directory, 
zips the corresponding term, and returns it.</p>

 Note: useful for network transfers of small files. Larger ones should be
 transferred with TCP/IP / send_file and by chunks.
</p>

<h3 class="function"><a name="filter_by_excluded_suffixes-2">filter_by_excluded_suffixes/2</a></h3>
<div class="spec">
<p><tt>filter_by_excluded_suffixes(Paths::[<a href="#type-any_path">any_path()</a>], ExcludedSuffixes::[<a href="#type-any_suffix">any_suffix()</a>]) -&gt; [<a href="#type-any_path">any_path()</a>]</tt><br></p>
<p> </p>
</div><p>Returns a list containing all paths in the specified list (in an
 unspecified order) that do not match any of the specified suffixes.
</p>

<h3 class="function"><a name="filter_by_extension-2">filter_by_extension/2</a></h3>
<div class="spec">
<p><tt>filter_by_extension(Filenames::[<a href="#type-file_path">file_path()</a>], Extension::<a href="#type-extension">extension()</a>) -&gt; [<a href="#type-file_path">file_path()</a>]</tt><br></p>
<p> </p>
</div><p>Returns a list containing all elements of the Filenames list whose
 extension is the specified one (e.g. ".dat").
</p>

<h3 class="function"><a name="filter_by_extensions-2">filter_by_extensions/2</a></h3>
<div class="spec">
<p><tt>filter_by_extensions(Filenames::[<a href="#type-file_path">file_path()</a>], Extensions::[<a href="#type-extension">extension()</a>]) -&gt; [<a href="#type-file_path">file_path()</a>]</tt><br></p>
<p> </p>
</div><p>Returns a list containing all elements of Filenames list whose extension
 corresponds to one of the specified extensions (e.g. [".dat", ".png"]).
</p>

<h3 class="function"><a name="filter_by_included_suffixes-2">filter_by_included_suffixes/2</a></h3>
<div class="spec">
<p><tt>filter_by_included_suffixes(Paths::[<a href="#type-any_path">any_path()</a>], IncludedSuffixes::[<a href="#type-any_suffix">any_suffix()</a>]) -&gt; [<a href="#type-any_path">any_path()</a>]</tt><br></p>
<p> </p>
</div><p>Returns a list containing all paths in the specified list (in an
 unspecified order) that match any of the specified suffixes.
</p>

<h3 class="function"><a name="find_directories_from-1">find_directories_from/1</a></h3>
<div class="spec">
<p><tt>find_directories_from(RootDir::<a href="#type-any_directory_name">any_directory_name()</a>) -&gt; [<a href="#type-directory_name">directory_name()</a>]</tt><br></p>
<p> </p>
</div><p><p>Returns a list of all directories found from the root, in the whole 
subtree (that is recursively).</p>

 All returned pathnames are relative to this root.
 For example ["./my-dir", "./tmp/other-dir"].
</p>

<h3 class="function"><a name="find_files_from-1">find_files_from/1</a></h3>
<div class="spec">
<p><tt>find_files_from(RootDir::<a href="#type-any_directory_path">any_directory_path()</a>) -&gt; [<a href="#type-file_path">file_path()</a>]</tt><br></p>
<p> </p>
</div><p><p>Returns a list of all files (regular ones and symlinks) found from the 
root, in the whole subtree (that is recursively).</p>

 <p>All extensions and suffixes accepted, no excluded directories. Elements whose 
name is improperly encoded are notified thanks to a warning trace, and then 
are ignored.</p>

 All returned pathnames are relative to this root.
 For example ["./a.txt", "./tmp/b.txt"].
</p>

<h3 class="function"><a name="find_files_from-2">find_files_from/2</a></h3>
<div class="spec">
<p><tt>find_files_from(RootDir::<a href="#type-any_directory_path">any_directory_path()</a>, IncludeSymlinks::boolean()) -&gt; [<a href="#type-file_path">file_path()</a>]</tt><br></p>
<p> </p>
</div><p><p>Returns a list of all files (regular ones and, if requested, symlinks) 
found from the root, in the whole subtree (that is recursively).</p>

 <p>All extensions and suffixes accepted, no excluded directories. Elements whose 
name is improperly encoded are notified thanks to a warning trace, and then 
are ignored.</p>

 All returned pathnames are relative to this root.
 For example ["./a.txt", "./tmp/b.txt"].
</p>

<h3 class="function"><a name="find_files_from-3">find_files_from/3</a></h3>
<div class="spec">
<p><tt>find_files_from(RootDir::<a href="#type-any_directory_path">any_directory_path()</a>, IncludeSymlinks::boolean(), IfImproperEncoding::<a href="#type-improper_encoding_action">improper_encoding_action()</a>) -&gt; [<a href="#type-any_file_path">any_file_path()</a>]</tt><br></p>
<p> </p>
</div><p><p>Returns a list of all files (regular ones and, if requested, symlinks) 
found from the root, in the whole subtree (that is recursively).</p>

 <p>All extensions and suffixes accepted, no excluded directories. Elements whose 
name is improperly encoded are managed according to the IfImproperEncoding 
parameter; if set to 'include', the return type of this function is the more 
general [any_file_path()], otherwise it is [file_path()].</p>

 All returned pathnames are relative to this root.
 For example ["./a.txt", "./tmp/b.txt"].
</p>

<h3 class="function"><a name="find_files_with_excluded_dirs-2">find_files_with_excluded_dirs/2</a></h3>
<div class="spec">
<p><tt>find_files_with_excluded_dirs(RootDir::<a href="#type-any_directory_path">any_directory_path()</a>, ExcludedDirs::[<a href="#type-directory_path">directory_path()</a>]) -&gt; [<a href="#type-file_path">file_path()</a>]</tt><br></p>
<p> </p>
</div><p><p>Returns a list of all files (regular ones and symlinks) found from the 
root, in the whole subtree (that is recursively), with specified directories 
excluded.</p>

 <p>Note that an excluded directory can be specified as a full (relative) path 
(e.g. "foo/bar/not-wanted"), or just as a final directory name (e.g. 
"my-excluded-name"). In the latter case, all directories bearing that name 
(e.g. "foo/bar/any/my-excluded-name") will be excluded as well.</p>

 <p>Thus when a directory D is specified in the excluded list, each traversed 
directory T will be compared twice to D: T will be matched against D, and 
against filename:basename(T), i.e. its final name, as well. As soon as one 
matches, T will be excluded.</p>

 <p>All extensions and suffixes accepted. Elements whose name is improperly 
encoded are notified thanks to a warning trace, and then are ignored.</p>

 All returned pathnames are relative to this root.
 For example ["./a.txt", "./tmp/b.txt"].
</p>

<h3 class="function"><a name="find_files_with_excluded_dirs-3">find_files_with_excluded_dirs/3</a></h3>
<div class="spec">
<p><tt>find_files_with_excluded_dirs(RootDir::<a href="#type-any_directory_path">any_directory_path()</a>, ExcludedDirs::[<a href="#type-directory_path">directory_path()</a>], IncludeSymlinks::boolean()) -&gt; [<a href="#type-file_path">file_path()</a>]</tt><br></p>
<p> </p>
</div><p><p>Returns a list of all files (regular ones and, if requested, symlinks) 
found from the root, in the whole subtree (that is recursively), with 
specified directories excluded.</p>

 <p>Note that an excluded directory can be specified as a full (relative) path 
(e.g. "foo/bar/not-wanted"), or just as a final directory name (e.g. 
"my-excluded-name"). In the latter case, all directories bearing that name 
(e.g. "foo/bar/any/my-excluded-name") will be excluded as well.</p>

 <p>Thus when a directory D is specified in the excluded list, each traversed 
directory T will be compared twice to D: T will be matched against D, and 
against filename:basename(T), i.e. its final name, as well. As soon as one 
matches, T will be excluded.</p>

 <p>All extensions and suffixes accepted. Elements whose name is improperly 
encoded are notified thanks to a warning trace, and then are ignored.</p>

 All returned pathnames are relative to this root.
 For example ["./a.txt", "./tmp/b.txt"].
</p>

<h3 class="function"><a name="find_files_with_excluded_dirs-4">find_files_with_excluded_dirs/4</a></h3>
<div class="spec">
<p><tt>find_files_with_excluded_dirs(RootDir::<a href="#type-any_directory_path">any_directory_path()</a>, ExcludedDirs::[<a href="#type-directory_path">directory_path()</a>], IncludeSymlinks::boolean(), IfImproperEncoding::<a href="#type-improper_encoding_action">improper_encoding_action()</a>) -&gt; [<a href="#type-file_path">file_path()</a>]</tt><br></p>
<p> </p>
</div><p><p>Returns a list of all files (regular ones and, if requested, symlinks) 
found from the root, in the whole subtree (that is recursively), with 
specified directories excluded.</p>

 <p>Note that an excluded directory can be specified as a full (relative) path 
(e.g. "foo/bar/not-wanted"), or just as a final directory name (e.g. 
"my-excluded-name"). In the latter case, all directories bearing that name 
(e.g. "foo/bar/any/my-excluded-name") will be excluded as well.</p>

 <p>Thus when a directory D is specified in the excluded list, each traversed 
directory T will be compared twice to D: T will be matched against D, and 
against filename:basename(T), i.e. its final name, as well. As soon as one 
matches, T will be excluded.</p>

 <p>All extensions and suffixes accepted. Elements whose name is improperly 
encoded are managed according to the IfImproperEncoding parameter; if set to 
'include', the return type of this function is the more general 
[any_file_path()], otherwise it is [file_path()].</p>

 All returned pathnames are relative to this root.
 For example ["./a.txt", "./tmp/b.txt"].
</p>

<h3 class="function"><a name="find_files_with_excluded_dirs_and_suffixes-3">find_files_with_excluded_dirs_and_suffixes/3</a></h3>
<div class="spec">
<p><tt>find_files_with_excluded_dirs_and_suffixes(RootDir::<a href="#type-any_directory_path">any_directory_path()</a>, ExcludedDirs::[<a href="#type-directory_path">directory_path()</a>], ExcludedSuffixes::[<a href="#type-any_suffix">any_suffix()</a>]) -&gt; [<a href="#type-file_path">file_path()</a>]</tt><br></p>
<p> </p>
</div><p><p>Returns a list of all files (regular ones and symlinks) found from the 
root, in the whole subtree (that is recursively), with specified directories 
and suffixes excluded.</p>

 <p>Note that an excluded directory can be specified as a full (relative) path 
(e.g. "foo/bar/not-wanted"), or just as a final directory name (e.g. 
"my-excluded-name"). In the latter case, all directories bearing that name 
(e.g. "foo/bar/any/my-excluded-name") will be excluded as well.</p>

 <p>Thus when a directory D is specified in the excluded list, each traversed 
directory T will be compared twice to D: T will be matched against D, and 
against filename:basename(T), i.e. its final name, as well. As soon as one 
matches, T will be excluded.</p>

 <p>Elements whose name is improperly encoded are notified thanks to a warning 
trace, and then are ignored.</p>

 All returned pathnames are relative to this root.
 For example ["./a.txt", "./tmp/b.txt"].
</p>

<h3 class="function"><a name="find_files_with_excluded_suffixes-2">find_files_with_excluded_suffixes/2</a></h3>
<div class="spec">
<p><tt>find_files_with_excluded_suffixes(RootDir::<a href="#type-any_directory_path">any_directory_path()</a>, ExcludedSuffixes::[<a href="#type-any_suffix">any_suffix()</a>]) -&gt; [<a href="#type-file_path">file_path()</a>]</tt><br></p>
<p> </p>
</div><p><p>Returns a list of all files (regular ones and symlinks) found from the 
root which do not match any of the specified suffixes, in the whole subtree 
(that is recursively).</p>

 <p>No excluded directories. Elements whose name is improperly encoded are 
notified thanks to a warning trace, and then are ignored.</p>

 All returned pathnames are relative to this root.
 For example ["./a.txt", "./tmp/b.txt"].
</p>

<h3 class="function"><a name="find_files_with_excluded_suffixes-3">find_files_with_excluded_suffixes/3</a></h3>
<div class="spec">
<p><tt>find_files_with_excluded_suffixes(RootDir::<a href="#type-any_directory_path">any_directory_path()</a>, ExcludedSuffixes::[<a href="#type-any_suffix">any_suffix()</a>], IfImproperEncoding::<a href="#type-improper_encoding_action">improper_encoding_action()</a>) -&gt; [<a href="#type-file_path">file_path()</a>]</tt><br></p>
<p> </p>
</div><p><p>Returns a list of all files (regular ones and symlinks) found from the 
root which do not match any of the specified suffixes, in the whole subtree 
(that is recursively).</p>

 <p>No excluded directories. Elements whose name is 
improperly encoded are managed according to the IfImproperEncoding parameter; 
if set to 'include', the return type of this function is the more general 
[any_file_path()], otherwise it is [file_path()].</p>

 All returned pathnames are relative to this root.
 For example ["./a.txt", "./tmp/b.txt"].
</p>

<h3 class="function"><a name="find_files_with_extension_from-2">find_files_with_extension_from/2</a></h3>
<div class="spec">
<p><tt>find_files_with_extension_from(RootDir::<a href="#type-any_directory_path">any_directory_path()</a>, Extension::<a href="#type-extension">extension()</a>) -&gt; [<a href="#type-file_path">file_path()</a>]</tt><br></p>
<p> </p>
</div><p><p>Returns a list of all files (regular ones and symlinks) found from the 
root with specified extension, in the whole subtree (that is recursively).</p>

 <p>All suffixes accepted, no excluded directories. Elements whose name is 
improperly encoded are notified thanks to a warning trace, and then are 
ignored.</p>

 All returned pathnames are relative to this root.
 For example ["./a.txt", "./tmp/b.txt"].
</p>

<h3 class="function"><a name="find_files_with_extension_from-3">find_files_with_extension_from/3</a></h3>
<div class="spec">
<p><tt>find_files_with_extension_from(RootDir::<a href="#type-any_directory_path">any_directory_path()</a>, Extension::<a href="#type-extension">extension()</a>, IfImproperEncoding::<a href="#type-improper_encoding_action">improper_encoding_action()</a>) -&gt; [<a href="#type-file_path">file_path()</a>]</tt><br></p>
<p> </p>
</div><p><p>Returns a list of all files (regular ones and symlinks) found from the 
root with specified extension, in the whole subtree (that is recursively).</p>

 <p>All suffixes accepted, no excluded directories. Elements whose name is 
improperly encoded are managed according to the IfImproperEncoding parameter; 
if set to 'include', the return type of this function is the more general 
[any_file_path()], otherwise it is [file_path()].</p>

 All returned pathnames are relative to this root.
 For example ["./a.txt", "./tmp/b.txt"].
</p>

<h3 class="function"><a name="find_links_from-1">find_links_from/1</a></h3>
<div class="spec">
<p><tt>find_links_from(RootDir::<a href="#type-any_directory_path">any_directory_path()</a>) -&gt; [<a href="#type-file_path">file_path()</a>]</tt><br></p>
<p> </p>
</div><p><p>Returns a list of all symlinks found from the root, in the whole subtree 
(that is recursively).</p>

 <p>All extensions and suffixes accepted, no excluded directories. Elements whose 
name is improperly encoded are notified thanks to a warning trace, and then 
are ignored.</p>

 All returned pathnames are relative to this root.
 For example ["./a.txt", "./tmp/b.txt"].
</p>

<h3 class="function"><a name="find_links_from-2">find_links_from/2</a></h3>
<div class="spec">
<p><tt>find_links_from(RootDir::<a href="#type-any_directory_path">any_directory_path()</a>, IfImproperEncoding::<a href="#type-improper_encoding_action">improper_encoding_action()</a>) -&gt; [<a href="#type-file_path">file_path()</a>]</tt><br></p>
<p> </p>
</div><p><p>Returns a list of all symlinks found from the root, in the whole subtree 
(that is recursively).</p>

 <p>All extensions and suffixes accepted, no excluded directories. Elements whose 
name is improperly encoded are managed according to the IfImproperEncoding 
parameter; if set to 'include', the return type of this function is the more 
general [any_file_path()], otherwise it is [file_path()].</p>

 All returned pathnames are relative to this root.
 For example ["./a.txt", "./tmp/b.txt"].
</p>

<h3 class="function"><a name="find_regular_files_from-1">find_regular_files_from/1</a></h3>
<div class="spec">
<p><tt>find_regular_files_from(RootDir::<a href="#type-any_directory_path">any_directory_path()</a>) -&gt; [<a href="#type-file_path">file_path()</a>]</tt><br></p>
<p> </p>
</div><p><p>Returns a list of all regular files (hence not including symlinks) found 
from the root, in the whole subtree (that is recursively).</p>

 <p>All extensions and suffixes accepted, no excluded directories. Elements whose 
name is improperly encoded are notified thanks to a warning trace, and then 
are ignored.</p>

 All returned pathnames are relative to this root.
 For example ["./a.txt", "./tmp/b.txt"].
</p>

<h3 class="function"><a name="from_permission_mask-1">from_permission_mask/1</a></h3>
<div class="spec">
<p><tt>from_permission_mask(Mask::<a href="#type-permission_mask">permission_mask()</a>) -&gt; [<a href="#type-permission">permission()</a>]</tt><br></p>
<p> </p>
</div><p>Decodes the specified permission mask into a list of the corresponding
 permissions.
</p>

<h3 class="function"><a name="get_base_path-1">get_base_path/1</a></h3>
<div class="spec">
<p><tt>get_base_path(AnyPath::<a href="#type-any_path">any_path()</a>) -&gt; <a href="#type-any_path">any_path()</a></tt><br></p>
<p> </p>
</div><p><p>Returns the complete leading, "directory" part of specified path, 
that is the one with all its element but the last one.</p>

 <p>For example "/aaa/bbb/ccc" =          
file_utils:get_base_path("/aaa/bbb/ccc/foobar.txt").</p>

 <p>Note that the return type is the same of the input path, i.e. plain string or 
binary string.</p>

 <p>Alias name for filename:dirname/1 (better in file_utils, and hopefully 
clearer).</p>

 See get_last_path_element/1 for the counterpart function.
</p>

<h3 class="function"><a name="get_bin_current_directory-0">get_bin_current_directory/0</a></h3>
<div class="spec">
<p><tt>get_bin_current_directory() -&gt; <a href="#type-bin_directory_path">bin_directory_path()</a></tt><br></p>
<p> </p>
</div><p><p>Returns the current directory, as a binary string.</p>

 Throws an exception on failure.
</p>

<h3 class="function"><a name="get_cache_directory-1">get_cache_directory/1</a></h3>
<div class="spec">
<p><tt>get_cache_directory(AppInfo::<a href="#type-any_app_info">any_app_info()</a>) -&gt; <a href="#type-directory_path">directory_path()</a></tt><br></p>
<p> </p>
</div><p>Returns the path location intended for the storage of transient data
 files that the specified application may perform on the local machine, that is
 any cache that it may use.
</p>

<h3 class="function"><a name="get_configuration_directory-1">get_configuration_directory/1</a></h3>
<div class="spec">
<p><tt>get_configuration_directory(AppInfo::<a href="#type-any_app_info">any_app_info()</a>) -&gt; <a href="#type-directory_path">directory_path()</a></tt><br></p>
<p> </p>
</div><p>Returns the path location intended for the storage of persistent
 configuration files that the specified application may perform on the local
 machine.
</p>

<h3 class="function"><a name="get_current_directory-0">get_current_directory/0</a></h3>
<div class="spec">
<p><tt>get_current_directory() -&gt; <a href="#type-directory_path">directory_path()</a></tt><br></p>
<p> </p>
</div><p><p>Returns the current directory, as a plain string.</p>

 Throws an exception on failure.
</p>

<h3 class="function"><a name="get_data_directory-1">get_data_directory/1</a></h3>
<div class="spec">
<p><tt>get_data_directory(AppInfo::<a href="#type-any_app_info">any_app_info()</a>) -&gt; <a href="#type-directory_path">directory_path()</a></tt><br></p>
<p> </p>
</div><p>Returns the path location intended for the storage of persistent data
 files that the specified application may perform on the local machine.
</p>

<h3 class="function"><a name="get_default_encoding-0">get_default_encoding/0</a></h3>
<div class="spec">
<p><tt>get_default_encoding() -&gt; <a href="system_utils.html#type-encoding">system_utils:encoding()</a></tt><br></p>
<p> </p>
</div><p><p>Returns the default recommended encoding, for example when needing to 
open a file for writing.</p>

 See the notes above in the 'Regarding encodings and Unicode' section, notably
 about the consequences of specifying an encoding at file opening (generally
 directly writing encoded content is safer and offers more control).
</p>

<h3 class="function"><a name="get_default_encoding_option-0">get_default_encoding_option/0</a></h3>
<div class="spec">
<p><tt>get_default_encoding_option() -&gt; <a href="system_utils.html#type-encoding_option">system_utils:encoding_option()</a></tt><br></p>
<p> </p>
</div><p><p>Returns the default recommended option encoding option, for example when 
needing to open a file for writing - should such an option be used.</p>

 See the notes above in the 'Regarding encodings and Unicode' section, notably
 about the consequences of specifying an encoding at file opening (generally
 directly writing encoded content is safer and offers more control).
</p>

<h3 class="function"><a name="get_dotted_extension_for-1">get_dotted_extension_for/1</a></h3>
<div class="spec">
<p><tt>get_dotted_extension_for(CompressionFormat::<a href="#type-compression_format">compression_format()</a>) -&gt; <a href="#type-dotted_extension">dotted_extension()</a></tt><br></p>
<p> </p>
</div><p>Returns the dotted file extension (e.g. ".xz", not just "xz")
 corresponding to filenames compressed with specified format.
</p>

<h3 class="function"><a name="get_extension-1">get_extension/1</a></h3>
<div class="spec">
<p><tt>get_extension(Filename::<a href="#type-file_path">file_path()</a>) -&gt; <a href="#type-extension">extension()</a> | no_extension</tt><br></p>
<p> </p>
</div><p><p>Returns the (last) extension of the specified file path.</p>

 For example "json" = get_extension("/home/joe/foobar.baz.json")
</p>

<h3 class="function"><a name="get_extension_for-1">get_extension_for/1</a></h3>
<div class="spec">
<p><tt>get_extension_for(CompressionFormat::<a href="#type-compression_format">compression_format()</a>) -&gt; <a href="#type-extension">extension()</a></tt><br></p>
<p> </p>
</div><p>Returns the file extension corresponding to filenames compressed with
 specified format.
</p>

<h3 class="function"><a name="get_extensions-1">get_extensions/1</a></h3>
<div class="spec">
<p><tt>get_extensions(Filename::<a href="#type-file_path">file_path()</a>) -&gt; [<a href="#type-extension">extension()</a>] | no_extension</tt><br></p>
<p> </p>
</div><p><p>Returns the (ordered) extension(s) of the specified file path.</p>

 For example ["baz", "json"] = get_extensions("/home/joe/foobar.baz.json")
</p>

<h3 class="function"><a name="get_extra_configuration_directories-1">get_extra_configuration_directories/1</a></h3>
<div class="spec">
<p><tt>get_extra_configuration_directories(AppInfo::<a href="#type-any_app_info">any_app_info()</a>) -&gt; [<a href="#type-directory_path">directory_path()</a>]</tt><br></p>
<p> </p>
</div><p>Returns the extra path locations intended for the storage of persistent
 configuration files that the specified application may perform on the local
 machine.
</p>

<h3 class="function"><a name="get_extra_data_directories-1">get_extra_data_directories/1</a></h3>
<div class="spec">
<p><tt>get_extra_data_directories(AppInfo::<a href="#type-any_app_info">any_app_info()</a>) -&gt; [<a href="#type-directory_path">directory_path()</a>]</tt><br></p>
<p> </p>
</div><p>Returns the extra path locations intended for the storage of persistent
 data files that the specified application may perform on the local machine.
</p>

<h3 class="function"><a name="get_first_existing_directory_in-1">get_first_existing_directory_in/1</a></h3>
<div class="spec">
<p><tt>get_first_existing_directory_in(DirPaths::[<a href="#type-any_directory_path">any_directory_path()</a>]) -&gt; <a href="#type-any_directory_path">any_directory_path()</a></tt><br></p>
<p> </p>
</div><p><p>Returns the first (if any) existing directory found in the specified 
list, or throws an exception if none is found.</p>

 <p>Each of the directory components involved may be an actual directory or a 
symbolic link.</p>

 Typically useful when having multiple possible paths depending on settings,
 only one of them being relevant.
</p>

<h3 class="function"><a name="get_group_of-1">get_group_of/1</a></h3>
<div class="spec">
<p><tt>get_group_of(Path::<a href="#type-any_path">any_path()</a>) -&gt; <a href="system_utils.html#type-group_id">system_utils:group_id()</a></tt><br></p>
<p> </p>
</div><p>Returns the group identifier (gid) of the group of the specified file
 entry.
</p>

<h3 class="function"><a name="get_image_extensions-0">get_image_extensions/0</a></h3>
<div class="spec">
<p><tt>get_image_extensions() -&gt; [<a href="#type-extension">extension()</a>]</tt><br></p>
<p> </p>
</div><p>Returns a list of the known file extensions that refer to image files.</p>

<h3 class="function"><a name="get_image_file_gif-1">get_image_file_gif/1</a></h3>
<div class="spec">
<p><tt>get_image_file_gif(Image::<a href="#type-file_name">file_name()</a>) -&gt; <a href="#type-path">path()</a></tt><br></p>
<p> </p>
</div><p>Returns the image path corresponding to the specified file.</p>

<h3 class="function"><a name="get_image_file_png-1">get_image_file_png/1</a></h3>
<div class="spec">
<p><tt>get_image_file_png(Image::<a href="#type-file_name">file_name()</a>) -&gt; <a href="#type-path">path()</a></tt><br></p>
<p> </p>
</div><p>Returns the image path corresponding to the specified file.</p>

<h3 class="function"><a name="get_last_modification_time-1">get_last_modification_time/1</a></h3>
<div class="spec">
<p><tt>get_last_modification_time(Path::<a href="#type-any_path">any_path()</a>) -&gt; <a href="time_utils.html#type-posix_seconds">time_utils:posix_seconds()</a></tt><br></p>
<p> </p>
</div><p><p>Returns the last time at which the content of specified file entry was 
modified (not counting attribute or permission changes), according to the 
filesystem.</p>

 Said timestamp will be expressed as an integer number of seconds since (or
 before) Unix time epoch, which is 1970-01-01 00:00 UTC.
</p>

<h3 class="function"><a name="get_last_path_element-1">get_last_path_element/1</a></h3>
<div class="spec">
<p><tt>get_last_path_element(AnyPath::<a href="#type-any_path">any_path()</a>) -&gt; <a href="#type-any_path_element">any_path_element()</a></tt><br></p>
<p> </p>
</div><p><p>Returns the final, "file" part of specified path, that is its last 
element, as a one-element path, corresponding either to a file or a directory.</p>

 <p>For example <code>&lt;&lt;"foobar.txt"&gt;&gt; =
          file_utils:get_last_path_element(&lt;&lt;"/aaa/bbb/ccc/foobar.txt"&gt;&gt;).</code></p>

 <p>Note that the return type is the same of the input path, i.e. plain string or 
binary string.</p>

 <p>Replacement name for filename:basename/1 (more convenient if in file_utils, 
and hopefully clearer).</p>

 See get_base_path/1 for the counterpart function.
</p>

<h3 class="function"><a name="get_log_directory-1">get_log_directory/1</a></h3>
<div class="spec">
<p><tt>get_log_directory(AppInfo::<a href="#type-any_app_info">any_app_info()</a>) -&gt; <a href="#type-directory_path">directory_path()</a></tt><br></p>
<p> </p>
</div><p>Returns the path location intended for the storage of transient log files
 that the specified application may perform on the local machine.
</p>

<h3 class="function"><a name="get_longest_common_path-1">get_longest_common_path/1</a></h3>
<div class="spec">
<p><tt>get_longest_common_path(DirPaths::[<a href="#type-any_path">any_path()</a>]) -&gt; {<a href="#type-any_path">any_path()</a>, [<a href="#type-any_path">any_path()</a>]}</tt><br></p>
<p> </p>
</div><p><p>Returns a pair made of the longest path common to all specified directory 
paths, and the corresponding suffixes, that is an (unordered) list of the 
input paths (as binaries) once the common prefix elements have been removed.</p>

 <p>Note: operates per-directory (as a whole), not per-character.</p>

 <p>For example get_longest_common_path(["/tmp/aa/bb/c1/foobar.txt",                              
"/tmp/aa/bb/c2/foobar.txt"])      
returns: 
{"/tmp/aa/bb", ["c1","foobar.txt"], ["c2","foobar.txt"]]}</p>

 Like text_utils:get_longest_common_prefix/1, except that operates on whole
 path elements, not individual characters.
</p>

<h3 class="function"><a name="get_non_clashing_entry_name_from-1">get_non_clashing_entry_name_from/1</a></h3>
<div class="spec">
<p><tt>get_non_clashing_entry_name_from(Path::<a href="#type-any_path">any_path()</a>) -&gt; <a href="#type-any_path">any_path()</a></tt><br></p>
<p> </p>
</div><p><p>Returns a path deriving from the specified one (and of the same type) so 
that it is unique, meaning that it does not clash with any pre-existing entry.</p>

 <p>Note: of course multiple, parallel calls to this function with the same base 
path will result in potential race conditions and risks of collisions.</p>

 See also basic_utils:get_unix_process_specific_string/0.
</p>

<h3 class="function"><a name="get_owner_of-1">get_owner_of/1</a></h3>
<div class="spec">
<p><tt>get_owner_of(Path::<a href="#type-any_path">any_path()</a>) -&gt; <a href="system_utils.html#type-user_id">system_utils:user_id()</a></tt><br></p>
<p> </p>
</div><p>Returns the user identifier (uid) of the owner of the specified file
 entry.
</p>

<h3 class="function"><a name="get_permissions_of-1">get_permissions_of/1</a></h3>
<div class="spec">
<p><tt>get_permissions_of(EntryPath::<a href="#type-any_path">any_path()</a>) -&gt; [<a href="#type-permission">permission()</a>]</tt><br></p>
<p> </p>
</div><p>Returns the (UNIX) permissions associated to the specified filesystem
 entry.
</p>

<h3 class="function"><a name="get_shortest_unique_ending_paths-2">get_shortest_unique_ending_paths/2</a></h3>
<div class="spec">
<p><tt>get_shortest_unique_ending_paths(Path::<a href="#type-any_path">any_path()</a>, SecondPath::<a href="#type-any_path">any_path()</a>) -&gt; {<a href="#type-any_path">any_path()</a>, <a href="#type-any_path">any_path()</a>}</tt><br></p>
<p> </p>
</div><p><p>Returns a pair made of the shortest ending paths that allows to 
discriminate between the specified paths (expected to be of the same string 
type).</p>

 For example get_shortest_unique_ending_paths("/aa/bb/foo/bar/hello.txt",
                                      "/tmp/buzz/frob/aa/foo/bar/hello.txt")
      returns: {"bb/foo/bar/hello.txt", "aa/foo/bar/hello.txt"}
</p>

<h3 class="function"><a name="get_size-1">get_size/1</a></h3>
<div class="spec">
<p><tt>get_size(FilePath::<a href="#type-any_file_path">any_file_path()</a>) -&gt; <a href="system_utils.html#type-byte_size">system_utils:byte_size()</a></tt><br></p>
<p> </p>
</div><p>Returns the size, in bytes, of the specified file.</p>

<h3 class="function"><a name="get_type_of-1">get_type_of/1</a></h3>
<div class="spec">
<p><tt>get_type_of(Path::<a href="#type-any_path">any_path()</a>) -&gt; <a href="#type-entry_type">entry_type()</a></tt><br></p>
<p> </p>
</div><p><p>Returns the (direct) type of the specified file entry (hence may return 
'symlink' if the path of a symbolic link is specified).</p>

 See resolve_type_of/1 to go through symbolic links, and return the actual,
 ultimate entry type resolved.
</p>

<h3 class="function"><a name="has_matching_suffix-2">has_matching_suffix/2</a></h3>
<div class="spec">
<p><tt>has_matching_suffix(Path::<a href="#type-any_path">any_path()</a>, Suffixes::[<a href="#type-any_suffix">any_suffix()</a>]) -&gt; boolean()</tt><br></p>
<p> </p>
</div><p><p>Tells whether specified path matches one of the specified suffixes.</p>

 (exported helper)</p>

<h3 class="function"><a name="hide-1">hide/1</a></h3>
<div class="spec">
<p><tt>hide(ToHidePath::<a href="#type-any_file_path">any_file_path()</a>) -&gt; <a href="#type-any_file_path">any_file_path()</a></tt><br></p>
<p> </p>
</div><p><p>Hides the specified file: renames it to a conventionally-deriving name, 
to have it out of the way; throws an exception if the resulting file already 
exists.</p>

 Returns its new name.
</p>

<h3 class="function"><a name="hide-2">hide/2</a></h3>
<div class="spec">
<p><tt>hide(ToHidePath::<a href="#type-any_file_path">any_file_path()</a>, HidingSuffix::<a href="#type-any_string">any_string()</a>) -&gt; <a href="#type-any_file_path">any_file_path()</a></tt><br></p>
<p> </p>
</div><p><p>Hides the specified file: renames it based on the specified suffix, to 
have it out of the way; throws an exception if the resulting file already 
exists.</p>

 Returns its new name.
</p>

<h3 class="function"><a name="hide_overwriting-1">hide_overwriting/1</a></h3>
<div class="spec">
<p><tt>hide_overwriting(ToHidePath::<a href="#type-any_file_path">any_file_path()</a>) -&gt; <a href="#type-any_file_path">any_file_path()</a></tt><br></p>
<p> </p>
</div><p><p>Hides the specified file: renames it to a conventionally-deriving name, 
to have it out of the way; if the resulting file already exists, it is 
overwritten.</p>

 Returns its new name.
</p>

<h3 class="function"><a name="hide_overwriting-2">hide_overwriting/2</a></h3>
<div class="spec">
<p><tt>hide_overwriting(ToHidePath::<a href="#type-any_file_path">any_file_path()</a>, HidingSuffix::<a href="#type-any_string">any_string()</a>) -&gt; <a href="#type-any_file_path">any_file_path()</a></tt><br></p>
<p> </p>
</div><p><p>Hides the specified file: renames it to a conventionally-deriving name, 
to have it out of the way; if the resulting file already exists, it is 
overwritten.</p>

 Returns its new name.
</p>

<h3 class="function"><a name="is_absolute_path-1">is_absolute_path/1</a></h3>
<div class="spec">
<p><tt>is_absolute_path(AnyPath::<a href="#type-any_path">any_path()</a>) -&gt; boolean()</tt><br></p>
<p> </p>
</div><p><p>Tells whether the specified path is an absolute one.</p>

 A path is deemed absolute iff it starts with "/".
</p>

<h3 class="function"><a name="is_directory-1">is_directory/1</a></h3>
<div class="spec">
<p><tt>is_directory(Path::<a href="#type-any_path">any_path()</a>) -&gt; boolean()</tt><br></p>
<p> </p>
</div><p><p>Returns whether the specified path entry, supposedly existing, is a 
directory.</p>

 If the specified entry happens not to exist, a {non_existing_entry, Path}
 exception will be thrown.
</p>

<h3 class="function"><a name="is_existing_directory-1">is_existing_directory/1</a></h3>
<div class="spec">
<p><tt>is_existing_directory(Path::<a href="#type-any_path">any_path()</a>) -&gt; boolean()</tt><br></p>
<p> </p>
</div><p><p>Returns whether the specified path entry exists and is a directory.</p>

 Returns true or false, and cannot trigger an exception.
</p>

<h3 class="function"><a name="is_existing_directory_or_link-1">is_existing_directory_or_link/1</a></h3>
<div class="spec">
<p><tt>is_existing_directory_or_link(Path::<a href="#type-any_path">any_path()</a>) -&gt; boolean()</tt><br></p>
<p> </p>
</div><p><p>Returns whether the specified path entry exists and is a directory or a 
symbolic link.</p>

 Returns true or false, and cannot trigger an exception.
</p>

<h3 class="function"><a name="is_existing_file-1">is_existing_file/1</a></h3>
<div class="spec">
<p><tt>is_existing_file(Path::<a href="#type-any_path">any_path()</a>) -&gt; boolean()</tt><br></p>
<p> </p>
</div><p><p>Returns whether the specified path entry exists and is a regular file.</p>

 Returns true or false, and cannot trigger an exception.
</p>

<h3 class="function"><a name="is_existing_file_or_link-1">is_existing_file_or_link/1</a></h3>
<div class="spec">
<p><tt>is_existing_file_or_link(Path::<a href="#type-any_path">any_path()</a>) -&gt; boolean()</tt><br></p>
<p> </p>
</div><p><p>Returns whether the specified path entry exists and is either a regular 
file or a symbolic link.</p>

 Returns true or false, and cannot trigger an exception.
</p>

<h3 class="function"><a name="is_existing_link-1">is_existing_link/1</a></h3>
<div class="spec">
<p><tt>is_existing_link(Path::<a href="#type-any_path">any_path()</a>) -&gt; boolean()</tt><br></p>
<p> </p>
</div><p><p>Returns whether the specified path entry exists and is a symbolic file.</p>

 Returns true or false, and cannot trigger an exception.
</p>

<h3 class="function"><a name="is_file-1">is_file/1</a></h3>
<div class="spec">
<p><tt>is_file(Path::<a href="#type-any_path">any_path()</a>) -&gt; boolean()</tt><br></p>
<p> </p>
</div><p><p>Returns whether the specified path entry, supposedly existing, is a 
regular file.</p>

 <p>If the specified entry happens not to exist, a {non_existing_entry, EntryName} 
exception will be thrown.</p>

 Not to be confused with is_file_reference/1, which deals with opened file IO
 devices.
</p>

<h3 class="function"><a name="is_file_reference-1">is_file_reference/1</a></h3>
<div class="spec">
<p><tt>is_file_reference(FilePid::term()) -&gt; boolean()</tt><br></p>
<p> </p>
</div><p><p>Tells whether the specified term is a file reference (pseudo-guard).</p>

 Not to be confused with is_file/1, which is about file paths.
</p>

<h3 class="function"><a name="is_leaf_among-2">is_leaf_among/2</a></h3>
<div class="spec">
<p><tt>is_leaf_among(LeafName::<a href="#type-leaf_name">leaf_name()</a>, PathList::[<a href="#type-path">path()</a>]) -&gt; false | <a href="#type-path">path()</a></tt><br></p>
<p> </p>
</div><p><p>Tells whether specified basename (e.g. a pathless filename) is among the 
specified list of full paths; returns either false or the first full path 
found corresponding to that leaf element.</p>

 For example
  false = file_utils:is_leaf_among( "xx", [ "a/b/c/yy", "d/e/zz"] )
  "a/b/c/xx"  = file_utils:is_leaf_among( "xx", [ "a/b/c/xx", "d/e/zz"] )
</p>

<h3 class="function"><a name="is_link-1">is_link/1</a></h3>
<div class="spec">
<p><tt>is_link(Path::<a href="#type-any_path">any_path()</a>) -&gt; boolean()</tt><br></p>
<p> </p>
</div><p><p>Returns whether the specified path entry, supposedly existing, is a 
symbolic file.</p>

 Returns true or false, and cannot trigger an exception.
</p>

<h3 class="function"><a name="is_owner_executable-1">is_owner_executable/1</a></h3>
<div class="spec">
<p><tt>is_owner_executable(Path::<a href="#type-any_path">any_path()</a>) -&gt; boolean()</tt><br></p>
<p> </p>
</div><p><p>Returns whether the specified path entry (can be either a regular file or 
a symbolic link) exists and is executable for its current owner - not telling 
anything about whether the current user can execute it.</p>

 <p>Returns true or false, and cannot trigger an exception.</p>

 See also: is_owner_writable/1.
</p>

<h3 class="function"><a name="is_owner_readable-1">is_owner_readable/1</a></h3>
<div class="spec">
<p><tt>is_owner_readable(Path::<a href="#type-any_path">any_path()</a>) -&gt; boolean()</tt><br></p>
<p> </p>
</div><p><p>Returns whether the specified path entry (can be either a regular file or 
a symbolic link) exists and is readable for its current owner - not telling 
anything about whether the current user can read it.</p>

 <p>Returns true or false, and cannot trigger an exception.</p>

 See also: is_user_readable/1.
</p>

<h3 class="function"><a name="is_owner_writable-1">is_owner_writable/1</a></h3>
<div class="spec">
<p><tt>is_owner_writable(Path::<a href="#type-any_path">any_path()</a>) -&gt; boolean()</tt><br></p>
<p> </p>
</div><p><p>Returns whether the specified path entry (can be either a regular file or 
a symbolic link) exists and is writable for its current owner) - not telling 
anything about whether the current user can write it.</p>

 <p>Returns true or false, and cannot trigger an exception.</p>

 See also: is_user_writable/1.
</p>

<h3 class="function"><a name="is_user_executable-1">is_user_executable/1</a></h3>
<div class="spec">
<p><tt>is_user_executable(Path::<a href="#type-any_path">any_path()</a>) -&gt; boolean()</tt><br></p>
<p> </p>
</div><p><p>Returns whether the specified path entry exists and is executable for the 
current user (can be either a regular file or a symbolic link).</p>

 <p>Returns true or false, and cannot trigger an exception.</p>

 See also: is_owner_executable/1.
</p>

<h3 class="function"><a name="is_user_readable-1">is_user_readable/1</a></h3>
<div class="spec">
<p><tt>is_user_readable(Path::<a href="#type-any_path">any_path()</a>) -&gt; boolean()</tt><br></p>
<p> </p>
</div><p><p>Returns whether the specified path entry (can be either a regular file or 
a symbolic link) exists and is readable for the current user .</p>

 Returns true or false, and cannot trigger an exception.
</p>

<h3 class="function"><a name="is_user_writable-1">is_user_writable/1</a></h3>
<div class="spec">
<p><tt>is_user_writable(Path::<a href="#type-any_path">any_path()</a>) -&gt; boolean()</tt><br></p>
<p> </p>
</div><p><p>Returns whether the specified path entry (can be either a regular file or 
a symbolic link) exists and is writable for the current user.</p>

 Returns true or false, and cannot trigger an exception.
</p>

<h3 class="function"><a name="join-1">join/1</a></h3>
<div class="spec">
<p><tt>join(ComponentList::[<a href="#type-any_path_element">any_path_element()</a>]) -&gt; <a href="#type-path">path()</a></tt><br></p>
<p> </p>
</div><p><p>Joins the specified list of path elements.</p>

 <p>This function has been added back to this module; filename:join(Components) 
could be used instead (at least to some extent), however filename:join(["", 
"my_dir"]) results in "/my_dir", whereas often we would want "my_dir" instead 
- which is returned by our function; moreover, if one of the components 
includes an absolute path (such as "/xxx" with Unix conventions), the 
preceding components, if any, were removed from the result (which does not 
seem desirable); here we throw an exception instead.</p>

 <p>So we deem our version simpler and less prone to surprise (least 
astonishment).</p>

 <p>Plain and binary strings can be freely used as arguments, and a plain string 
is returned in all cases.</p>

 See split/1 for the reverse operation.
</p>

<h3 class="function"><a name="join-2">join/2</a></h3>
<div class="spec">
<p><tt>join(FirstPath::<a href="#type-any_path">any_path()</a>, SecondPath::<a href="#type-any_path">any_path()</a>) -&gt; <a href="#type-path">path()</a></tt><br></p>
<p> </p>
</div><p><p>Joins the two specified path elements, returns a corresponding plain 
string.</p>

 <p>This function has been added back to this module; filename:join(Name1, Name2) 
could be used instead (at least to some extent); however filename:join("", 
"my_dir") results in "/my_dir", whereas often we would want "my_dir" - which 
is returned by our function ; moreover filename:join(SomePath, AbsPath=[ 
?directory_separator | _ ]) returns AbsPath, dropping SomePath for some reason 
(which does not seem desirable); here we throw an exception instead.</p>

 <p>So we deem our version simpler and less prone to surprise (least 
astonishment).</p>

 <p>Plain and binary strings can be freely used as arguments; a plain string is 
returned in all cases.</p>

 <p>See split/1 for the reverse operation.</p>

 Prefer bin_join/2 if having to possibly deal with so-called "raw filenames".
</p>

<h3 class="function"><a name="latin1_file_to_unicode-1">latin1_file_to_unicode/1</a></h3>
<div class="spec">
<p><tt>latin1_file_to_unicode(AnyFilePath::<a href="#type-any_file_path">any_file_path()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p>Converts in-place the specified file, whose current encoding is expected
 to be Latin1, to Unicode.
</p>

<h3 class="function"><a name="list_dir_elements-1">list_dir_elements/1</a></h3>
<div class="spec">
<p><tt>list_dir_elements(DirName::<a href="#type-directory_name">directory_name()</a>) -&gt; {[<a href="#type-file_name">file_name()</a>], [<a href="#type-file_name">file_name()</a>], [<a href="#type-directory_name">directory_name()</a>], [<a href="#type-file_name">file_name()</a>], [<a href="#type-file_name">file_name()</a>]}</tt><br></p>
<p> </p>
</div><p><p>Returns a tuple containing five lists corresponding to the per-type 
dispatching of all filesystem elements local to specified directory (hence not 
recursively traversed), namely: {RegularFiles, Symlinks, Directories, 
OtherFiles, Devices}.</p>

 <p>If a raw filename is found (i.e. a file element whose name is not properly 
Unicode-encoded), a warning trace is emitted and the corresponding file 
elemen</p>

 Note that:
 - symbolic links may or may not be dead
 - only plain strings are returned (any raw filename found will trigger a
 warning trace and then will be ignored)
</p>

<h3 class="function"><a name="list_dir_elements-2">list_dir_elements/2</a></h3>
<div class="spec">
<p><tt>list_dir_elements(DirName::<a href="#type-directory_name">directory_name()</a>, ImproperEncodingAction::<a href="#type-improper_encoding_action">improper_encoding_action()</a>) -&gt; {[<a href="#type-any_file_name">any_file_name()</a>], [<a href="#type-any_file_name">any_file_name()</a>], [<a href="#type-any_directory_name">any_directory_name()</a>], [<a href="#type-any_file_name">any_file_name()</a>], [<a href="#type-any_file_name">any_file_name()</a>]}</tt><br></p>
<p> </p>
</div><p><p>Returns a tuple containing five lists corresponding to the per-type 
dispatching of all filesystem elements local to specified directory (hence not 
recursively traversed), namely: {RegularFiles, Symlinks, Directories, 
OtherFiles, Devices}.</p>

 <p>If a raw filename is found (i.e. a file element whose name is not properly 
Unicode-encoded), ImproperEncodingAction will determine how it will be 
handled.</p>

 Note that:
 - symbolic links may or may not be dead
 - generally the returned elements are strings, yet, if ImproperEncodingAction
 is 'include', binaries may also returned, should raw ("incorrectly-encoded")
 filenames be found (they are then returned verbatim, short of being able to
 stringify them)
</p>

<h3 class="function"><a name="list_permission_pairs-0">list_permission_pairs/0</a></h3>
<div class="spec">
<p><tt>list_permission_pairs() -&gt; [{<a href="#type-permission">permission()</a>, <a href="#type-permission_mask">permission_mask()</a>}]</tt><br></p>
<p> </p>
</div><p>Lists all known permission types, as {Perm,Mask} pairs.</p>

<h3 class="function"><a name="make_relative-1">make_relative/1</a></h3>
<div class="spec">
<p><tt>make_relative(Path::<a href="#type-any_path">any_path()</a>) -&gt; <a href="#type-any_path">any_path()</a></tt><br></p>
<p> </p>
</div><p>Returns a version of the specified path that is relative to the current
 directory; returns the same type (plain or binary string) as the one of the
 specified path.
</p>

<h3 class="function"><a name="make_relative-2">make_relative/2</a></h3>
<div class="spec">
<p><tt>make_relative(Path::<a href="#type-any_path">any_path()</a>, RefDir::<a href="#type-any_directory_path">any_directory_path()</a>) -&gt; <a href="#type-any_path">any_path()</a></tt><br></p>
<p> </p>
</div><p>Returns a version of the first specified path that is relative to the
 specified second reference directory; returns the same type (plain or binary
 string) as the one of the first specified path.
</p>

<h3 class="function"><a name="move_file-2">move_file/2</a></h3>
<div class="spec">
<p><tt>move_file(SourceFilePath::<a href="#type-any_file_path">any_file_path()</a>, DestinationFilePath::<a href="#type-any_file_path">any_file_path()</a>) -&gt; <a href="#type-any_file_path">any_file_path()</a></tt><br></p>
<p> </p>
</div><p><p>Moves the specified file or symbolic link so that it is now designated by 
specified path.</p>

 <p>Note:  
- no check that source is a file or symlink (e.g. not a directory) is done  
- destination is a file path, not a directory path, and it is expected not to  
exist already</p>

 Returns, for convenience, the new path.
</p>

<h3 class="function"><a name="normalise_path-1">normalise_path/1</a></h3>
<div class="spec">
<p><tt>normalise_path(Path::<a href="#type-path">path()</a>) -&gt; <a href="#type-path">path()</a></tt><br></p><p><tt>normalise_path(Path::<a href="#type-bin_path">bin_path()</a>) -&gt; <a href="#type-bin_path">bin_path()</a></tt><br></p>
<p> </p>
<p> </p>
</div><p><p>Normalises specified path (canonicalises it), by translating it so that 
no intermediate, superfluous '.' or '..' is present afterwards.</p>

 <p>For example, "/home/garfield/../lisa/./src/.././tube" shall be normalised in 
"/home/lisa/tube".</p>

 Returns a path of the same string type as the specified parameter.
</p>

<h3 class="function"><a name="open-2">open/2</a></h3>
<div class="spec">
<p><tt>open(AnyFilePath::<a href="#type-any_file_path">any_file_path()</a>, Options::[<a href="#type-file_open_mode">file_open_mode()</a>]) -&gt; <a href="#type-file">file()</a></tt><br></p>
<p> </p>
</div><p><p>Opens the file corresponding to the specified path, with the specified
 list of options (as listed for file:open/2 in
 <a href="http://erlang.org/doc/man/file.html#open-2" target="_top"><tt>http://erlang.org/doc/man/file.html#open-2</tt></a>, that is: read, write, append, 
exclusive, raw, etc).</p>

 <p>See read_terms/1 if planning to read that content as terms later, notably with 
regard to encoding.</p>

 <p>Returns the file reference, or throws an exception.</p>

 <p>Will attempt to open the specified file only once, as looping endlessly does 
not seem a viable solution right now (risk of exhausting the descriptors, 
making the VM fail for example when loading a new BEAM).</p>

 <p>As soon as a file is opened for writing, a corresponding empty file appears in 
the filesystem.</p>

 For all questions in link with the Unicode support or the use of the 'raw'
 option, read the 'Regarding encodings and Unicode' section at the top of this
 file.
</p>

<h3 class="function"><a name="open-3">open/3</a></h3>
<div class="spec">
<p><tt>open(AnyFilePath::<a href="#type-any_file_path">any_file_path()</a>, Options::[<a href="#type-file_open_mode">file_open_mode()</a>], AttemptMode::try_once | try_endlessly | try_endlessly_safer) -&gt; <a href="#type-file">file()</a></tt><br></p>
<p> </p>
</div><p><p>Opens the file corresponding to the specified path (first parameter) with
 the specified list of options (second parameter; refer to file:open/2 for
 detailed documentation, see <a href="http://erlang.org/doc/man/file.html#open-2" target="_top"><tt>http://erlang.org/doc/man/file.html#open-2</tt></a>).</p>

 <p>Third parameter is the "attempt mode", either 'try_once', 'try_endlessly' or 
'try_endlessly_safer', depending respectively on whether we want to try to 
open the file once (no other attempt will be made), endlessly (until a file 
descriptor can be gained), possibly with a safer setting.</p>

 <p>Returns the file reference, or throws an exception.</p>

 <p>Will try to obtain a file descriptor iteratively (and endlessly) with 
process-specific random waitings, should no descriptor be available.</p>

 <p>A risk of that approach is that all available file descriptors will be 
taken, thus potentially preventing other processes (including the VM itself) 
to perform any file operation, like loading a new BEAM, e.g. 
""" 
File operation error: system_limit. Target: 
lib/erlang/lib/kernel-x.y.z/ebin/timer.beam. Function: get_file. 
Process: code_server. 
"""</p>

 <p>This is done in order to support situations where potentially more Erlang 
processes than available file descriptors try to access to files. An effort is 
made to desynchronize these processes to smooth the use of descriptors.</p>

 For all questions in link with the Unicode support or the use of the 'raw'
 option, read the 'Regarding encodings and Unicode' section at the top of this
 file.
</p>

<h3 class="function"><a name="path_to_variable_name-1">path_to_variable_name/1</a></h3>
<div class="spec">
<p><tt>path_to_variable_name(Filename::<a href="#type-path">path()</a>) -&gt; <a href="#type-ustring">ustring()</a></tt><br></p>
<p> </p>
</div><p><p>Converts specified path (full filename, like '/home/jack/test.txt' or 
'./media/test.txt') into a variable name licit in most programming languages 
(e.g. C/C++).</p>

 Rule here is:
  - variable name starts with a prefix, user-supplied or the default one
  - any leading './' is removed
  - '-' becomes '_'
  - '.' becomes '_'
  - '/' becomes '_'
</p>

<h3 class="function"><a name="path_to_variable_name-2">path_to_variable_name/2</a></h3>
<div class="spec">
<p><tt>path_to_variable_name(T::<a href="#type-path">path()</a>, Prefix::<a href="#type-ustring">ustring()</a>) -&gt; <a href="#type-ustring">ustring()</a></tt><br></p>
<p> </p>
</div><p><p>Converts specified path (full filename, like '/home/jack/test.txt' or 
'./media/test.txt') into a variable name licit in most programming languages 
(e.g. C/C++), based on specified prefix.</p>


 Removes any leading './'.</p>

<h3 class="function"><a name="read-2">read/2</a></h3>
<div class="spec">
<p><tt>read(File::<a href="#type-file">file()</a>, Count::<a href="basic_utils.html#type-count">basic_utils:count()</a>) -&gt; {ok, <a href="#type-ustring">ustring()</a> | binary()} | eof</tt><br></p>
<p> </p>
</div><p><p>Reads the specified number of bytes/characters from the specified file.</p>

 <p>Returns either {ok, Data} if at least some data could be read, or eof if at 
least one element was to read and end of file was reached before anything at 
all could be read.</p>

 Throws an exception on failure.
</p>

<h3 class="function"><a name="read_etf_file-1">read_etf_file/1</a></h3>
<div class="spec">
<p><tt>read_etf_file(AnyFilePath::<a href="#type-any_file_path">any_file_path()</a>) -&gt; [term()]</tt><br></p>
<p> </p>
</div><p><p>Reads the specified file, supposedly in ETF format (Erlang Term Format): 
tries to parse a list of terms (one per line, terminating with a dot) from it 
(as file:consult/1 does), and returns it. Lines starting with '%' are ignored 
(just considered as comments).</p>

 <p>If expecting to read UTF-8 content from a file, it should:</p>

  <p>- have been then opened for writing typically while including the {encoding,  
utf8} option, or have been written with content already properly encoded  
(it may be more reliable that way)</p>

  <p>- start with a '%% -*- coding: utf-8 -*-' header</p>

 <p>See http://myriad.esperide.org/#etf for more details.</p>

 Throws an exception on error.
</p>

<h3 class="function"><a name="read_lines-1">read_lines/1</a></h3>
<div class="spec">
<p><tt>read_lines(FilePath::<a href="#type-any_file_path">any_file_path()</a>) -&gt; [<a href="#type-ustring">ustring()</a>]</tt><br></p>
<p> </p>
</div><p><p>Reads the content of the specified file, expected to be a text one, based 
on its filename specified as any kind of string (plain, binary, atom, etc) and 
returns its content as a list of plain strings, or throws an exception on 
failure.</p>

 Each returned line has any (trailing) newline(s) removed (knowing that the
 last one may or may not have a newline). See
 <a href="https://erlang.org/doc/man/file.html#read_line-1" target="_top"><tt>https://erlang.org/doc/man/file.html#read_line-1</tt></a> for more details regarding
 end-of-line characters.
</p>

<h3 class="function"><a name="read_terms-1">read_terms/1</a></h3>
<div class="spec">
<p><tt>read_terms(AnyFilePath::<a href="#type-any_file_path">any_file_path()</a>) -&gt; [term()]</tt><br></p>
<p> </p>
</div><p><p>Reads the specified file supposedly in ETF format (Erlang Term Format): 
tries to parse a list of terms (one per line, terminating with a dot) from it 
(as file:consult/1 does), and returns it. Lines starting with '%' are ignored 
(just considered as comments).</p>

 <p>If expecting to read UTF-8 content from a file, it should:</p>

  <p>- have been then opened for writing typically while including the {encoding,  
utf8} option, or have been written with content already properly encoded  
(it may be more reliable that way)</p>

  <p>- start with a '%% -*- coding: utf-8 -*-' header</p>

 <p>See http://myriad.esperide.org/#etf for more details.</p>

 Throws an exception on error.
</p>

<h3 class="function"><a name="read_whole-1">read_whole/1</a></h3>
<div class="spec">
<p><tt>read_whole(FilePath::<a href="#type-any_file_path">any_file_path()</a>) -&gt; binary()</tt><br></p>
<p> </p>
</div><p><p>Reads the content of the specified file, based on its filename specified 
as any kind of string (plain, binary, atom, etc), and returns the 
corresponding binary, or throws an exception on failure.</p>

 See also: read_terms/1 to read directly Erlang terms instead.
</p>

<h3 class="function"><a name="remove_directories-1">remove_directories/1</a></h3>
<div class="spec">
<p><tt>remove_directories(DirectoryPaths::[<a href="#type-any_directory_path">any_directory_path()</a>]) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Removes the specified (possibly non-empty) directories as a whole 
(i.e. including its full content), recursively (so: behaves mostly like the 
'rm -rf ' shell command; of course to use with care).</p>

 Note that if any unusual file entry is found in the tree (e.g. device or file
 that is neither regular nor a symbolic link), the operation will stop on error
 (whereas elements may already have been removed).
</p>

<h3 class="function"><a name="remove_directories_if_existing-1">remove_directories_if_existing/1</a></h3>
<div class="spec">
<p><tt>remove_directories_if_existing(DirectoryPaths::[<a href="#type-any_directory_path">any_directory_path()</a>]) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Removes, if they exist, the specified (possibly non-empty) directories as 
a whole (i.e. including its full content), recursively (so: behaves mostly 
like the 'rm -rf ' shell command; of course to use with care).</p>

 Note that if any unusual file entry is found in the tree (e.g. device or file
 that is neither regular nor a symbolic link), the operation will stop on error
 (whereas elements may already have been removed).
</p>

<h3 class="function"><a name="remove_directory-1">remove_directory/1</a></h3>
<div class="spec">
<p><tt>remove_directory(DirectoryPath::<a href="#type-any_directory_path">any_directory_path()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Removes the specified (possibly non-empty) directory as a whole 
(i.e. including its full content), recursively (so: behaves mostly like the 
'rm -rf ' shell command; of course to use with care).</p>

 Note that if any unusual file entry is found in the tree (e.g. device or file
 that is neither regular nor a symbolic link), the operation will stop on error
 (whereas elements may already have been removed).
</p>

<h3 class="function"><a name="remove_directory_if_existing-1">remove_directory_if_existing/1</a></h3>
<div class="spec">
<p><tt>remove_directory_if_existing(DirectoryPath::<a href="#type-any_directory_path">any_directory_path()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Removes, if it exists, the specified (possibly non-empty) directory as a 
whole (i.e. including its full content), recursively (so: behaves mostly like 
the 'rm -rf ' shell command; of course to use with care).</p>

 Note that if any unusual file entry is found in the tree (e.g. device or file
 that is neither regular nor a symbolic link), the operation will stop on error
 (whereas elements may already have been removed).
</p>

<h3 class="function"><a name="remove_empty_directory-1">remove_empty_directory/1</a></h3>
<div class="spec">
<p><tt>remove_empty_directory(AnyDirPath::<a href="#type-any_directory_path">any_directory_path()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p>Removes the specified directory, which must be empty (so: behaves mostly
 like the 'rmdir' shell command).
</p>

<h3 class="function"><a name="remove_empty_path-1">remove_empty_path/1</a></h3>
<div class="spec">
<p><tt>remove_empty_path(DirectoryPath::<a href="#type-any_directory_path">any_directory_path()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Removes all (supposedly) empty directories pertaining to the specified 
local, relative directory path, that is this path (e.g. a/b/c) and all its 
ancestors (hence a/b and a are - if empty - removed as well, and none of their 
possible siblings of course); so behaves mostly like the 'rmdir --parents' 
shell command.</p>

 Note: does not remove an (empty) tree, just a given directory and its local
 ancestors.
</p>

<h3 class="function"><a name="remove_empty_tree-1">remove_empty_tree/1</a></h3>
<div class="spec">
<p><tt>remove_empty_tree(DirectoryPath::<a href="#type-any_directory_path">any_directory_path()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p>Removes all (supposedly) empty directories found from specified
 directory, expected to be the root of a tree that contains only (possibly
 nested) directories (and no other kind of filesystem entry).
</p>

<h3 class="function"><a name="remove_extension-1">remove_extension/1</a></h3>
<div class="spec">
<p><tt>remove_extension(FilePath::<a href="#type-file_path">file_path()</a>) -&gt; <a href="#type-file_path">file_path()</a></tt><br></p>
<p> </p>
</div><p><p>Removes the (last) extension (regardless of its actual value) of the 
specified file path.</p>

 For example "/home/jack/rosie.tmp" =
 remove_extension("/home/jack/rosie.tmp.ttf")
</p>

<h3 class="function"><a name="remove_extension-2">remove_extension/2</a></h3>
<div class="spec">
<p><tt>remove_extension(FilePath::<a href="#type-file_path">file_path()</a>, ExpectedExtension::<a href="#type-extension">extension()</a>) -&gt; <a href="#type-file_path">file_path()</a></tt><br></p>
<p> </p>
</div><p><p>Checks that the (last) extension of the specified file path is the 
specified one, and returns that path once this extension has been removed.</p>

 For example "/home/jack/rosie" = remove_extension("/home/jack/rosie.tmp.ttf",
 "ttf")
</p>

<h3 class="function"><a name="remove_file-1">remove_file/1</a></h3>
<div class="spec">
<p><tt>remove_file(FilePath::<a href="#type-any_file_path">any_file_path()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Removes (deletes) the specified file (be them regular files or symbolic 
links), specified as any kind of string.</p>

 Throws an exception if any problem occurs (e.g. the file does not exist, or
 could not be removed for any reason).
</p>

<h3 class="function"><a name="remove_file_if_existing-1">remove_file_if_existing/1</a></h3>
<div class="spec">
<p><tt>remove_file_if_existing(FilePath::<a href="#type-any_file_path">any_file_path()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p>Removes the specified regular file, specified as any kind of string, iff
 it is already existing, otherwise does nothing.
</p>

<h3 class="function"><a name="remove_file_or_link_if_existing-1">remove_file_or_link_if_existing/1</a></h3>
<div class="spec">
<p><tt>remove_file_or_link_if_existing(FileOrLinkPath::<a href="#type-any_file_path">any_file_path()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Removes (deletes) the specified file (regular or symbolic link), 
specified as any kind of string, iff it is already existing, otherwise does 
nothing.</p>

 Throws an exception if any problem occurs.
</p>

<h3 class="function"><a name="remove_files-1">remove_files/1</a></h3>
<div class="spec">
<p><tt>remove_files(FilePaths::[<a href="#type-any_file_path">any_file_path()</a>]) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Removes (deletes) the specified files (be them regular files or symbolic 
links), specified as a list of any kind of strings.</p>

 Throws an exception if any problem occurs (e.g. a file does not exist, or
 could not be removed for any reason).
</p>

<h3 class="function"><a name="remove_files_if_existing-1">remove_files_if_existing/1</a></h3>
<div class="spec">
<p><tt>remove_files_if_existing(FilePaths::[<a href="#type-any_file_path">any_file_path()</a>]) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p>Removes each of the specified regular files, in the specified list of any
 kind of strings, iff it is already existing.
</p>

<h3 class="function"><a name="remove_symlink-1">remove_symlink/1</a></h3>
<div class="spec">
<p><tt>remove_symlink(SymlinkPath::<a href="#type-any_file_path">any_file_path()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Removes (deletes) the specified symbolic link, specified as any kind of 
string.</p>

 <p>Checks that the specified path designates indeed a symbolic link (dead or 
not).</p>

 Throws an exception if any problem occurs.
</p>

<h3 class="function"><a name="remove_symlink_if_existing-1">remove_symlink_if_existing/1</a></h3>
<div class="spec">
<p><tt>remove_symlink_if_existing(SymlinkPath::<a href="#type-any_file_path">any_file_path()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Removes (deletes) the specified symbolic link, specified as any kind of 
string, iff it is already existing, otherwise does nothing.</p>

 <p>Checks that the specified path designates indeed a symbolic link (dead or 
not).</p>

 Throws an exception if any problem occurs.
</p>

<h3 class="function"><a name="remove_upper_levels_and_extension-1">remove_upper_levels_and_extension/1</a></h3>
<div class="spec">
<p><tt>remove_upper_levels_and_extension(FilePath) -&gt; any()</tt></p>
<p> </p>
</div><p><p>Removes all upper levels of a path (absolute or not), as well as the 
extension of the resulting file name.</p>

 For example "foobar" =
           file_utils:remove_upper_levels_and_extension( "aa/bb/foobar.txt" ).
</p>

<h3 class="function"><a name="rename-2">rename/2</a></h3>
<div class="spec">
<p><tt>rename(SourceFilePath::<a href="#type-any_file_path">any_file_path()</a>, DestinationFilePath::<a href="#type-any_file_path">any_file_path()</a>) -&gt; <a href="#type-any_file_path">any_file_path()</a></tt><br></p>
<p> </p>
</div><p><p>Renames the specified file.</p>

 Returns, for convenience, the new name.
</p>

<h3 class="function"><a name="rename_preserving-2">rename_preserving/2</a></h3>
<div class="spec">
<p><tt>rename_preserving(SourceFilePath::<a href="#type-any_file_path">any_file_path()</a>, DestinationFilePath::<a href="#type-any_file_path">any_file_path()</a>) -&gt; <a href="#type-any_file_path">any_file_path()</a></tt><br></p>
<p> </p>
</div><p><p>Renames the specified file; if the destination file already exists, 
renames it first by suffixing '.previous' to its name (then overwriting any 
identically-named file that would already exist), before performing the 
renaming.</p>

 Returns, for convenience, the new name.
</p>

<h3 class="function"><a name="rename_preserving-3">rename_preserving/3</a></h3>
<div class="spec">
<p><tt>rename_preserving(SourceFilePath::<a href="#type-any_file_path">any_file_path()</a>, DestinationFilePath::<a href="#type-any_file_path">any_file_path()</a>, HidingSuffix::<a href="#type-any_string">any_string()</a>) -&gt; <a href="#type-any_file_path">any_file_path()</a></tt><br></p>
<p> </p>
</div><p><p>Renames the specified file; if the destination file already exists, 
renames it first by adding the specified suffix to its name (then overwriting 
any identically-named file that would already exist), before performing the 
renaming.</p>

 Returns, for convenience, the new name.
</p>

<h3 class="function"><a name="replace_extension-3">replace_extension/3</a></h3>
<div class="spec">
<p><tt>replace_extension(FilePath::<a href="#type-file_path">file_path()</a>, SourceExtension::<a href="#type-extension">extension()</a>, TargetExtension::<a href="#type-extension">extension()</a>) -&gt; <a href="#type-file_path">file_path()</a></tt><br></p>
<p> </p>
</div><p><p>Returns a new file path whose extension has been updated.</p>

 <p>For example replace_extension("/home/jack/rosie.ttf", "ttf", "wav") should 
return "/home/jack/rosie.wav".</p>

 Use remove_extension/2 to remove extension, as replacing an extension by an
 empty one would leave the leading dot.
</p>

<h3 class="function"><a name="resolve_any_path-1">resolve_any_path/1</a></h3>
<div class="spec">
<p><tt>resolve_any_path(BinPath::<a href="#type-possibly_resolvable_path">possibly_resolvable_path()</a>) -&gt; <a href="#type-path">path()</a></tt><br></p>
<p> </p>
</div><p>Resolves the specified path - either a standard one or a resolvable one -
 in all cases as a plain, standard path.
</p>

<h3 class="function"><a name="resolve_path-1">resolve_path/1</a></h3>
<div class="spec">
<p><tt>resolve_path(ResolvablePath::<a href="#type-resolvable_path">resolvable_path()</a>) -&gt; <a href="#type-path">path()</a></tt><br></p>
<p> </p>
</div><p>Resolves the specified resolvable path as a standard path.</p>

<h3 class="function"><a name="resolve_symlink_fully-1">resolve_symlink_fully/1</a></h3>
<div class="spec">
<p><tt>resolve_symlink_fully(SymlinkPath::<a href="#type-any_path">any_path()</a>) -&gt; <a href="#type-any_path">any_path()</a></tt><br></p>
<p> </p>
</div><p>Resolves fully the specified symbolic link: returns the entry it points
 ultimately to (therefore this entry cannot be a symbolic link), or throws an
 exception (including if exceeding a larger link depth, which happens most
 probably because these links form a cycle; throwing arbitrarily an exception
 is better than looping for ever).
</p>

<h3 class="function"><a name="resolve_symlink_once-1">resolve_symlink_once/1</a></h3>
<div class="spec">
<p><tt>resolve_symlink_once(SymlinkPath::<a href="#type-any_path">any_path()</a>) -&gt; <a href="#type-any_path">any_path()</a></tt><br></p>
<p> </p>
</div><p>Resolves the specified symbolic link once: returns the entry (potentially
 another symbolic link) it points to.
</p>

<h3 class="function"><a name="resolve_type_of-1">resolve_type_of/1</a></h3>
<div class="spec">
<p><tt>resolve_type_of(Path::<a href="#type-any_path">any_path()</a>) -&gt; <a href="#type-entry_type">entry_type()</a></tt><br></p>
<p> </p>
</div><p><p>Returns the actual, ultimate type of the specified file entry (hence may 
not return 'symlink').</p>

 Refer to get_type_of/1 to return the type into which the specified entry
 resolves first (thus possibly resolving in a symbolic link).
</p>

<h3 class="function"><a name="set_current_directory-1">set_current_directory/1</a></h3>
<div class="spec">
<p><tt>set_current_directory(DirPath::<a href="#type-directory_path">directory_path()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Sets the specified directory as current directory.</p>

 Throws an exception on failure.
</p>

<h3 class="function"><a name="split-1">split/1</a></h3>
<div class="spec">
<p><tt>split(Path::<a href="#type-any_path">any_path()</a>) -&gt; [<a href="#type-any_path_element">any_path_element()</a>]</tt><br></p>
<p> </p>
</div><p>Splits the specified path in elements, returned as a list.</p>

<h3 class="function"><a name="split_path-1">split_path/1</a></h3>
<div class="spec">
<p><tt>split_path(AnyPath::<a href="#type-any_path">any_path()</a>) -&gt; {<a href="#type-any_path">any_path()</a>, <a href="#type-any_path_element">any_path_element()</a>}</tt><br></p>
<p> </p>
</div><p><p>Splits the specified path into a full base directory path and a final 
entry (filename or directory name).</p>

 For example {"/aaa/bbb/ccc", "foobar.txt"} =
   file_utils:split_path("/aaa/bbb/ccc/foobar.txt")
</p>

<h3 class="function"><a name="to_permission_mask-1">to_permission_mask/1</a></h3>
<div class="spec">
<p><tt>to_permission_mask(PermissionList::<a href="#type-permission">permission()</a> | [<a href="#type-permission">permission()</a>]) -&gt; <a href="#type-permission_mask">permission_mask()</a></tt><br></p>
<p> </p>
</div><p>Encodes the specified symbolic permission(s) into its/their low-level
 counterpart mask(s).
</p>

<h3 class="function"><a name="touch-1">touch/1</a></h3>
<div class="spec">
<p><tt>touch(Path::<a href="#type-any_path">any_path()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Updates the modification time (the last time at which its content was 
reported as modified according to the filesystem) of the specified file entry, 
which must already exist.</p>

 <p>Note: leaves last access time unchanged, updates both modification and change 
times.</p>

 See also: create_empty_file/1
</p>

<h3 class="function"><a name="try_copy_file-2">try_copy_file/2</a></h3>
<div class="spec">
<p><tt>try_copy_file(SourceFilePath::<a href="#type-any_file_path">any_file_path()</a>, DestinationFilePath::<a href="#type-any_file_path">any_file_path()</a>) -&gt; <a href="basic_utils.html#type-base_status">basic_utils:base_status()</a></tt><br></p>
<p> </p>
</div><p><p>Copies the specified file to a given destination filename (not a 
directory name, see copy_file_in/2 for that), overwriting any previous file.</p>

 <p>Symlinks are copied as symlinks (whereas file:copy/2 would copy their target 
as new files).</p>

 Note: content is copied and permissions are preserved (e.g. the copy of an
 executable file will be itself executable, and other permissions as well,
 unlike /bin/cp that relies on umask).
</p>

<h3 class="function"><a name="update_with_keywords-3">update_with_keywords/3</a></h3>
<div class="spec">
<p><tt>update_with_keywords(OriginalFilePath::<a href="#type-any_file_path">any_file_path()</a>, TargetFilePath::<a href="#type-any_file_path">any_file_path()</a>, TranslationTable::<a href="text_utils.html#type-translation_table">text_utils:translation_table()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Updates the specified file with the specified keywords, that is copies 
the original file into a target, updated one (supposedly non-already 
existing), in which all the specified keywords (the keys of the translation 
table) have been replaced by their associated value (that is the value in 
table corresponding to that key).</p>

 <p>For example: file_utils:update_with_keywords("original.txt", "updated.txt",    
table:new([{"hello", "goodbye"}, {"Blue", "Red"}])).</p>

 <p>The resulting file will be written with no additional encoding options.</p>

 In-place update can be done (by specifying the same file).
</p>

<h3 class="function"><a name="update_with_keywords-4">update_with_keywords/4</a></h3>
<div class="spec">
<p><tt>update_with_keywords(OriginalFilePath::<a href="#type-any_file_path">any_file_path()</a>, TargetFilePath::<a href="#type-any_file_path">any_file_path()</a>, TranslationTable::<a href="text_utils.html#type-translation_table">text_utils:translation_table()</a>, EncodingOpts::<a href="system_utils.html#type-encoding_options">system_utils:encoding_options()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Updates the specified file with the specified keywords, that is copies 
the original file into a target, updated one (supposedly non-already 
existing), in which all the specified keywords (the keys of the translation 
table) have been replaced by their associated value (that is the value in 
table corresponding to that key).</p>

 For example: file_utils:update_with_keywords("original.txt", "updated.txt",
    table:new([{"hello", "goodbye"}, {"Blue", "Red"}]), []).
</p>

<h3 class="function"><a name="write-2">write/2</a></h3>
<div class="spec">
<p><tt>write(File::<a href="#type-file">file()</a>, Content::iodata()) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Writes the specified byte-oriented content in the specified file.</p>

 <p>Operates on files opened in raw mode (only way to do so), or not (works for 
normal mode as well).</p>

 <p>Throws an exception on failure.</p>

 See write_ustring/{2,3} to write Unicode text.
</p>

<h3 class="function"><a name="write_direct_terms-2">write_direct_terms/2</a></h3>
<div class="spec">
<p><tt>write_direct_terms(File::<a href="#type-file">file()</a>, Terms::[term()]) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Writes directly the specified terms int the specified already opened 
file, in the ETF format.</p>

 <p>See http://myriad.esperide.org/#etf for more details.</p>

 Heavily inspired from Joe Armstrong's lib_misc:unconsult/2.
</p>

<h3 class="function"><a name="write_etf_file-2">write_etf_file/2</a></h3>
<div class="spec">
<p><tt>write_etf_file(Terms::[term()], AnyFilePath::<a href="#type-any_file_path">any_file_path()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Writes the specified terms in the specified file, in the ETF format, with 
no specific header or footer.</p>

 <p>See http://myriad.esperide.org/#etf for more details.</p>

 Heavily inspired from Joe Armstrong's lib_misc:unconsult/2.
</p>

<h3 class="function"><a name="write_etf_file-4">write_etf_file/4</a></h3>
<div class="spec">
<p><tt>write_etf_file(Terms::[term()], Header::<a href="#type-maybe">maybe</a>(<a href="#type-ustring">ustring()</a>), Footer::<a href="#type-maybe">maybe</a>(<a href="#type-ustring">ustring()</a>), Filename::<a href="#type-file_path">file_path()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Writes the specified terms in the specified file, in the ETF format, with 
the specified header and footer.</p>

 <p>See http://myriad.esperide.org/#etf for more details.</p>

 Heavily inspired from Joe Armstrong's lib_misc:unconsult/2.
</p>

<h3 class="function"><a name="write_terms-2">write_terms/2</a></h3>
<div class="spec">
<p><tt>write_terms(Terms::[term()], AnyFilePath::<a href="#type-any_file_path">any_file_path()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Writes the specified terms in the specified file, in the ETF format, with 
no specific header or footer.</p>

 <p>See http://myriad.esperide.org/#etf for more details.</p>

 Heavily inspired from Joe Armstrong's lib_misc:unconsult/2.
</p>

<h3 class="function"><a name="write_terms-4">write_terms/4</a></h3>
<div class="spec">
<p><tt>write_terms(Terms::[term()], Header::<a href="#type-maybe">maybe</a>(<a href="#type-ustring">ustring()</a>), Footer::<a href="#type-maybe">maybe</a>(<a href="#type-ustring">ustring()</a>), AnyFilePath::<a href="#type-any_file_path">any_file_path()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Writes the specified terms in the specified file, in the ETF format, with 
the specified header and footer.</p>

 Heavily inspired from Joe Armstrong's lib_misc:unconsult/2.
</p>

<h3 class="function"><a name="write_ustring-2">write_ustring/2</a></h3>
<div class="spec">
<p><tt>write_ustring(File::<a href="#type-file">file()</a>, Str::<a href="#type-ustring">ustring()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Writes the specified Unicode string in the specified file.</p>

 <p>Operates on files opened in raw mode (only way to do so), or not (works for 
normal mode as well).</p>

 <p>Note that no control character (even no "~n", for newlines) must exist in the 
specified string, otherwise they will be written literally. To convert them, 
use: 'write_ustring( File, Str, _FormatValues=[] )'.</p>

 Throws an exception on failure.
</p>

<h3 class="function"><a name="write_ustring-3">write_ustring/3</a></h3>
<div class="spec">
<p><tt>write_ustring(File::<a href="#type-file">file()</a>, FormatString::<a href="#type-format_string">format_string()</a>, FormatValues::<a href="#type-format_values">format_values()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Writes the specified formatted content in the specified file.</p>

 Throws an exception on failure.
</p>

<h3 class="function"><a name="write_whole-2">write_whole/2</a></h3>
<div class="spec">
<p><tt>write_whole(AnyFilePath::<a href="#type-any_file_path">any_file_path()</a>, Content::<a href="#type-ustring">ustring()</a> | binary()) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Writes the specified content in the specified file, whose path is 
specified as any kind of string, using a default encoding if a plain string is 
specified.</p>

 <p>Note that specifying a binary allows to avoid any potential unwanted encoding.</p>

 <p>Any already-existing file at that path will be silently overwritten.</p>

 Throws an exception on failure.
</p>

<h3 class="function"><a name="write_whole-3">write_whole/3</a></h3>
<div class="spec">
<p><tt>write_whole(AnyFilePath::<a href="#type-any_file_path">any_file_path()</a>, StringContent::<a href="#type-ustring">ustring()</a> | binary(), Modes::[<a href="http://www.erlang.org/edoc/doc/kernel/doc/file.html#type-mode">file:mode()</a>]) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Writes the specified content in the file whose path is specified as any 
kind of string, using the specified modes options, and applying before a 
default encoding if a plain string is specified.</p>

 <p>Note that no transparent encoding-to-file is thus expected to be specified 
through modes, as this function already performs (through 
text_utils:string_to_binary/1) such encoding on plain strings (otherwise this 
would result in a double encoding); specifying a binary allows to avoid any 
potential unwanted encoding.</p>

 <p>Any already-existing file at that path will be silently overwritten.</p>

 Throws an exception on failure.
</p>

<h3 class="function"><a name="write_whole_in_non_clashing-1">write_whole_in_non_clashing/1</a></h3>
<div class="spec">
<p><tt>write_whole_in_non_clashing(Content::<a href="#type-ustring">ustring()</a> | binary()) -&gt; <a href="#type-file_path">file_path()</a></tt><br></p>
<p> </p>
</div><p><p>Writes the specified content in a new file, whose path is chosen not to 
clash with any other (typically a temporary file), and returns that path.</p>

 Throws an exception on failure.
</p>

<h3 class="function"><a name="zipped_term_to_unzipped_file-1">zipped_term_to_unzipped_file/1</a></h3>
<div class="spec">
<p><tt>zipped_term_to_unzipped_file(ZippedTerm::binary()) -&gt; <a href="#type-file_name">file_name()</a></tt><br></p>
<p> </p>
</div><p><p>Reads the specified binary, extracts the zipped file in it and writes it 
on disk, in the current directory.</p>

 Returns the filename of the unzipped file.
</p>

<h3 class="function"><a name="zipped_term_to_unzipped_file-2">zipped_term_to_unzipped_file/2</a></h3>
<div class="spec">
<p><tt>zipped_term_to_unzipped_file(ZippedTerm::binary(), TargetFilename::<a href="#type-file_name">file_name()</a>) -&gt; <a href="#type-void">void()</a></tt><br></p>
<p> </p>
</div><p><p>Reads the specified binary, extracts the zipped file in it and writes it 
on disk, in the current directory, under the specified filename instead of 
under the filename stored in the zip archive.</p>

 <p>Any pre-existing file will be overwritten.</p>

 Note: only one file is expected to be stored in the specified archive.
</p>

<h3 class="function"><a name="zipped_term_to_unzipped_files-1">zipped_term_to_unzipped_files/1</a></h3>
<div class="spec">
<p><tt>zipped_term_to_unzipped_files(ZippedTerm::binary()) -&gt; [<a href="#type-file_name">file_name()</a>]</tt><br></p>
<p> </p>
</div><p><p>Reads the specified binary, extracts the zipped files stored in it and 
writes them on disk, in the current directory.</p>

 Returns the list of filenames corresponding to the unzipped files.
</p>

<h3 class="function"><a name="zipped_term_to_unzipped_files-2">zipped_term_to_unzipped_files/2</a></h3>
<div class="spec">
<p><tt>zipped_term_to_unzipped_files(ZippedTerm::binary(), TargetDirectory::<a href="#type-directory_name">directory_name()</a>) -&gt; [<a href="#type-file_name">file_name()</a>]</tt><br></p>
<p> </p>
</div><p><p>Reads the specified binary, extracts the zipped files in it and writes 
them on disk, in the specified directory.</p>

 Returns the list of filenames corresponding to the unzipped files.
</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
