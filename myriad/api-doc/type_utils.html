<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module type_utils</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module type_utils</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>Module helping to manage <b>datatypes</b> (and also values), notably in 
ASTs.


<h2><a name="description">Description</a></h2><p>Module helping to manage <b>datatypes</b> (and also values), notably in 
ASTs.</p>

 <p>See <code>type_utils_test.erl</code> for the corresponding test.</p>

 See also <code>meta_utils</code> for all topics regarding metaprogramming,
 parse-transforms, etc.

<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-byte_size">byte_size()</a></h3>
<p><code>byte_size() = <a href="system_utils.html#type-byte_size">system_utils:byte_size()</a></code></p>


<h3 class="typedecl"><a name="type-count">count()</a></h3>
<p><code>count() = <a href="basic_utils.html#type-count">basic_utils:count()</a></code></p>


<h3 class="typedecl"><a name="type-counters">counters()</a></h3>
<p><code>counters() = <a href="#type-tuple">tuple</a>(<a href="#type-count">count()</a>)</code></p>
<p> A tuple containing counters.</p>

<h3 class="typedecl"><a name="type-explicit_type">explicit_type()</a></h3>
<p><code>explicit_type() = <a href="#type-type">type()</a></code></p>
<p> An explicit type is a type that has been fully resolved in terms of built-in
 constructs; it is thus autonomous, self-standing.</p>

<h3 class="typedecl"><a name="type-float32">float32()</a></h3>
<p><code>float32() = float()</code></p>
<p><p> A single-precision, IEEE 754 32-bit base-2 floating-point value.</p>

 <p>Exact for all integers with up to 7 decimal digits, and for any 2^N for an 
integer number N in [-149,127].</p>

 <p>See <a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format" target="_top"><code>https://en.wikipedia.org/wiki/Single-precision_floating-point_format</code></a> for 
more information.</p>

 Note that in Erlang this datatype does not exist as such, only floars are
 float64() ones.</p>

<h3 class="typedecl"><a name="type-float64">float64()</a></h3>
<p><code>float64() = float()</code></p>
<p><p> A binary64/double-precision, IEEE 754 64-bit base-2 floating-point value.</p>

 <p>Exact notably for integers from -2^253 to 2^253 (-9,007,199,254,740,992 to 
9,007,199,254,740,992).</p>

 See <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" target="_top"><code>https://en.wikipedia.org/wiki/Double-precision_floating-point_format</code></a> for
 more information.</p>

<h3 class="typedecl"><a name="type-int16">int16()</a></h3>
<p><code>int16() = <a href="#type-uint16">uint16()</a> | <a href="#type-sint16">sint16()</a></code></p>
<p> 16-bit integer, potentially ranging from -32,768 to 65,535 (both included).</p>

<h3 class="typedecl"><a name="type-int32">int32()</a></h3>
<p><code>int32() = <a href="#type-uint32">uint32()</a> | <a href="#type-sint32">sint32()</a></code></p>
<p> 32-bit integer, potentially ranging from -2,147,483,648 to 4,294,967,295 (both
 included).</p>

<h3 class="typedecl"><a name="type-int64">int64()</a></h3>
<p><code>int64() = <a href="#type-uint64">uint64()</a> | <a href="#type-sint64">sint64()</a></code></p>
<p> 64-bit integer, potentially ranging from -9,223,372,036,854,775,808 to
 18,446,744,073,709,551,615 (both included).</p>

<h3 class="typedecl"><a name="type-int8">int8()</a></h3>
<p><code>int8() = <a href="#type-uint8">uint8()</a> | <a href="#type-sint8">sint8()</a></code></p>
<p> 8-bit integer, potentially ranging from -128 to 255 (both included).</p>

<h3 class="typedecl"><a name="type-level">level()</a></h3>
<p><code>level() = <a href="basic_utils.html#type-level">basic_utils:level()</a></code></p>


<h3 class="typedecl"><a name="type-low_level_type">low_level_type()</a></h3>
<p><code>low_level_type() = uint8 | sint8 | uint16 | sint16 | uint32 | sint32 | uint64 | sint64 | float32 | float64</code></p>
<p><p> Designates lower-level types, with a prefix and a size in bits.</p>

 <p>Following prefixes are defined: 
- u for unsigned 
- s for signed</p>

 Datatypes are 'int' (for integer) and 'float' (for standard IEEE signed,
 floating-point values).</p>

<h3 class="typedecl"><a name="type-map">map()</a></h3>
<p><code>map(_K, _V) = map()</code></p>
<p> As (maps:)map/2 does not even exist apparently, at least not since 18.0.</p>

<h3 class="typedecl"><a name="type-maybe">maybe()</a></h3>
<p><code>maybe(T) = T | undefined</code></p>


<h3 class="typedecl"><a name="type-nesting_depth">nesting_depth()</a></h3>
<p><code>nesting_depth() = {<a href="#type-count">count()</a>, <a href="#type-count">count()</a>}</code></p>
<p><p> Description of a nesting depth reached when parsing a type description.</p>

 It is in pratice a {P,B} pair, where P is the parenthesis depth (that is the
 number of the parentheses that have been opened and not closed yet) and B is
 the bracket depth (ie the same principle, for "[]" instead of for "()").</p>

<h3 class="typedecl"><a name="type-non_negative_float">non_negative_float()</a></h3>
<p><code>non_negative_float() = float()</code></p>
<p> A float that is positive or null.</p>

<h3 class="typedecl"><a name="type-pair">pair()</a></h3>
<p><code>pair() = <a href="pair.html#type-pair">pair:pair()</a></code></p>


<h3 class="typedecl"><a name="type-permanent_term">permanent_term()</a></h3>
<p><code>permanent_term() = integer() | float() | atom() | boolean() | binary() | [<a href="#type-permanent_term">permanent_term()</a>] | <a href="#type-tuple">tuple</a>(<a href="#type-permanent_term">permanent_term()</a>) | <a href="#type-map">map</a>(<a href="#type-permanent_term">permanent_term()</a>, <a href="#type-permanent_term">permanent_term()</a>)</code></p>
<p><p> Designates values that are permanent, that is that are context-free, not 
runtime-specific and can be reproduced (e.g. serialised).</p>

 <p>As for compound datatypes (lists, tuples and thus records, maps), they are 
also permanent iff all the terms they aggregate are themselves permanent 
terms.</p>

 Permanent terms are the opposite of transient ones.</p>

<h3 class="typedecl"><a name="type-pid_ref">pid_ref()</a></h3>
<p><code>pid_ref() = <a href="naming_utils.html#type-local_designator">naming_utils:local_designator()</a></code></p>
<p> Any kind of reference onto a process.</p>

<h3 class="typedecl"><a name="type-positive_float">positive_float()</a></h3>
<p><code>positive_float() = float()</code></p>
<p> A float that is strictly positive.</p>

<h3 class="typedecl"><a name="type-positive_index">positive_index()</a></h3>
<p><code>positive_index() = <a href="basic_utils.html#type-positive_index">basic_utils:positive_index()</a></code></p>


<h3 class="typedecl"><a name="type-primitive_type_description">primitive_type_description()</a></h3>
<p><code>primitive_type_description() = atom | binary | boolean | float | function | integer | list | map | pid | port | record | reference | tuple</code></p>


<h3 class="typedecl"><a name="type-record">record()</a></h3>
<p><code>record() = tuple()</code></p>
<p> Designates a record instance, to discriminate from a mere tuple.</p>

<h3 class="typedecl"><a name="type-record_tag">record_tag()</a></h3>
<p><code>record_tag() = atom()</code></p>
<p> The first (atom) element of the tuple corresponding to a record instance.  For
 example #my_point{ x=1, y=2 } is actually {my_point, 1, 2} and thus my_point
 is the corresponding record tag.</p>

<h3 class="typedecl"><a name="type-sint16">sint16()</a></h3>
<p><code>sint16() = -32768..32767</code></p>
<p> Signed 16-bit integer, ranging from -32,768 to 32,767 (both included).</p>

<h3 class="typedecl"><a name="type-sint32">sint32()</a></h3>
<p><code>sint32() = -2147483648..2147483647</code></p>
<p> Signed 32-bit integer, ranging from -2,147,483,648 to 2,147,483,647 (both
 included).</p>

<h3 class="typedecl"><a name="type-sint64">sint64()</a></h3>
<p><code>sint64() = -9223372036854775808..9223372036854775807</code></p>
<p> Signed 64-bit integer, ranging from -9,223,372,036,854,775,808 to
 9,223,372,036,854,775,807 (both included).</p>

<h3 class="typedecl"><a name="type-sint8">sint8()</a></h3>
<p><code>sint8() = -128..127</code></p>
<p> Signed 8-bit integer, ranging from -128 to 127 (both included).</p>

<h3 class="typedecl"><a name="type-transient_term">transient_term()</a></h3>
<p><code>transient_term() = pid() | port() | reference() | function()</code></p>
<p><p> Designates values that are transient, that is that are runtime-specific and 
cannot be reproduced a priori.</p>

 <p>PIDs belong to this type, ports, references, anonymous functions may also.</p>

 <p>As for compound datatypes (lists, tuples and thus records, maps), they are 
also transient iff at least one of the terms they aggregate is itself a 
transient term.</p>

 Transient terms are the opposite of permanent ones.</p>

<h3 class="typedecl"><a name="type-triplet">triplet()</a></h3>
<p><code>triplet() = {any(), any(), any()}</code></p>


<h3 class="typedecl"><a name="type-tuple">tuple()</a></h3>
<p><code>tuple(_T, _S) = tuple()</code></p>
<p> Designates an uniform tuple of the specified size, that is a tuple whose
 S elements are all of the type T.</p>

<h3 class="typedecl"><a name="type-tuple">tuple()</a></h3>
<p><code>tuple(_T) = tuple()</code></p>
<p> Designates an uniform tuple (of unspecified size), that is a tuple whose
 elements are all of the specified type T.</p>

<h3 class="typedecl"><a name="type-tuploid">tuploid()</a></h3>
<p><code>tuploid(T) = tuple() | T</code></p>
<p> Probably that such a tuple would contain at least an element of type T.</p>

<h3 class="typedecl"><a name="type-tuploid">tuploid()</a></h3>
<p><code>tuploid() = <a href="#type-tuploid">tuploid</a>(term())</code></p>
<p><p> We name tuploid a pseudo-tuple, that is a value that is either an actual tuple 
or a single, standalone term, designated as a "basic tuploid".</p>

 That is, a tuploid is a tuple of any size, except that the tuploid of size 1
 is MyTerm, not {MyTerm}.</p>

<h3 class="typedecl"><a name="type-type">type()</a></h3>
<p><code>type() = term()</code></p>
<p><p> Internal, "formal", actual programmatic description of a type according to our 
conventions: type-as-a-term (either contextual or explicit, F2 or F3), relying 
on a translated version of the textual type (which is for example: 
"[{float,boolean}]").</p>

 <p>This "internal type language of the Myriad layer" is largely inspired from the 
forms that can be found in actual ASTs.</p>

 <p>Requirements for this term-based description were:</p>

 <p>- be able to represent at least any actual (that can be readily instantiated, 
hence non-polymorphic) type (like "-type a() :: ...", not "-type a(T) :: 
..."); should, in the future, polymorphic types have to be *defined* (not 
merely used), then (non-empty) parentheses could be introduced</p>

 <p>- be able to nevertheless *use* polymorphic types, as they are certainly 
useful (e.g. maps/associative tables, lists, etc.); a problem is that, in 
terms (as opposed to in the textual counterpart), parentheses cannot be used 
to express these polymorphic types (not only they denote function calls, but 
also are not legit components of a term); therefore the convention chosen here 
is to specify types as pairs, the first element being the name of the type, 
the second one being the (ordered) list of the types it depends on; then the 
textual type "a( T1, T2 )" is translated to the {a,[T1,T2]} type term; most 
types being "monomorphic", they are represented as {my_simple_type,[]} (which 
cannot be abbreviated by only the 'my_simple_type' atom, as it would lead to 
ambiguous forms)</p>

 <p>So, as an example, the type-as-a-term corresponding to "[{float,boolean}]" 
is: {list, [{tuple, [{float,[]}, {boolean,[]} ]}]}</p>

 <p>Note that an alternate type language (sticking more closely to its textual 
counterpart) could have been a more direct [{float,boolean}] term (hence 
getting rid of the parentheses and the pair with an empty list in second 
position); reason for not doing so: then no possible support of the 
polymorphic types that happen to be often needed.</p>

 <p>The origin of this term-as-a-type notation is clearly the standard (Erlang) 
type specifications; for example 'meta_utils:string_to_form( "-type a() :: 
[{float(),boolean()}]." ).' returns following AST form:</p>

  <p>'{attribute,1,type, {a,{type,1,list, [{type,1,tuple,[{type,1,float,[]},  
{type,1,boolean,[]}]}]}'</p>

 <p>As a result the counterpart to the aforementioned "[{float(), boolean()}]" 
type string is translated in ASTs as:</p>

 <p>{type, 1, list, [{type, 1, tuple, [{type, 1, float, []}, {type, 1, boolean, 
[]}]}]}</p>

 <p>Then one can remove:</p>

 <p>- the 'type' (and 'user_type') atoms (not making then a specific distinction 
between the origin of a type); a list of built-in types - names and arities - 
is maintained, other types being then user ones)</p>

 <p>- the line numbers (the '1's here), not useful in that context, hence stripped</p>

 <p>Then we obtain our aforementioned term-as-a-type:    
{list, [{tuple, [{float,[]}, {boolean,[]}]}]}</p>

 <p>We can therefore describe this way arbitrary types as valid terms.</p>

 <p>Next steps:</p>

 <p>- define and document the full type language (elementary datatypes - like 
boolean, integer, float, atoms - and constructs - like list, map, tuple, 
union)</p>

 <p>- support it, notably define functions to tell whether a given term is an 
instance of a specified type</p>

 <p>Experiment with ast_utils:string_to_form/1 and have fun!</p>

 <p>For example "-type a() :: [foobar()]." yields: '{attribute,1,type, {a,{type,1,    
list,[{user_type,1,foobar,[]}]},[]}}'.</p>

 <p>See also <a href="http://erlang.org/doc/apps/erts/absform.html" target="_top"><code>http://erlang.org/doc/apps/erts/absform.html</code></a>.</p>

 <p>Finally, a direct string representation can be converted into a type(); maybe 
writing a parser may not mandatory, as "{float(), atom()}" may be a string 
expression evaluated with functions that we can bind to obtain a closer term, 
such as: float() -&gt; {float, []}.</p>

 <p>Of course, on a related note, if TextualType = "{list, [ 
{tuple, [float, boolean]}]}", then ast_utils:string_to_value(TextualType) 
will return the expected: {list, [{tuple, [{float, []}, {boolean, []}]}]}</p>

 Note that such a type may not be fully explicit, as it may contain unresolved
 references to other types; for example: {list, [{count, []}]} does not specify
 what the count() type is.</p>

<h3 class="typedecl"><a name="type-type_arity">type_arity()</a></h3>
<p><code>type_arity() = <a href="#type-count">count()</a></code></p>
<p> Number of types a (possibly polymorphic) type depends on (possibly zero for
 plain types).</p>

<h3 class="typedecl"><a name="type-type_description">type_description()</a></h3>
<p><code>type_description() = <a href="#type-ustring">ustring()</a></code></p>
<p><p> Textual type description: type-as-a-string, inspired from the syntax used for
 type specifications (<a href="http://erlang.org/doc/reference_manual/typespec.html" target="_top"><code>http://erlang.org/doc/reference_manual/typespec.html</code></a>), 
yet different. Notably, monomorphic types do not end with empty parentheses 
(e.g. "integer", not "integer()") and atoms are always surrounded by simple 
quotes (e.g. "'an_atom'|'another_one'").</p>

 For example: "[{float, boolean}]".</p>

<h3 class="typedecl"><a name="type-type_id">type_id()</a></h3>
<p><code>type_id() = {<a href="#type-type_name">type_name()</a>, <a href="#type-type_arity">type_arity()</a>}</code></p>
<p> Analoguous to function_id/0.</p>

<h3 class="typedecl"><a name="type-type_name">type_name()</a></h3>
<p><code>type_name() = atom()</code></p>
<p><p> Describes the name of a type (without the names of the types it depends on, 
for polymorphic ones).</p>

 For example 'my_count'.</p>

<h3 class="typedecl"><a name="type-uint16">uint16()</a></h3>
<p><code>uint16() = 0..65535</code></p>
<p> Non-negative 16-bit integer, ranging from 0 to 65,535 (both included).</p>

<h3 class="typedecl"><a name="type-uint32">uint32()</a></h3>
<p><code>uint32() = 0..4294967295</code></p>
<p> Non-negative 32-bit integer, ranging from 0 to 4,294,967,295 (both included).</p>

<h3 class="typedecl"><a name="type-uint64">uint64()</a></h3>
<p><code>uint64() = 0..18446744073709551615</code></p>
<p> Non-negative 64-bit integer, ranging from 0 to 18,446,744,073,709,551,615
 (both included).</p>

<h3 class="typedecl"><a name="type-uint8">uint8()</a></h3>
<p><code>uint8() = 0..255</code></p>
<p> Non-negative 8-bit integer, ranging from 0 to 255 (both included).</p>

<h3 class="typedecl"><a name="type-ustring">ustring()</a></h3>
<p><code>ustring() = <a href="text_utils.html#type-ustring">text_utils:ustring()</a></code></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#add_to_counter-3">add_to_counter/3</a></td><td>Adds the specified value to the specified counter.</td></tr>
<tr><td valign="top"><a href="#are_binaries-1">are_binaries/1</a></td><td>Returns whether the specified term is a list of binaries.</td></tr>
<tr><td valign="top"><a href="#are_floats-1">are_floats/1</a></td><td>Returns whether the specified term is a list of floats.</td></tr>
<tr><td valign="top"><a href="#are_integers-1">are_integers/1</a></td><td>Returns whether the specified term is a list of integers.</td></tr>
<tr><td valign="top"><a href="#are_maybe_floats-1">are_maybe_floats/1</a></td><td>Returns whether the specified term is a list of maybe-floats.</td></tr>
<tr><td valign="top"><a href="#are_maybe_integers-1">are_maybe_integers/1</a></td><td>Returns whether the specified term is a list of maybe-integers.</td></tr>
<tr><td valign="top"><a href="#are_maybe_numbers-1">are_maybe_numbers/1</a></td><td>Returns whether the specified term is a list of maybe-numbers.</td></tr>
<tr><td valign="top"><a href="#are_numbers-1">are_numbers/1</a></td><td>Returns whether the specified term is a list of numbers.</td></tr>
<tr><td valign="top"><a href="#are_positive_floats-1">are_positive_floats/1</a></td><td>Returns whether the specified term is a list of positive floats.</td></tr>
<tr><td valign="top"><a href="#are_types_identical-2">are_types_identical/2</a></td><td>Tells whether the two specified types are the same (ie designate the same
 actual type, are aliases).</td></tr>
<tr><td valign="top"><a href="#augment_tuploid-2">augment_tuploid/2</a></td><td>Augments the specified tuploid with the specified term, placed as new 
last element.</td></tr>
<tr><td valign="top"><a href="#check_atom-1">check_atom/1</a></td><td>Checks that the specified term is an atom indeed, and returns it.</td></tr>
<tr><td valign="top"><a href="#check_atoms-1">check_atoms/1</a></td><td>Checks that the specified term is a list of atoms indeed, and returns it.</td></tr>
<tr><td valign="top"><a href="#check_binaries-1">check_binaries/1</a></td><td>Checks that the specified term is a list of binaries indeed, and returns
 it.</td></tr>
<tr><td valign="top"><a href="#check_binary-1">check_binary/1</a></td><td>Checks that the specified term is a binary indeed, and returns it.</td></tr>
<tr><td valign="top"><a href="#check_boolean-1">check_boolean/1</a></td><td>Checks that the specified term is a boolean indeed, and returns it.</td></tr>
<tr><td valign="top"><a href="#check_booleans-1">check_booleans/1</a></td><td>Checks that the specified term is a list of booleans indeed, and returns
 it.</td></tr>
<tr><td valign="top"><a href="#check_float-1">check_float/1</a></td><td>Checks that the specified term is a float indeed, and returns it.</td></tr>
<tr><td valign="top"><a href="#check_floats-1">check_floats/1</a></td><td>Checks that the specified term is a list of floats indeed, and returns
 it.</td></tr>
<tr><td valign="top"><a href="#check_integer-1">check_integer/1</a></td><td>Checks that the specified term is an integer indeed, and returns it.</td></tr>
<tr><td valign="top"><a href="#check_integers-1">check_integers/1</a></td><td>Checks that the specified term is a list of integers indeed, and returns
 it.</td></tr>
<tr><td valign="top"><a href="#check_list-1">check_list/1</a></td><td>Checks that the specified term is a list indeed, and returns it.</td></tr>
<tr><td valign="top"><a href="#check_map-1">check_map/1</a></td><td>Checks that the specified term is a map indeed, and returns it.</td></tr>
<tr><td valign="top"><a href="#check_maybe_float-1">check_maybe_float/1</a></td><td>Checks that the specified term is a maybe-float indeed, and returns it.</td></tr>
<tr><td valign="top"><a href="#check_maybe_floats-1">check_maybe_floats/1</a></td><td>Checks that the specified term is a list of maybe-floats indeed, and
 returns it.</td></tr>
<tr><td valign="top"><a href="#check_maybe_integer-1">check_maybe_integer/1</a></td><td>Checks that the specified term is a maybe-integer indeed, and returns it.</td></tr>
<tr><td valign="top"><a href="#check_maybe_integers-1">check_maybe_integers/1</a></td><td>Checks that the specified term is a list of maybe-integers indeed, and
 returns it.</td></tr>
<tr><td valign="top"><a href="#check_maybe_number-1">check_maybe_number/1</a></td><td>Checks that the specified term is a maybe-number indeed, and returns it.</td></tr>
<tr><td valign="top"><a href="#check_maybe_numbers-1">check_maybe_numbers/1</a></td><td>Checks that the specified term is a list of maybe-numbers indeed, and
 returns it.</td></tr>
<tr><td valign="top"><a href="#check_maybe_pid-1">check_maybe_pid/1</a></td><td>Checks that the specified term is a PID indeed or the 'undefined' atom,
 and returns it.</td></tr>
<tr><td valign="top"><a href="#check_maybe_positive_float-1">check_maybe_positive_float/1</a></td><td>Checks that the specified term is a maybe-(positive float) indeed, and
 returns it.</td></tr>
<tr><td valign="top"><a href="#check_maybe_positive_integer-1">check_maybe_positive_integer/1</a></td><td>Checks that the specified term is a positive or null integer or the
 'undefined' atom, and returns it.</td></tr>
<tr><td valign="top"><a href="#check_maybe_strictly_positive_float-1">check_maybe_strictly_positive_float/1</a></td><td>Checks that the specified term is a maybe-(strictly positive float)
 indeed, and returns it.</td></tr>
<tr><td valign="top"><a href="#check_number-1">check_number/1</a></td><td>Checks that the specified term is a number indeed, and returns it.</td></tr>
<tr><td valign="top"><a href="#check_numbers-1">check_numbers/1</a></td><td>Checks that the specified term is a list of numbers indeed, and returns
 it.</td></tr>
<tr><td valign="top"><a href="#check_pid-1">check_pid/1</a></td><td>Checks that the specified term is a PID indeed, and returns it.</td></tr>
<tr><td valign="top"><a href="#check_pids-1">check_pids/1</a></td><td>Checks that the specified term is a list of PIDs indeed, and returns it.</td></tr>
<tr><td valign="top"><a href="#check_positive_float-1">check_positive_float/1</a></td><td>Checks that the specified term is a positive (or null) float indeed, and
 returns it.</td></tr>
<tr><td valign="top"><a href="#check_positive_floats-1">check_positive_floats/1</a></td><td>Checks that the specified term is a list of positive (or null) floats
 indeed, and returns it.</td></tr>
<tr><td valign="top"><a href="#check_positive_integer-1">check_positive_integer/1</a></td><td>Checks that the specified term is a positive or null integer, and returns
 it.</td></tr>
<tr><td valign="top"><a href="#check_positive_number-1">check_positive_number/1</a></td><td>Checks that the specified term is a positive or null number indeed, and
 returns it.</td></tr>
<tr><td valign="top"><a href="#check_strictly_positive_float-1">check_strictly_positive_float/1</a></td><td>Checks that the specified term is a strictly positive float indeed, and
 returns it.</td></tr>
<tr><td valign="top"><a href="#check_strictly_positive_integer-1">check_strictly_positive_integer/1</a></td><td>Checks that the specified term is a strictly positive integer, and
 returns it.</td></tr>
<tr><td valign="top"><a href="#check_strictly_positive_number-1">check_strictly_positive_number/1</a></td><td>Checks that the specified term is a strictly positive number indeed, and
 returns it.</td></tr>
<tr><td valign="top"><a href="#check_tuple-1">check_tuple/1</a></td><td>Checks that the specified term is a tuple indeed, and returns it.</td></tr>
<tr><td valign="top"><a href="#description_to_type-1">description_to_type/1</a></td><td>Returns the actual type corresponding to specified type description: 
parses the specified string to determine the type described therein.</td></tr>
<tr><td valign="top"><a href="#ensure_binary-1">ensure_binary/1</a></td><td>Ensures that the specified term is a binary string, and returns it.</td></tr>
<tr><td valign="top"><a href="#ensure_ceiled_integer-1">ensure_ceiled_integer/1</a></td><td>Ensures that the specified term is an integer, and returns it.</td></tr>
<tr><td valign="top"><a href="#ensure_float-1">ensure_float/1</a></td><td>Ensures that the specified term is a float, and returns it.</td></tr>
<tr><td valign="top"><a href="#ensure_floored_integer-1">ensure_floored_integer/1</a></td><td>Ensures that the specified term is an integer, and returns it.</td></tr>
<tr><td valign="top"><a href="#ensure_integer-1">ensure_integer/1</a></td><td>Ensures that the specified term is an integer, and returns it.</td></tr>
<tr><td valign="top"><a href="#ensure_positive_float-1">ensure_positive_float/1</a></td><td>Ensures that the specified term is a positive (possibly null) float, and 
returns it.</td></tr>
<tr><td valign="top"><a href="#ensure_rounded_integer-1">ensure_rounded_integer/1</a></td><td>Ensures that the specified term is an integer, and returns it.</td></tr>
<tr><td valign="top"><a href="#ensure_string-1">ensure_string/1</a></td><td>Ensures that the specified term is a string, and returns it.</td></tr>
<tr><td valign="top"><a href="#get_ast_simple_builtin_types-0">get_ast_simple_builtin_types/0</a></td><td>Returns a list of the possible types for immediate values (typically 
found in an AST like, like 'undefined' in: {atom,42,undefined}).</td></tr>
<tr><td valign="top"><a href="#get_elementary_types-0">get_elementary_types/0</a></td><td>Returns a list of the elementary, "atomic" types.</td></tr>
<tr><td valign="top"><a href="#get_immediate_types-0">get_immediate_types/0</a></td><td>Returns a list of the possible types for immediate values.</td></tr>
<tr><td valign="top"><a href="#get_last_tuple_element-1">get_last_tuple_element/1</a></td><td>Returns the last element of the specified tuple.</td></tr>
<tr><td valign="top"><a href="#get_low_level_type_size-1">get_low_level_type_size/1</a></td><td>Returns the number of bytes used by each value of the specified low-level
 type.</td></tr>
<tr><td valign="top"><a href="#get_record_tag-1">get_record_tag/1</a></td><td>Returns the tag of the specified record instance.</td></tr>
<tr><td valign="top"><a href="#get_simple_builtin_types-0">get_simple_builtin_types/0</a></td><td>Returns a list of the built-in, non-polymorphic types that can be
 typically found in AST forms.</td></tr>
<tr><td valign="top"><a href="#get_type_of-1">get_type_of/1</a></td><td>Returns an atom describing, as precisely as possible, the overall type of 
the specified primitive term.</td></tr>
<tr><td valign="top"><a href="#increment_counter-2">increment_counter/2</a></td><td>Increments the specified counter.</td></tr>
<tr><td valign="top"><a href="#initialise_counters-1">initialise_counters/1</a></td><td>Initialises the specified number of counters to zero.</td></tr>
<tr><td valign="top"><a href="#initialise_counters-2">initialise_counters/2</a></td><td>Initialises the specified number of counters to the specified (initial)
 value.</td></tr>
<tr><td valign="top"><a href="#interpret_type_of-1">interpret_type_of/1</a></td><td>Returns a string describing, in a user-friendly manner, the type of the
 specified term (up to one level of nesting detailed).</td></tr>
<tr><td valign="top"><a href="#interpret_type_of-2">interpret_type_of/2</a></td><td>Returns a string describing, in a user-friendly manner, the type of the
 specified term, up to the specified nesting level (either a positive integer
 or the 'infinite' atom, to go as deep as possible in the term structure).</td></tr>
<tr><td valign="top"><a href="#is_homogeneous-1">is_homogeneous/1</a></td><td>Tells whether specified non-empty monomorphic container (list or tuple) 
is homogeneous in terms of type, ie whether all its elements are of the same 
type.</td></tr>
<tr><td valign="top"><a href="#is_homogeneous-2">is_homogeneous/2</a></td><td>Tells whether specified non-empty monomorphic container (list or tuple)
 is homogeneous in terms of type, that is whether all its elements are of the
 same, specified, primitive type.</td></tr>
<tr><td valign="top"><a href="#is_of_described_type-2">is_of_described_type/2</a></td><td>Tells whether the specified term is of specified textually-described 
type.</td></tr>
<tr><td valign="top"><a href="#is_of_type-2">is_of_type/2</a></td><td>Tells whether specified term is of specified type (predicate).</td></tr>
<tr><td valign="top"><a href="#is_transient-1">is_transient/1</a></td><td>Tells whether the specified term is, just by itself, a transient one.</td></tr>
<tr><td valign="top"><a href="#is_type-1">is_type/1</a></td><td>Tells whether specified term designates a type (ie a type() instance).</td></tr>
<tr><td valign="top"><a href="#share-1">share/1</a></td><td>Improves the compactness of the specified term ("compresses it"): returns 
it once the sharing of its sub-terms has been favored (equal term, but 
possibly smaller in memory).</td></tr>
<tr><td valign="top"><a href="#share-2">share/2</a></td><td>Returns the two specified terms as a pair favoring the in-memory sharing 
of its elements, if they are equal.</td></tr>
<tr><td valign="top"><a href="#share-3">share/3</a></td><td>Returns the three specified terms as a triplet favoring the in-memory 
sharing of its elements, if they are equal.</td></tr>
<tr><td valign="top"><a href="#tokenise_per_union-1">tokenise_per_union/1</a></td><td>Splits the specified type description according to union delimiters.</td></tr>
<tr><td valign="top"><a href="#type_to_description-1">type_to_description/1</a></td><td>Returns the type description (in canonical form, notably without 
whitespaces) corresponding to specified type.</td></tr>
<tr><td valign="top"><a href="#type_to_string-1">type_to_string/1</a></td><td>Returns a textual representation of the specified type.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="add_to_counter-3">add_to_counter/3</a></h3>
<div class="spec">
<p><code>add_to_counter(ToAdd::number(), CounterIndex::<a href="#type-positive_index">positive_index()</a>, Counters::<a href="#type-counters">counters()</a>) -&gt; <a href="#type-counters">counters()</a></code><br></p>
<p> </p>
</div><p>Adds the specified value to the specified counter.</p>

<h3 class="function"><a name="are_binaries-1">are_binaries/1</a></h3>
<div class="spec">
<p><code>are_binaries(T::term()) -&gt; boolean()</code><br></p>
<p> </p>
</div><p>Returns whether the specified term is a list of binaries.</p>

<h3 class="function"><a name="are_floats-1">are_floats/1</a></h3>
<div class="spec">
<p><code>are_floats(T::term()) -&gt; boolean()</code><br></p>
<p> </p>
</div><p>Returns whether the specified term is a list of floats.</p>

<h3 class="function"><a name="are_integers-1">are_integers/1</a></h3>
<div class="spec">
<p><code>are_integers(T::term()) -&gt; boolean()</code><br></p>
<p> </p>
</div><p>Returns whether the specified term is a list of integers.</p>

<h3 class="function"><a name="are_maybe_floats-1">are_maybe_floats/1</a></h3>
<div class="spec">
<p><code>are_maybe_floats(T::term()) -&gt; boolean()</code><br></p>
<p> </p>
</div><p>Returns whether the specified term is a list of maybe-floats.</p>

<h3 class="function"><a name="are_maybe_integers-1">are_maybe_integers/1</a></h3>
<div class="spec">
<p><code>are_maybe_integers(T::term()) -&gt; boolean()</code><br></p>
<p> </p>
</div><p>Returns whether the specified term is a list of maybe-integers.</p>

<h3 class="function"><a name="are_maybe_numbers-1">are_maybe_numbers/1</a></h3>
<div class="spec">
<p><code>are_maybe_numbers(T::term()) -&gt; boolean()</code><br></p>
<p> </p>
</div><p>Returns whether the specified term is a list of maybe-numbers.</p>

<h3 class="function"><a name="are_numbers-1">are_numbers/1</a></h3>
<div class="spec">
<p><code>are_numbers(T::term()) -&gt; boolean()</code><br></p>
<p> </p>
</div><p>Returns whether the specified term is a list of numbers.</p>

<h3 class="function"><a name="are_positive_floats-1">are_positive_floats/1</a></h3>
<div class="spec">
<p><code>are_positive_floats(T::term()) -&gt; boolean()</code><br></p>
<p> </p>
</div><p>Returns whether the specified term is a list of positive floats.</p>

<h3 class="function"><a name="are_types_identical-2">are_types_identical/2</a></h3>
<div class="spec">
<p><code>are_types_identical(Type::<a href="#type-type">type()</a>, SecondType::<a href="#type-type">type()</a>) -&gt; boolean()</code><br></p>
<p> </p>
</div><p>Tells whether the two specified types are the same (ie designate the same
 actual type, are aliases).
</p>

<h3 class="function"><a name="augment_tuploid-2">augment_tuploid/2</a></h3>
<div class="spec">
<p><code>augment_tuploid(Tuploid::<a href="#type-tuploid">tuploid()</a>, ExtraTerm::term()) -&gt; <a href="#type-tuploid">tuploid()</a></code><br></p>
<p> </p>
</div><p><p>Augments the specified tuploid with the specified term, placed as new 
last element.</p>

 <p>For example augment_tuploid(a, 2.0) = {a, 2.0}     
augment_tuploid({foo, 42}, 2.0) = {foo, 42, 2.0}</p>

 Useful typically to augment returned error tuploids (either a single error
 term such as 'invalid_name', or a tuple like '{invalid_name,"Arnold"}') with
 caller-local information, to obtain in all cases a tuploid (a tuple here) with
 this extra information.
</p>

<h3 class="function"><a name="check_atom-1">check_atom/1</a></h3>
<div class="spec">
<p><code>check_atom(Atom::term()) -&gt; atom()</code><br></p>
<p> </p>
</div><p>Checks that the specified term is an atom indeed, and returns it.</p>

<h3 class="function"><a name="check_atoms-1">check_atoms/1</a></h3>
<div class="spec">
<p><code>check_atoms(Atoms::term()) -&gt; [atom()]</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a list of atoms indeed, and returns it.</p>

<h3 class="function"><a name="check_binaries-1">check_binaries/1</a></h3>
<div class="spec">
<p><code>check_binaries(Binaries::term()) -&gt; [binary()]</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a list of binaries indeed, and returns
 it.
</p>

<h3 class="function"><a name="check_binary-1">check_binary/1</a></h3>
<div class="spec">
<p><code>check_binary(Binary::term()) -&gt; binary()</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a binary indeed, and returns it.</p>

<h3 class="function"><a name="check_boolean-1">check_boolean/1</a></h3>
<div class="spec">
<p><code>check_boolean(Other::term()) -&gt; atom()</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a boolean indeed, and returns it.</p>

<h3 class="function"><a name="check_booleans-1">check_booleans/1</a></h3>
<div class="spec">
<p><code>check_booleans(Booleans::term()) -&gt; [boolean()]</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a list of booleans indeed, and returns
 it.</p>

<h3 class="function"><a name="check_float-1">check_float/1</a></h3>
<div class="spec">
<p><code>check_float(Float::term()) -&gt; float()</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a float indeed, and returns it.</p>

<h3 class="function"><a name="check_floats-1">check_floats/1</a></h3>
<div class="spec">
<p><code>check_floats(Floats::term()) -&gt; [float()]</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a list of floats indeed, and returns
 it.
</p>

<h3 class="function"><a name="check_integer-1">check_integer/1</a></h3>
<div class="spec">
<p><code>check_integer(Int::term()) -&gt; integer()</code><br></p>
<p> </p>
</div><p>Checks that the specified term is an integer indeed, and returns it.</p>

<h3 class="function"><a name="check_integers-1">check_integers/1</a></h3>
<div class="spec">
<p><code>check_integers(Integers::term()) -&gt; [integer()]</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a list of integers indeed, and returns
 it.
</p>

<h3 class="function"><a name="check_list-1">check_list/1</a></h3>
<div class="spec">
<p><code>check_list(List::term()) -&gt; list()</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a list indeed, and returns it.</p>

<h3 class="function"><a name="check_map-1">check_map/1</a></h3>
<div class="spec">
<p><code>check_map(Map::term()) -&gt; map()</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a map indeed, and returns it.</p>

<h3 class="function"><a name="check_maybe_float-1">check_maybe_float/1</a></h3>
<div class="spec">
<p><code>check_maybe_float(F::term()) -&gt; <a href="#type-maybe">maybe</a>(float())</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a maybe-float indeed, and returns it.</p>

<h3 class="function"><a name="check_maybe_floats-1">check_maybe_floats/1</a></h3>
<div class="spec">
<p><code>check_maybe_floats(MaybeFloats::term()) -&gt; [<a href="#type-maybe">maybe</a>(float())]</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a list of maybe-floats indeed, and
 returns it.
</p>

<h3 class="function"><a name="check_maybe_integer-1">check_maybe_integer/1</a></h3>
<div class="spec">
<p><code>check_maybe_integer(Int::term()) -&gt; <a href="#type-maybe">maybe</a>(integer())</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a maybe-integer indeed, and returns it.</p>

<h3 class="function"><a name="check_maybe_integers-1">check_maybe_integers/1</a></h3>
<div class="spec">
<p><code>check_maybe_integers(MaybeIntegers::term()) -&gt; [<a href="#type-maybe">maybe</a>(integer())]</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a list of maybe-integers indeed, and
 returns it.
</p>

<h3 class="function"><a name="check_maybe_number-1">check_maybe_number/1</a></h3>
<div class="spec">
<p><code>check_maybe_number(Num::term()) -&gt; <a href="#type-maybe">maybe</a>(number())</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a maybe-number indeed, and returns it.</p>

<h3 class="function"><a name="check_maybe_numbers-1">check_maybe_numbers/1</a></h3>
<div class="spec">
<p><code>check_maybe_numbers(MaybeNumbers::term()) -&gt; [<a href="#type-maybe">maybe</a>(number())]</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a list of maybe-numbers indeed, and
 returns it.
</p>

<h3 class="function"><a name="check_maybe_pid-1">check_maybe_pid/1</a></h3>
<div class="spec">
<p><code>check_maybe_pid(Pid::term()) -&gt; <a href="#type-maybe">maybe</a>(pid())</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a PID indeed or the 'undefined' atom,
 and returns it.
</p>

<h3 class="function"><a name="check_maybe_positive_float-1">check_maybe_positive_float/1</a></h3>
<div class="spec">
<p><code>check_maybe_positive_float(Float::term()) -&gt; <a href="#type-maybe">maybe</a>(float())</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a maybe-(positive float) indeed, and
 returns it.
</p>

<h3 class="function"><a name="check_maybe_positive_integer-1">check_maybe_positive_integer/1</a></h3>
<div class="spec">
<p><code>check_maybe_positive_integer(Int::term()) -&gt; <a href="#type-maybe">maybe</a>(pos_integer())</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a positive or null integer or the
 'undefined' atom, and returns it.
</p>

<h3 class="function"><a name="check_maybe_strictly_positive_float-1">check_maybe_strictly_positive_float/1</a></h3>
<div class="spec">
<p><code>check_maybe_strictly_positive_float(Float::term()) -&gt; <a href="#type-maybe">maybe</a>(float())</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a maybe-(strictly positive float)
 indeed, and returns it.
</p>

<h3 class="function"><a name="check_number-1">check_number/1</a></h3>
<div class="spec">
<p><code>check_number(Num::term()) -&gt; number()</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a number indeed, and returns it.</p>

<h3 class="function"><a name="check_numbers-1">check_numbers/1</a></h3>
<div class="spec">
<p><code>check_numbers(Numbers::term()) -&gt; [number()]</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a list of numbers indeed, and returns
 it.
</p>

<h3 class="function"><a name="check_pid-1">check_pid/1</a></h3>
<div class="spec">
<p><code>check_pid(Pid::term()) -&gt; pid()</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a PID indeed, and returns it.</p>

<h3 class="function"><a name="check_pids-1">check_pids/1</a></h3>
<div class="spec">
<p><code>check_pids(Pids::term()) -&gt; [pid()]</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a list of PIDs indeed, and returns it.</p>

<h3 class="function"><a name="check_positive_float-1">check_positive_float/1</a></h3>
<div class="spec">
<p><code>check_positive_float(Float::term()) -&gt; float()</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a positive (or null) float indeed, and
 returns it.
</p>

<h3 class="function"><a name="check_positive_floats-1">check_positive_floats/1</a></h3>
<div class="spec">
<p><code>check_positive_floats(Floats::term()) -&gt; [float()]</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a list of positive (or null) floats
 indeed, and returns it.
</p>

<h3 class="function"><a name="check_positive_integer-1">check_positive_integer/1</a></h3>
<div class="spec">
<p><code>check_positive_integer(Int::term()) -&gt; pos_integer()</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a positive or null integer, and returns
 it.
</p>

<h3 class="function"><a name="check_positive_number-1">check_positive_number/1</a></h3>
<div class="spec">
<p><code>check_positive_number(Num::term()) -&gt; number()</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a positive or null number indeed, and
 returns it.
</p>

<h3 class="function"><a name="check_strictly_positive_float-1">check_strictly_positive_float/1</a></h3>
<div class="spec">
<p><code>check_strictly_positive_float(Float::term()) -&gt; float()</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a strictly positive float indeed, and
 returns it.
</p>

<h3 class="function"><a name="check_strictly_positive_integer-1">check_strictly_positive_integer/1</a></h3>
<div class="spec">
<p><code>check_strictly_positive_integer(Int::term()) -&gt; pos_integer()</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a strictly positive integer, and
 returns it.
</p>

<h3 class="function"><a name="check_strictly_positive_number-1">check_strictly_positive_number/1</a></h3>
<div class="spec">
<p><code>check_strictly_positive_number(Num::term()) -&gt; number()</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a strictly positive number indeed, and
 returns it.
</p>

<h3 class="function"><a name="check_tuple-1">check_tuple/1</a></h3>
<div class="spec">
<p><code>check_tuple(Tuple::term()) -&gt; tuple()</code><br></p>
<p> </p>
</div><p>Checks that the specified term is a tuple indeed, and returns it.</p>

<h3 class="function"><a name="description_to_type-1">description_to_type/1</a></h3>
<div class="spec">
<p><code>description_to_type(TypeDescription::<a href="#type-type_description">type_description()</a>) -&gt; <a href="#type-type">type()</a></code><br></p>
<p> </p>
</div><p><p>Returns the actual type corresponding to specified type description: 
parses the specified string to determine the type described therein.</p>

 Note: returns a correct type, but currently rarely the expected, most precise
 one.
</p>

<h3 class="function"><a name="ensure_binary-1">ensure_binary/1</a></h3>
<div class="spec">
<p><code>ensure_binary(S::term()) -&gt; <a href="#type-ustring">ustring()</a></code><br></p>
<p> </p>
</div><p>Ensures that the specified term is a binary string, and returns it.</p>

<h3 class="function"><a name="ensure_ceiled_integer-1">ensure_ceiled_integer/1</a></h3>
<div class="spec">
<p><code>ensure_ceiled_integer(N::number()) -&gt; integer()</code><br></p>
<p> </p>
</div><p><p>Ensures that the specified term is an integer, and returns it.</p>

 If it is a float, will return a ceiled (rounded-up integer) version of it.
</p>

<h3 class="function"><a name="ensure_float-1">ensure_float/1</a></h3>
<div class="spec">
<p><code>ensure_float(N::number()) -&gt; float()</code><br></p>
<p> </p>
</div><p><p>Ensures that the specified term is a float, and returns it.</p>

 <p>If it is an integer, will return a floating-point version of it.</p>

 Yet float/1 mostly suffices (as it can can operate on floats).
</p>

<h3 class="function"><a name="ensure_floored_integer-1">ensure_floored_integer/1</a></h3>
<div class="spec">
<p><code>ensure_floored_integer(N::number()) -&gt; integer()</code><br></p>
<p> </p>
</div><p><p>Ensures that the specified term is an integer, and returns it.</p>

 If it is a float, will return a floored (rounded-down integer) version of it.
</p>

<h3 class="function"><a name="ensure_integer-1">ensure_integer/1</a></h3>
<div class="spec">
<p><code>ensure_integer(N::number()) -&gt; integer()</code><br></p>
<p> </p>
</div><p><p>Ensures that the specified term is an integer, and returns it.</p>

 If it is a float, will return a truncated (integer) version of it.
</p>

<h3 class="function"><a name="ensure_positive_float-1">ensure_positive_float/1</a></h3>
<div class="spec">
<p><code>ensure_positive_float(F::number()) -&gt; float()</code><br></p>
<p> </p>
</div><p><p>Ensures that the specified term is a positive (possibly null) float, and 
returns it.</p>

 If it is an integer, will return a floating-point version of it.
</p>

<h3 class="function"><a name="ensure_rounded_integer-1">ensure_rounded_integer/1</a></h3>
<div class="spec">
<p><code>ensure_rounded_integer(N::number()) -&gt; integer()</code><br></p>
<p> </p>
</div><p><p>Ensures that the specified term is an integer, and returns it.</p>

 If it is a float, will return a rounded (integer) version of it.
</p>

<h3 class="function"><a name="ensure_string-1">ensure_string/1</a></h3>
<div class="spec">
<p><code>ensure_string(S::term()) -&gt; <a href="#type-ustring">ustring()</a></code><br></p>
<p> </p>
</div><p>Ensures that the specified term is a string, and returns it.</p>

<h3 class="function"><a name="get_ast_simple_builtin_types-0">get_ast_simple_builtin_types/0</a></h3>
<div class="spec">
<p><code>get_ast_simple_builtin_types() -&gt; [<a href="#type-type_name">type_name()</a>]</code><br></p>
<p> </p>
</div><p><p>Returns a list of the possible types for immediate values (typically 
found in an AST like, like 'undefined' in: {atom,42,undefined}).</p>

 <p>From <a href="http://erlang.org/doc/apps/erts/absform.html" target="_top"><code>http://erlang.org/doc/apps/erts/absform.html</code></a>:</p>

 <p>"There are five kinds of atomic literals, which are represented in the same 
way in patterns, expressions, and guards:</p>

 <p>- If L is an atom literal, then Rep(L) = {atom,LINE,L}.</p>

 <p>- If L is a character literal, then Rep(L) = {char,LINE,L}.</p>

 <p>- If L is a float literal, then Rep(L) = {float,LINE,L}.</p>

 <p>- If L is an integer literal, then Rep(L) = {integer,LINE,L}.</p>

 <p>- If L is a string literal consisting of the characters C_1, ..., C_k, then 
Rep(L) = {string,LINE,[C_1, ..., C_k]}."</p>

 Actually additional types can be found in ASTs.
</p>

<h3 class="function"><a name="get_elementary_types-0">get_elementary_types/0</a></h3>
<div class="spec">
<p><code>get_elementary_types() -&gt; [<a href="#type-type_name">type_name()</a>]</code><br></p>
<p> </p>
</div><p>Returns a list of the elementary, "atomic" types.</p>

<h3 class="function"><a name="get_immediate_types-0">get_immediate_types/0</a></h3>
<div class="spec">
<p><code>get_immediate_types() -&gt; [<a href="#type-type_name">type_name()</a>]</code><br></p>
<p> </p>
</div><p>Returns a list of the possible types for immediate values.</p>

<h3 class="function"><a name="get_last_tuple_element-1">get_last_tuple_element/1</a></h3>
<div class="spec">
<p><code>get_last_tuple_element(Tuple::tuple()) -&gt; term()</code><br></p>
<p> </p>
</div><p>Returns the last element of the specified tuple.</p>

<h3 class="function"><a name="get_low_level_type_size-1">get_low_level_type_size/1</a></h3>
<div class="spec">
<p><code>get_low_level_type_size(X1::<a href="#type-low_level_type">low_level_type()</a>) -&gt; <a href="#type-byte_size">byte_size()</a></code><br></p>
<p> </p>
</div><p>Returns the number of bytes used by each value of the specified low-level
 type.
</p>

<h3 class="function"><a name="get_record_tag-1">get_record_tag/1</a></h3>
<div class="spec">
<p><code>get_record_tag(RecordTuple::<a href="#type-record">record()</a>) -&gt; <a href="#type-record_tag">record_tag()</a></code><br></p>
<p> </p>
</div><p>Returns the tag of the specified record instance.</p>

<h3 class="function"><a name="get_simple_builtin_types-0">get_simple_builtin_types/0</a></h3>
<div class="spec">
<p><code>get_simple_builtin_types() -&gt; [<a href="#type-type_name">type_name()</a>]</code><br></p>
<p> </p>
</div><p>Returns a list of the built-in, non-polymorphic types that can be
 typically found in AST forms.
</p>

<h3 class="function"><a name="get_type_of-1">get_type_of/1</a></h3>
<div class="spec">
<p><code>get_type_of(Term::term()) -&gt; <a href="#type-primitive_type_description">primitive_type_description()</a></code><br></p>
<p> </p>
</div><p><p>Returns an atom describing, as precisely as possible, the overall type of 
the specified primitive term.</p>

 <p>Note: limited to primitive types, not compounded ones (like [float()]).</p>

 <p>is_number/1, is_record/1, etc. not usable here.</p>

 <p>Note: often we do not want to retrieve the actual type of a term but need 
instead to determine whether the term can be considered as an instance of a 
specific type (this is not strictly the same need, as a given term in general 
may be seen of being of multiple types).</p>

 The lowest-level/most precising typing can be obtained with the (undocumented)
 erts_internal:term_type/1 function.
</p>

<h3 class="function"><a name="increment_counter-2">increment_counter/2</a></h3>
<div class="spec">
<p><code>increment_counter(CounterIndex::<a href="#type-positive_index">positive_index()</a>, Counters::<a href="#type-counters">counters()</a>) -&gt; <a href="#type-counters">counters()</a></code><br></p>
<p> </p>
</div><p>Increments the specified counter.</p>

<h3 class="function"><a name="initialise_counters-1">initialise_counters/1</a></h3>
<div class="spec">
<p><code>initialise_counters(Count::<a href="#type-count">count()</a>) -&gt; <a href="#type-counters">counters()</a></code><br></p>
<p> </p>
</div><p>Initialises the specified number of counters to zero.</p>

<h3 class="function"><a name="initialise_counters-2">initialise_counters/2</a></h3>
<div class="spec">
<p><code>initialise_counters(Count::<a href="#type-count">count()</a>, InitValue::integer()) -&gt; <a href="#type-counters">counters()</a></code><br></p>
<p> </p>
</div><p>Initialises the specified number of counters to the specified (initial)
 value.
</p>

<h3 class="function"><a name="interpret_type_of-1">interpret_type_of/1</a></h3>
<div class="spec">
<p><code>interpret_type_of(Term::term()) -&gt; <a href="#type-ustring">ustring()</a></code><br></p>
<p> </p>
</div><p>Returns a string describing, in a user-friendly manner, the type of the
 specified term (up to one level of nesting detailed).
</p>

<h3 class="function"><a name="interpret_type_of-2">interpret_type_of/2</a></h3>
<div class="spec">
<p><code>interpret_type_of(Term::term(), MaxNestingLevel::<a href="#type-level">level()</a> | infinite) -&gt; <a href="#type-ustring">ustring()</a></code><br></p>
<p> </p>
</div><p>Returns a string describing, in a user-friendly manner, the type of the
 specified term, up to the specified nesting level (either a positive integer
 or the 'infinite' atom, to go as deep as possible in the term structure).
</p>

<h3 class="function"><a name="is_homogeneous-1">is_homogeneous/1</a></h3>
<div class="spec">
<p><code>is_homogeneous(List::list() | tuple()) -&gt; {true, <a href="#type-primitive_type_description">primitive_type_description()</a>} | {false, {<a href="#type-primitive_type_description">primitive_type_description()</a>, <a href="#type-primitive_type_description">primitive_type_description()</a>}}</code><br></p>
<p> </p>
</div><p><p>Tells whether specified non-empty monomorphic container (list or tuple) 
is homogeneous in terms of type, ie whether all its elements are of the same 
type.</p>

 If true, returns the common type.
 If false, returns two of the different types found in the container.
</p>

<h3 class="function"><a name="is_homogeneous-2">is_homogeneous/2</a></h3>
<div class="spec">
<p><code>is_homogeneous(List::list() | tuple(), Type::<a href="#type-primitive_type_description">primitive_type_description()</a>) -&gt; boolean()</code><br></p>
<p> </p>
</div><p>Tells whether specified non-empty monomorphic container (list or tuple)
 is homogeneous in terms of type, that is whether all its elements are of the
 same, specified, primitive type.
</p>

<h3 class="function"><a name="is_of_described_type-2">is_of_described_type/2</a></h3>
<div class="spec">
<p><code>is_of_described_type(Term::term(), TypeDescription::<a href="#type-type_description">type_description()</a>) -&gt; boolean()</code><br></p>
<p> </p>
</div><p><p>Tells whether the specified term is of specified textually-described 
type.</p>

 Note: currently no checking is made and the test always succeeds.
</p>

<h3 class="function"><a name="is_of_type-2">is_of_type/2</a></h3>
<div class="spec">
<p><code>is_of_type(Term::term(), Type::<a href="#type-type">type()</a>) -&gt; boolean()</code><br></p>
<p> </p>
</div><p><p>Tells whether specified term is of specified type (predicate).</p>

 Note: currently only a very partial checking is made, based on top-level
 primitive types; later the type will be recursed into, in order to check
 whether the term complies with this expected structure.
</p>

<h3 class="function"><a name="is_transient-1">is_transient/1</a></h3>
<div class="spec">
<p><code>is_transient(T::term()) -&gt; boolean()</code><br></p>
<p> </p>
</div><p>Tells whether the specified term is, just by itself, a transient one.</p>

<h3 class="function"><a name="is_type-1">is_type/1</a></h3>
<div class="spec">
<p><code>is_type(T::term()) -&gt; boolean()</code><br></p>
<p> </p>
</div><p><p>Tells whether specified term designates a type (ie a type() instance).</p>

 (only the elementary types are currently recognised)
</p>

<h3 class="function"><a name="share-1">share/1</a></h3>
<div class="spec">
<p><code>share(Other::term()) -&gt; term()</code><br></p>
<p> </p>
</div><p><p>Improves the compactness of the specified term ("compresses it"): returns 
it once the sharing of its sub-terms has been favored (equal term, but 
possibly smaller in memory).</p>

 <p>Presumably useful on platforms where the size of a pointer is lower than the 
one of the subterms (e.g. an Erlang float, i.e. a double), when some subterms 
may be equal (by value), yet are duplicated (not defined once and pointed to 
multiple times).</p>

 <p>Such a deduplication may happen typically on homogeneous tuples 
(e.g. vectors), when received as messages for example, or when read from any 
external source (e.g. from file).</p>

 Directly inspired from wings_utils:share/*.
</p>

<h3 class="function"><a name="share-2">share/2</a></h3>
<div class="spec">
<p><code>share(X::term(), Y::term()) -&gt; <a href="#type-pair">pair()</a></code><br></p>
<p> </p>
</div><p><p>Returns the two specified terms as a pair favoring the in-memory sharing 
of its elements, if they are equal.</p>

 <p>Presumably useful on platforms where the size of a pointer is lower than the 
one of the subterms (e.g. an Erlang float, i.e. a double), when some subterms 
may be equal (by value), yet are duplicated (not defined once and pointed to 
multiple times).</p>

 Directly inspired from wings_utils:share/*.
</p>

<h3 class="function"><a name="share-3">share/3</a></h3>
<div class="spec">
<p><code>share(X::term(), Y::term(), Z::term()) -&gt; <a href="#type-triplet">triplet()</a></code><br></p>
<p> </p>
</div><p><p>Returns the three specified terms as a triplet favoring the in-memory 
sharing of its elements, if they are equal.</p>

 <p>Presumably useful on platforms where the size of a pointer is lower than the 
one of the subterms (e.g. an Erlang float, i.e. a double), when some subterms 
may be equal (by value), yet are duplicated (not defined once and pointed to 
multiple times).</p>

 Directly inspired from wings_utils:share/*.
</p>

<h3 class="function"><a name="tokenise_per_union-1">tokenise_per_union/1</a></h3>
<div class="spec">
<p><code>tokenise_per_union(TypeDescription::<a href="#type-type_description">type_description()</a>) -&gt; [<a href="#type-type_description">type_description()</a>]</code><br></p>
<p> </p>
</div><p>Splits the specified type description according to union delimiters</p>

<h3 class="function"><a name="type_to_description-1">type_to_description/1</a></h3>
<div class="spec">
<p><code>type_to_description(Type::<a href="#type-type">type()</a>) -&gt; <a href="#type-type_description">type_description()</a></code><br></p>
<p> </p>
</div><p><p>Returns the type description (in canonical form, notably without 
whitespaces) corresponding to specified type.</p>

 Note: currently does not return a really relevant type description; basically
 meant to be the function reciprocal to scan_type/1.
</p>

<h3 class="function"><a name="type_to_string-1">type_to_string/1</a></h3>
<div class="spec">
<p><code>type_to_string(Type::<a href="#type-type">type()</a>) -&gt; <a href="#type-ustring">ustring()</a></code><br></p>
<p> </p>
</div><p>Returns a textual representation of the specified type.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
