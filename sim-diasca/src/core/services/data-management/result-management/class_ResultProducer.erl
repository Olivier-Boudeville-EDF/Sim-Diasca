% Copyright (C) 2010-2021 EDF R&D

% This file is part of Sim-Diasca.

% Sim-Diasca is free software: you can redistribute it and/or modify
% it under the terms of the GNU Lesser General Public License as
% published by the Free Software Foundation, either version 3 of
% the License, or (at your option) any later version.

% Sim-Diasca is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
% GNU Lesser General Public License for more details.

% You should have received a copy of the GNU Lesser General Public
% License along with Sim-Diasca.
% If not, see <http://www.gnu.org/licenses/>.

% Author: Olivier Boudeville (olivier.boudeville@edf.fr)


-module(class_ResultProducer).


-define( class_description,
		 "Base class for all result producers. "
		 "It allows them to be declared automatically to the result manager, "
		 "and provides the basic behaviour so that they can interact with "
		 "it. " ).


% Determines what are the direct mother classes of this class (if any):
-define( superclasses, [ class_EngineBaseObject ] ).


% The class-specific attributes of a result producer:
-define( class_attributes, [

	{ result_manager_pid, result_manager_pid(),
	  "the PID of the result manager, necessary for a producer to declare its "
	  "outputs before being fed with data" },

	{ enabled_producer, boolean(), "tells whether the outputs of this producer "
	  "have a chance of being of interest for the simulation; if "
	  "false, then the producer may simply drop incoming samples, if not being "
	  "asked by the data source(s) that are using it about its enable status: "
	  "it is still better to have data sources stop sending samples instead of "
	  "having the producer drop them on receiving" },

	{ result_produced, boolean(), "tells whether this producer already fully "
	  "generated its expected results" },

	{ result_collected, boolean(), "tells whether the results generated by "
	  "this producer have been already collected (by the result manager)" } ] ).



% Type section.

-type producer_name() :: string().
-type bin_producer_name() :: text_utils:ustring().

-type producer_pid() :: sim_diasca:agent_pid().

% Describes the types of output expected from a producer:
-type producer_option() :: 'data_only'
						 | 'rendering_only'
						 | 'data_and_rendering'.

-type producer_options() :: producer_option() | [ producer_option() ].



% Describes the precise nature of a result producer:
-type producer_nature() ::
		maybe( 'basic_probe' | 'virtual_probe' | 'web_probe' ).


% Possible terms returned by a producer after results have been sent to it.
%
% It is:
%
% - {self(), archive, BinArchive} where BinArchive is a binary corresponding to
% a ZIP archive of a set of files (ex: data and command file)
%
% - or {self(), raw, {BinFilename, BinContent}} where BinFilename is the
% filename (as a binary) of the transferred file, and BinContent is a binary of
% its content (ex: a PNG file, which should better not be transferred as an
% one-file archive)
%
% - or {self(), no_result} should no result be to return
%
-type producer_result() ::
		{ producer_pid(), 'archive', binary() }
	  | { producer_pid(), 'raw', { file_utils:bin_file_name(), binary() } }
	  | { producer_pid(), 'no_result' }.


-export_type([ producer_name/0, bin_producer_name/0, producer_pid/0,
			   producer_option/0, producer_options/0,
			   producer_nature/0, producer_result/0 ]).



% Allows to define WOOPER base variables and methods for that class:
-include_lib("wooper/include/wooper.hrl").


% Must be included before class_TraceEmitter header:
-define( trace_emitter_categorization, "Core.ResultManagement.ResultProducer" ).


% Allows to use macros for trace sending:
-include_lib("traces/include/class_TraceEmitter.hrl").

% For result_manager_name:
-include("class_ResultManager.hrl").


% Shorthand:
%-type result_manager_pid() :: class_ResultManager:manager_pid().



% Constructs a new result producer.
%
% ProducerName is the name of this producer, specified as a plain string.
%
-spec construct( wooper:state(), producer_name() ) -> wooper:state().
construct( State, ProducerName ) ->

	% First the direct mother classes:
	TraceState = class_EngineBaseObject:construct( State,
									?trace_categorize(ProducerName) ),

	TrackerPid = class_InstanceTracker:get_local_tracker(),

	{ _SameState, BinName } = executeRequest( TraceState, getName ),

	TrackerPid ! { registerResultProducer, BinName, self() },

	% Then look-up the result manager, so that the actual producer child class
	% can send a notification to it later.
	%
	% As the deployment is synchronous, the manager must already be available
	% (no specific waiting to perform):
	%
	ResultManagerPid =
		naming_utils:get_registered_pid_for( ?result_manager_name, global ),

	% We link a result producer to its manager, as the producer may fail whereas
	% any linked process (typically its creating actor) has already terminated
	% (normally); in this case any failure of the producer would be silent
	% (potentially detected only when the result manager raises a time-out).
	%
	erlang:link( ResultManagerPid ),

	%?send_debug_fmt( TraceState, "Creating result producer '~ts'.",
	%				[ ProducerName ] ),

	% Deferred reception for registerResultProducer:
	receive

		{ wooper_result, result_producer_registered } ->
			ok

	end,

	setAttributes( TraceState, [
		{ result_manager_pid, ResultManagerPid },

		% By default:
		{ enabled_producer, true },

		{ result_produced, false },
		{ result_collected, false } ] ).




% Overridden destructor.
-spec destruct( wooper:state() ) -> wooper:state().
destruct( State ) ->

	% Class-specific actions:

	%?info( "Deleting result producer." ),

	case ?getAttr(result_produced) of

		true ->

			case ?getAttr(result_collected) of

				true ->
					ok;

				false ->
					throw( result_produced_yet_not_collected )

			end;

		false ->
			throw( { result_not_produced,
					 text_utils:binary_to_string( ?getAttr(name) ) } )

	end,

	TrackerPid = class_InstanceTracker:get_local_tracker(),

	TrackerPid ! { unregisterResultProducer, self() },

	% Then call the direct mother class counterparts and allow chaining:
	State.




% Methods section.


% Sets the enable status for this producer.
-spec setEnableStatus( wooper:state(), boolean() ) -> oneway_return().
setEnableStatus( State, NewStatus ) ->
	wooper:return_state(
				 setAttribute( State, enabled_producer, NewStatus ) ).



% Returns true iff the outputs of that producer are enabled.
-spec getEnableStatus( wooper:state() ) -> const_request_return( boolean() ).
getEnableStatus( State ) ->
	wooper:const_return_result( ?getAttr(enabled_producer) ).



% Sends the specified results to the caller (generally the result manager).
%
% Note: must be overridden by the actual result producer.
%
% It is expected to return either:
%
% - {self(), archive, BinArchive} where BinArchive is a binary corresponding to
% a ZIP archive of a set of files (ex: data and command file)
%
% - or {self(), raw, { BinFilename, BinContent}} where BinFilename is the
% filename (as a binary) of the transferred file, and BinContent is a binary of
% its content (ex: a PNG file, which should better not be transferred as an
% archive)
%
% - or {self(), no_result} should no result be to return
%
% The PID of the producer is sent, so that the caller is able to discriminate
% between multiple parallel calls.
%
% (const request, for synchronous yet concurrent operations)
%
-spec sendResults( wooper:state(), producer_options() ) ->
						const_request_return( producer_result() ).
sendResults( _State, _Options ) ->
	throw( result_sending_not_implemented ).



% Forces the status of this producer regarding its results being produced or
% not.
%
-spec setResultProducedStatus( wooper:state(), boolean() ) ->
									oneway_return().
setResultProducedStatus( State, AreProduced ) ->
	wooper:return_state( setAttribute( State, result_produced, AreProduced ) ).



% Forces the status of this producer regarding its results being collected or
% not.
%
-spec setResultCollectedStatus( wooper:state(), boolean() ) ->
									oneway_return().
setResultCollectedStatus( State, AreCollected ) ->
	wooper:return_state(
	  setAttribute( State, result_collected, AreCollected ) ).



% Static section.


% Returns a list of all possible generation-time options for result producers.
-spec get_producer_options() -> static_return( [ producer_option() ] ).
get_producer_options() ->
	wooper:return_static( [ data_only, rendering_only, data_and_rendering ] ).
