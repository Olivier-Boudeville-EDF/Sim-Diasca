% Copyright (C) 2010-2022 EDF R&D

% This file is part of Sim-Diasca.

% Sim-Diasca is free software: you can redistribute it and/or modify
% it under the terms of the GNU Lesser General Public License as
% published by the Free Software Foundation, either version 3 of
% the License, or (at your option) any later version.

% Sim-Diasca is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
% GNU Lesser General Public License for more details.

% You should have received a copy of the GNU Lesser General Public
% License along with Sim-Diasca.
% If not, see <http://www.gnu.org/licenses/>.

% Author: Olivier Boudeville (olivier.boudeville@edf.fr)
% Creation date: 2010.


% @doc Base class for all <b>result producers</b>.
-module(class_ResultProducer).


-define( class_description,
		 "Base class for all result producers. "
		 "It allows them to be declared automatically to the result manager, "
		 "and provides the basic behaviour so that they can interact with "
		 "it. " ).


% Determines what are the direct mother classes of this class (if any):
-define( superclasses, [ class_EngineBaseObject ] ).


% The class-specific attributes of a result producer:
-define( class_attributes, [

	{ result_manager_pid, result_manager_pid(),
	  "the PID of the result manager, necessary for a producer to declare its "
	  "outputs before being fed with data" },

	{ enabled_producer, boolean(), "tells whether the outputs of this producer "
	  "have a chance of being of interest for the simulation; if "
	  "false, then the producer may simply drop incoming samples, if not being "
	  "asked by the data source(s) that are using it about its enable status: "
	  "it is still better to have data sources stop sending samples instead of "
	  "having the producer drop them on receiving" },

	{ result_produced, boolean(), "tells whether this producer already fully "
	  "generated its expected results" },

	{ result_collected, boolean(), "tells whether the results generated by "
	  "this producer have been already collected (by the result manager)" } ] ).



% Type section.

-type producer_name() :: ustring().
-type bin_producer_name() :: ustring().

-type producer_pid() :: sim_diasca:agent_pid().


-type producer_option() :: 'data_only'
						 | 'rendering_only'
						 | 'data_and_rendering'.
% Describes the types of output expected from a result producer.


-type producer_options() :: producer_option() | [ producer_option() ].


-type producer_nature() ::
		maybe( 'basic_probe' | 'virtual_probe' | 'web_probe'
			 | 'graph_stream_probe' ).
% Describes the precise nature of a result producer.



-type producer_result() ::
		{ producer_pid(), 'archive', binary() }
	  | { producer_pid(), 'raw', { file_utils:bin_file_name(), binary() } }
	  | { producer_pid(), 'no_result' }.
% Possible terms returned by a producer in terms of results.
%
% It is:
%
% - {self(), archive, BinArchive} where BinArchive is a binary corresponding to
% a ZIP archive of a set of files (ex: data and command files)
%
% - or {self(), raw, {BinFilename, BinContent}} where BinFilename is the
% filename (as a binary) of the transferred file, and BinContent is a binary of
% its content (ex: a PNG file - which should better not be transferred as an
% one-file archive)
%
% - or {self(), no_result} should no result be to return


-export_type([ producer_name/0, bin_producer_name/0, producer_pid/0,
			   producer_option/0, producer_options/0,
			   producer_nature/0, producer_result/0 ]).



% Allows to define WOOPER base variables and methods for that class:
-include_lib("wooper/include/wooper.hrl").


% Must be included before class_TraceEmitter header:
-define( trace_emitter_categorization, "Core.ResultManagement.ResultProducer" ).


% Allows to use macros for trace sending:
-include_lib("traces/include/class_TraceEmitter.hrl").

% For result_manager_name:
-include("class_ResultManager.hrl").


% Shorthands:

-type ustring() :: text_utils:ustring().

%-type result_manager_pid() :: class_ResultManager:manager_pid().



% @doc Constructs a result producer.
%
% ProducerName is the name of this producer, specified as a plain string.
%
-spec construct( wooper:state(), producer_name() ) -> wooper:state().
construct( State, ProducerName ) ->

	% First the direct mother classes:
	TraceState = class_EngineBaseObject:construct( State,
									?trace_categorize(ProducerName) ),

	TrackerPid = class_InstanceTracker:get_local_tracker(),

	{ _SameState, BinName } = executeRequest( TraceState, getName ),

	TrackerPid ! { registerResultProducer, BinName, self() },

	% Then look-up the result manager, so that the actual producer child class
	% can send a notification to it later.
	%
	% As the deployment is synchronous, the manager must already be available
	% (no specific waiting to perform):
	%
	ResultManagerPid =
		naming_utils:get_registered_pid_for( ?result_manager_name, global ),

	% We link a result producer to its manager, as the producer may fail whereas
	% any linked process (typically its creating actor) has already terminated
	% (normally); in this case any failure of the producer would be silent
	% (potentially detected only when the result manager raises a time-out).
	%
	erlang:link( ResultManagerPid ),

	%?send_debug_fmt( TraceState, "Creating result producer '~ts'.",
	%                 [ ProducerName ] ),

	ConstructState = setAttributes( TraceState, [
		{ result_manager_pid, ResultManagerPid },

		% By default:
		{ enabled_producer, true },

		{ result_produced, false },
		{ result_collected, false } ] ),

	% Deferred reception for registerResultProducer/3:
	receive

		{ wooper_result, result_producer_registered } ->
			ok

	end,

	ConstructState.



% @doc Overridden destructor.
-spec destruct( wooper:state() ) -> wooper:state().
destruct( State ) ->

	% Class-specific actions:

	%?info( "Deleting result producer." ),

	case ?getAttr(result_produced) of

		true ->
			?getAttr(result_collected) orelse
				throw( result_produced_yet_not_collected );

		false ->
			throw( { result_not_produced,
					 text_utils:binary_to_string( ?getAttr(name) ) } )

	end,

	TrackerPid = class_InstanceTracker:get_local_tracker(),

	TrackerPid ! { unregisterResultProducer, self() },

	% Then call the direct mother class counterparts and allow chaining:
	State.




% Methods section.


% @doc Sets the enable status for this producer.
-spec setEnableStatus( wooper:state(), boolean() ) -> oneway_return().
setEnableStatus( State, NewStatus ) ->
	wooper:return_state(
				setAttribute( State, enabled_producer, NewStatus ) ).



% @doc Returns whether the outputs of that producer are enabled.
-spec getEnableStatus( wooper:state() ) -> const_request_return( boolean() ).
getEnableStatus( State ) ->
	wooper:const_return_result( ?getAttr(enabled_producer) ).



% @doc Sends the specified results to the caller (generally the result manager).
%
% Note: must be overridden by the actual result producer.
%
% It is expected to return either:
%
% - {self(), archive, BinArchive} where BinArchive is a binary corresponding to
% a ZIP archive of a set of files (ex: data and command file)
%
% - or {self(), raw, {BinFilename, BinContent}} where BinFilename is the
% filename (as a binary) of the transferred file, and BinContent is a binary of
% its content (ex: a PNG file, which should better not be transferred as an
% archive)
%
% - or {self(), no_result} should no result be to return
%
% The PID of the producer is sent, so that the caller is able to discriminate
% between multiple parallel calls.
%
% (const request, for synchronous yet concurrent operations)
%
-spec sendResults( wooper:state(), producer_options() ) ->
						const_request_return( producer_result() ).
sendResults( _State, _Options ) ->
	throw( result_sending_not_implemented ).



% @doc Forces the status of this producer, regarding its results being produced
% or not.
%
-spec setResultProducedStatus( wooper:state(), boolean() ) -> oneway_return().
setResultProducedStatus( State, AreProduced ) ->
	wooper:return_state( setAttribute( State, result_produced, AreProduced ) ).



% @doc Forces the status of this producer regarding its results being collected
% or not.
%
-spec setResultCollectedStatus( wooper:state(), boolean() ) -> oneway_return().
setResultCollectedStatus( State, AreCollected ) ->
	wooper:return_state(
		setAttribute( State, result_collected, AreCollected ) ).



% Static section.


% @doc Returns a list of all possible generation-time options for result
% producers.
%
-spec get_producer_options() -> static_return( [ producer_option() ] ).
get_producer_options() ->
	wooper:return_static( [ data_only, rendering_only, data_and_rendering ] ).
