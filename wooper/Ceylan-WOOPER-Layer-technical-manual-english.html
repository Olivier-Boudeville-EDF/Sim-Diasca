<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.13.1: http://docutils.sourceforge.net/" />
<title>Welcome to the Ceylan-WOOPER documentation</title>
<meta content="WOOPER, OOP, inheritance, object-oriented, Erlang" name="keywords" />
<link rel="stylesheet" href="pygments-default.css" type="text/css" />
<link rel="stylesheet" href="wooper.css" type="text/css" />
<link href="wooper-icon.png" rel="icon">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
<div class="document" id="wrapper-for-object-oriented-programming-in-erlang">
<h1 class="title"><em>Wrapper for Object-Oriented Programming in Erlang</em></h1>

<span class="target" id="top"></span><p><span class="raw-html"><a name="wooper_top"></a></span></p>
<p><span class="raw-html"><div class="banner"><p><em>WOOPER documentation</em> <a href="http://wooper.esperide.org">browse latest</a> <a href="https://olivier-boudeville.github.io/Ceylan-WOOPER/index.html">browse mirror</a> <a href="Ceylan-WOOPER-Layer-technical-manual-english.pdf">get PDF</a> <a href="#wooper_top">go to top</a> <a href="#wooper_toc">go to toc</a> <a href="#wooper_bottom">go to bottom</a> <a href="api-doc/index.html">browse API</a> <a href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER">go to project</a> <a href="mailto:about(dash)wooper(at)esperide(dot)com?subject=[Ceylan-WOOPER]%20Remark">email us</a></p></div></span></p>
<p><span class="raw-html"><center><img src="wooper-title.png" id="responsive-image-small"></img></span>
</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Organisation:</th><td class="field-body">Copyright (C) 2008-2022 Olivier Boudeville</td>
</tr>
<tr class="field"><th class="field-name">Contact:</th><td class="field-body">about (dash) wooper (at) esperide (dot) com</td>
</tr>
<tr class="field"><th class="field-name">Creation date:</th><td class="field-body">Sunday, August 17, 2008</td>
</tr>
<tr class="field"><th class="field-name">Lastly updated:</th><td class="field-body">Tuesday, January 11, 2022</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">2.0.15</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Stable</td>
</tr>
<tr class="field"><th class="field-name">Dedication:</th><td class="field-body">Users and maintainers of the <tt class="docutils literal">WOOPER</tt> layer.</td>
</tr>
<tr class="field"><th class="field-name">Abstract:</th><td class="field-body">The role of the <tt class="docutils literal">WOOPER</tt> layer is to provide free software object-oriented facilities to the Erlang language.</td>
</tr>
</tbody>
</table>
<p><span class="raw-html"></center></span></p>
<p>The latest version of this documentation is to be found at the <a class="reference external" href="http://wooper.esperide.org">official WOOPER website</a> (<tt class="docutils literal"><span class="pre">http://wooper.esperide.org</span></tt>).</p>
<p><span class="raw-html">This WOOPER documentation is also available in the PDF format (see <a href="Ceylan-WOOPER-Layer-technical-manual-english.pdf">Ceylan-WOOPER-Layer-technical-manual-english.pdf</a>), and mirrored <a href="http://olivier-boudeville.github.io/Ceylan-WOOPER/">here</a>.</span></p>
<p></p>
<p></p>
<p><span class="raw-html"><a name="wooper_toc"></a></span></p>
<div class="contents topic" id="id1">
<span id="table-of-contents"></span><p class="topic-title first"><strong>Table of Contents</strong></p>
<ul class="simple">
<li><a class="reference internal" href="#overview" id="id68">Overview</a></li>
<li><a class="reference internal" href="#understanding-wooper-in-two-steps" id="id69">Understanding WOOPER in Two Steps</a><ul>
<li><a class="reference internal" href="#motivations-purpose" id="id70">Motivations &amp; Purpose</a></li>
<li><a class="reference internal" href="#the-wooper-mode-of-operation-in-a-nutshell" id="id71">The WOOPER Mode of Operation in a Nutshell</a></li>
<li><a class="reference internal" href="#id2" id="id72">Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#why-adding-object-oriented-capabilities-to-erlang" id="id73">Why Adding Object-Oriented Capabilities To Erlang?</a></li>
<li><a class="reference internal" href="#how-to-use-wooper-detailed-description-concept-mappings" id="id74">How to Use WOOPER: Detailed Description &amp; Concept Mappings</a><ul>
<li><a class="reference internal" href="#classes" id="id75">Classes</a><ul>
<li><a class="reference internal" href="#classes-names" id="id76">Classes &amp; Names</a></li>
<li><a class="reference internal" href="#class-description" id="id77">Class Description</a></li>
<li><a class="reference internal" href="#inheritance-superclasses" id="id78">Inheritance &amp; Superclasses</a></li>
</ul>
</li>
<li><a class="reference internal" href="#instances" id="id79">Instances</a><ul>
<li><a class="reference internal" href="#instance-mapping" id="id80">Instance Mapping</a></li>
<li><a class="reference internal" href="#instance-state" id="id81">Instance State</a></li>
</ul>
</li>
<li><a class="reference internal" href="#methods" id="id82">Methods</a><ul>
<li><a class="reference internal" href="#method-declaration" id="id83">Method Declaration</a></li>
<li><a class="reference internal" href="#method-invocation" id="id84">Method Invocation</a></li>
<li><a class="reference internal" href="#method-name" id="id85">Method Name</a></li>
<li><a class="reference internal" href="#method-parameters" id="id86">Method Parameters</a></li>
<li><a class="reference internal" href="#two-kinds-of-member-methods" id="id87">Two Kinds of Member Methods</a></li>
<li><a class="reference internal" href="#method-results" id="id88">Method Results</a></li>
<li><a class="reference internal" href="#method-definition" id="id89">Method Definition</a></li>
<li><a class="reference internal" href="#for-requests" id="id90">For Requests</a></li>
<li><a class="reference internal" href="#for-oneways" id="id91">For Oneways</a></li>
<li><a class="reference internal" href="#usefulness-of-the-method-terminators" id="id92">Usefulness Of the Method Terminators</a></li>
<li><a class="reference internal" href="#self-invocation-calling-a-method-from-the-instance-itself" id="id93">Self-Invocation: Calling a Method From the Instance Itself</a></li>
<li><a class="reference internal" href="#static-methods" id="id94">Static Methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id25" id="id95">State Management</a><ul>
<li><a class="reference internal" href="#principles" id="id96">Principles</a></li>
<li><a class="reference internal" href="#state-implementation-details" id="id97">State Implementation Details</a></li>
<li><a class="reference internal" href="#managing-the-state-of-an-instance" id="id98">Managing the State of an Instance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#multiple-inheritance-polymorphism" id="id99">Multiple Inheritance &amp; Polymorphism</a><ul>
<li><a class="reference internal" href="#the-general-case" id="id100">The General Case</a></li>
<li><a class="reference internal" href="#the-special-case-of-diamond-shaped-inheritance" id="id101">The Special Case of Diamond-Shaped Inheritance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#life-cycle" id="id102">Life-Cycle</a><ul>
<li><a class="reference internal" href="#instance-creation-new-new-link-and-construct" id="id103">Instance Creation: <tt class="docutils literal">new</tt>/<tt class="docutils literal">new_link</tt> and <tt class="docutils literal">construct</tt></a></li>
<li><a class="reference internal" href="#instance-deletion" id="id104">Instance Deletion</a></li>
</ul>
</li>
<li><a class="reference internal" href="#passive-instances" id="id105">Passive Instances</a></li>
</ul>
</li>
<li><a class="reference internal" href="#miscellaneous-technical-points" id="id106">Miscellaneous Technical Points</a><ul>
<li><a class="reference internal" href="#helper-vs-static" id="id107">Helper vs Static</a></li>
<li><a class="reference internal" href="#calling-a-method-clause-from-another" id="id108">Calling a Method Clause from Another</a></li>
<li><a class="reference internal" href="#integrated-call-apis" id="id109">Integrated Call APIs</a><ul>
<li><a class="reference internal" href="#single-calls" id="id110">Single Calls</a></li>
<li><a class="reference internal" href="#multi-calls" id="id111">Multi-Calls</a></li>
</ul>
</li>
<li><a class="reference internal" href="#methods-not-returning-anything-of-interest" id="id112">Methods Not Returning Anything of Interest</a></li>
<li><a class="reference internal" href="#exception-throwing-methods" id="id113">Exception-Throwing Methods</a></li>
<li><a class="reference internal" href="#delete-any-instance-referenced-in-2" id="id114"><tt class="docutils literal">delete_any_instance_referenced_in/2</tt></a></li>
<li><a class="reference internal" href="#exit-signals-messages" id="id115"><tt class="docutils literal">EXIT</tt> Signals / Messages</a></li>
<li><a class="reference internal" href="#down-messages-for-process-monitors" id="id116"><tt class="docutils literal">DOWN</tt> Messages for Process Monitors</a></li>
<li><a class="reference internal" href="#node-monitors" id="id117">Node Monitors</a></li>
<li><a class="reference internal" href="#a-bit-of-introspection" id="id118">A bit of Introspection</a></li>
<li><a class="reference internal" href="#developer-guidelines" id="id119">Developer Guidelines</a><ul>
<li><a class="reference internal" href="#general-guidelines" id="id120">General Guidelines</a></li>
<li><a class="reference internal" href="#otp-guidelines" id="id121">OTP Guidelines</a></li>
</ul>
</li>
<li><a class="reference internal" href="#wooper-api" id="id122">WOOPER API</a></li>
<li><a class="reference internal" href="#class-developer-cheat-sheet" id="id123">Class Developer Cheat Sheet</a></li>
<li><a class="reference internal" href="#source-editors" id="id124">Source Editors</a></li>
<li><a class="reference internal" href="#similarity-with-other-languages" id="id125">Similarity With other Languages</a></li>
<li><a class="reference internal" href="#wooper-limitations" id="id126">WOOPER limitations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#wooper-example" id="id127">WOOPER Example</a><ul>
<li><a class="reference internal" href="#class-implementations" id="id128">Class implementations</a></li>
<li><a class="reference internal" href="#tests" id="id129">Tests</a></li>
</ul>
</li>
<li><a class="reference internal" href="#good-practices" id="id130">Good Practices</a></li>
<li><a class="reference internal" href="#supported-platforms" id="id131">Supported Platforms</a></li>
<li><a class="reference internal" href="#troubleshooting" id="id132">Troubleshooting</a><ul>
<li><a class="reference internal" href="#debug-mode" id="id133">Debug Mode</a></li>
<li><a class="reference internal" href="#no-attribute-declaration-found-whereas-a-class-attributes-define-exists" id="id134">&quot;No attribute declaration found&quot; whereas a <tt class="docutils literal">class_attributes</tt> define exists</a></li>
<li><a class="reference internal" href="#compilation-error-pointing-to-wooper-for-classes-hrl" id="id135">Compilation Error Pointing to <tt class="docutils literal">wooper_for_classes.hrl</tt></a></li>
<li><a class="reference internal" href="#general-case" id="id136">General Case</a><ul>
<li><a class="reference internal" href="#compilation-warnings" id="id137">Compilation Warnings</a></li>
<li><a class="reference internal" href="#runtime-errors" id="id138">Runtime Errors</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#current-stable-version-download" id="id139">Current Stable Version &amp; Download</a><ul>
<li><a class="reference internal" href="#prerequisites" id="id140">Prerequisites</a></li>
<li><a class="reference internal" href="#using-cutting-edge-git" id="id141">Using Cutting-Edge GIT</a></li>
<li><a class="reference internal" href="#using-otp-related-build-runtime-conventions" id="id142">Using OTP-Related Build/Runtime Conventions</a><ul>
<li><a class="reference internal" href="#using-rebar3" id="id143">Using Rebar3</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-hex" id="id144">Using Hex</a></li>
<li><a class="reference internal" href="#testing-wooper" id="id145">Testing WOOPER</a></li>
</ul>
</li>
<li><a class="reference internal" href="#version-history-changes" id="id146">Version History &amp; Changes</a><ul>
<li><a class="reference internal" href="#version-2-0-current-stable" id="id147">Version 2.0 [current stable]</a></li>
<li><a class="reference internal" href="#version-1-x" id="id148">Version 1.x</a></li>
<li><a class="reference internal" href="#version-1-0" id="id149">Version 1.0</a></li>
<li><a class="reference internal" href="#version-0-4" id="id150">Version 0.4</a></li>
<li><a class="reference internal" href="#version-0-3" id="id151">Version 0.3</a></li>
<li><a class="reference internal" href="#version-0-2" id="id152">Version 0.2</a></li>
<li><a class="reference internal" href="#version-0-1" id="id153">Version 0.1</a></li>
</ul>
</li>
<li><a class="reference internal" href="#wooper-inner-workings" id="id154">WOOPER Inner Workings</a><ul>
<li><a class="reference internal" href="#general-principles" id="id155">General Principles</a><ul>
<li><a class="reference internal" href="#understanding-compilation" id="id156">Understanding Compilation</a></li>
<li><a class="reference internal" href="#understanding-the-mode-of-operation-of-a-wooper-instance" id="id157">Understanding the Mode of Operation of a WOOPER Instance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#method-virtual-table" id="id158">Method Virtual Table</a><ul>
<li><a class="reference internal" href="#general-principle" id="id159">General Principle</a></li>
</ul>
</li>
<li><a class="reference internal" href="#attribute-table" id="id160">Attribute Table</a></li>
</ul>
</li>
<li><a class="reference internal" href="#issues-planned-enhancements" id="id161">Issues &amp; Planned Enhancements</a></li>
<li><a class="reference internal" href="#licence" id="id162">Licence</a></li>
<li><a class="reference internal" href="#sources-inspirations-alternate-solutions" id="id163">Sources, Inspirations &amp; Alternate Solutions</a></li>
<li><a class="reference internal" href="#support" id="id164">Support</a></li>
<li><a class="reference internal" href="#please-react" id="id165">Please React!</a></li>
<li><a class="reference internal" href="#ending-word" id="id166">Ending Word</a></li>
</ul>
</div>
<p></p>
<div class="section" id="overview">
<h1><a class="toc-backref" href="#id68">Overview</a></h1>
<p>WOOPER, which stands for <em>Wrapper for Object-Oriented Programming in Erlang</em>, is a <a class="reference internal" href="#free-software">free software</a> lightweight layer on top of the <a class="reference external" href="http://erlang.org">Erlang</a> language that provides constructs dedicated to <a class="reference external" href="http://en.wikipedia.org/wiki/Object-oriented_programming">Object-Oriented Programming</a> (OOP).</p>
<p>WOOPER is a rather autonomous part of the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan">Ceylan</a> project (yet it uses <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Myriad">Myriad</a> and is used by <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Traces">Traces</a>). WOOPER can be readily built and run on most Unices (including of course GNU/Linux) and on Windows.</p>
<p>The project repository is located <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER">here</a>.</p>
<p>At least a basic knowledge of Erlang is expected in order to use WOOPER.</p>
<p>Seasoned WOOPER users may directly bookmark this always useful <a class="reference internal" href="#cheat-sheet">cheat sheet</a>.</p>
</div>
<div class="section" id="understanding-wooper-in-two-steps">
<h1><a class="toc-backref" href="#id69">Understanding WOOPER in Two Steps</a></h1>
<p>Here is a <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/blob/master/priv/examples/class_Cat.erl">class definition</a>, and here is an example of <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/blob/master/priv/examples/class_Cat_test.erl">code using it</a>. That's it!</p>
<p>Now, let's discuss these subjects a bit more in-depth.</p>
<div class="section" id="motivations-purpose">
<h2><a class="toc-backref" href="#id70">Motivations &amp; Purpose</a></h2>
<p>Some problems may almost only be tackled efficiently thanks to an object-oriented modelling.</p>
<p>The set of code and conventions proposed here allows to benefit from all the main OOP features (including polymorphism, life cycle management, state management, passive or active instances, and multiple inheritance) directly from Erlang (which natively does not rely on the OOP paradigm), so that - in the cases where it makes sense - an object-oriented approach at the implementation level can be easily achieved.</p>
</div>
<div class="section" id="the-wooper-mode-of-operation-in-a-nutshell">
<h2><a class="toc-backref" href="#id71">The WOOPER Mode of Operation in a Nutshell</a></h2>
<p>The WOOPER OOP concepts translate into Erlang constructs according to the following mapping:</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">WOOPER base concept</th>
<th class="head">Corresponding mapping to Erlang</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>class definition</td>
<td>module (typically compiled in a <tt class="docutils literal">.beam</tt> file)</td>
</tr>
<tr><td>active instance</td>
<td>process</td>
</tr>
<tr><td>active instance reference</td>
<td>process identifier (PID)</td>
</tr>
<tr><td>passive instance</td>
<td>opaque term</td>
</tr>
<tr><td>new operators</td>
<td>WOOPER-provided functions, making use of user-defined <tt class="docutils literal">construct/N</tt> functions (a.k.a. the constructors)</td>
</tr>
<tr><td>delete operator</td>
<td>WOOPER-provided function, making use of any user-defined <tt class="docutils literal">destruct/1</tt> (a.k.a. the destructor)</td>
</tr>
<tr><td>member method definition</td>
<td>module function that respects some conventions (request/oneway/static method)</td>
</tr>
<tr><td>member method invocation</td>
<td>sending of an appropriate inter-process message</td>
</tr>
<tr><td>method look-up</td>
<td>class-specific virtual table taking into account inheritance transparently</td>
</tr>
<tr><td>instance state</td>
<td>instance-specific datastructure storing its attributes, and kept by the instance-specific WOOPER tail-recursive infinite loop</td>
</tr>
<tr><td>instance attributes</td>
<td>key/value pairs stored in the instance state</td>
</tr>
<tr><td>class (static) method</td>
<td>module function that respects some conventions</td>
</tr>
</tbody>
</table>
<p>In practice, developing a class with WOOPER mostly involves including the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/blob/master/include/wooper.hrl">wooper.hrl</a> header file and respecting the WOOPER conventions detailed below.</p>
</div>
<div class="section" id="id2">
<span id="example"></span><h2><a class="toc-backref" href="#id72">Example</a></h2>
<p>Here is a simple example of how a WOOPER class can be defined and used.</p>
<p>It shows <tt class="docutils literal">new/delete</tt> operators, method calling (both request and oneway), and inheritance.</p>
<p>A cat is here a viviparous mammal, as defined below (this is a variation of our more complete <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/blob/master/priv/examples/class_Cat.erl">class_Cat.erl</a> example):</p>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">class_Cat</span><span class="p">).</span>

<span class="c">% Optional:
</span><span class="p">-</span><span class="ni">define</span><span class="p">(</span><span class="no">class_description</span><span class="p">,</span><span class="s">&quot;Models a domestic cat&quot;</span><span class="p">).</span>

<span class="c">% Determines what are the direct mother classes of this class (if any):
</span><span class="p">-</span><span class="ni">define</span><span class="p">(</span><span class="no">superclasses</span><span class="p">,[</span><span class="n">class_Mammal</span><span class="p">,</span><span class="n">class_ViviparousBeing</span><span class="p">]).</span>

<span class="c">% Declaration of class-specific attributes:
% (optional, yet recommended for clarity)
</span><span class="p">-</span><span class="ni">define</span><span class="p">(</span><span class="no">class_attributes</span><span class="p">,[</span>
          <span class="p">{</span><span class="n">meow_style</span><span class="p">,</span><span class="n">style</span><span class="p">(),</span><span class="n">const</span><span class="p">,</span><span class="s">&quot;the kind of meow to expect&quot;</span><span class="p">},</span>
          <span class="p">{</span><span class="n">whisker_color</span><span class="p">,</span><span class="s">&quot;the color of this cat's whiskers&quot;</span><span class="p">}]).</span>

<span class="c">% Allows to define WOOPER base variables and methods for that class:
</span><span class="p">-</span><span class="ni">include</span><span class="p">(</span><span class="s">&quot;wooper.hrl&quot;</span><span class="p">).</span>

<span class="c">% No need to export constructors, destructor or methods.
% Type specifications remain optional (yet are recommended).
</span>
<span class="c">% Constructs a new Cat.
</span><span class="nf">construct</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">Age</span><span class="p">,</span><span class="nv">Gender</span><span class="p">,</span><span class="nv">FurColor</span><span class="p">,</span><span class="nv">WhiskerColor</span><span class="p">)</span> <span class="o">-&gt;</span>
   <span class="c">% First the direct mother classes:
</span>   <span class="nv">MammalState</span> <span class="o">=</span> <span class="nn">class_Mammal</span><span class="p">:</span><span class="nf">construct</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">Age</span><span class="p">,</span><span class="nv">Gender</span><span class="p">,</span><span class="nv">FurColor</span><span class="p">),</span>
   <span class="nv">ViviparousMammalState</span> <span class="o">=</span> <span class="nn">class_ViviparousBeing</span><span class="p">:</span><span class="nf">construct</span><span class="p">(</span><span class="nv">MammalState</span><span class="p">),</span>
   <span class="c">% Then the class-specific attributes; returns an updated state:
</span>   <span class="n">setAttribute</span><span class="p">(</span><span class="nv">ViviparousMammalState</span><span class="p">,</span><span class="n">whisker_color</span><span class="p">,</span><span class="nv">WhiskerColor</span><span class="p">).</span>

<span class="nf">destruct</span><span class="p">(</span><span class="nv">State</span><span class="p">)</span> <span class="o">-&gt;</span>
   <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span> <span class="s">&quot;Deleting cat </span><span class="si">~w</span><span class="s">! (overridden destructor)</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">self</span><span class="p">()]</span> <span class="p">),</span>
   <span class="nv">State</span><span class="p">.</span>

<span class="c">% Member methods.
</span>
<span class="c">% A cat-specific request, supposing the developer missed the fact
% that it is a const one (no problem):
</span><span class="nf">getWhiskerColor</span><span class="p">(</span><span class="nv">State</span><span class="p">)</span><span class="o">-&gt;</span>
   <span class="nn">wooper</span><span class="p">:</span><span class="nf">return_state_result</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="o">?</span><span class="n">getAttr</span><span class="p">(</span><span class="n">whisker_color</span><span class="p">)).</span>

<span class="c">% A (non-const) oneway, with a spec:
</span><span class="p">-</span><span class="ni">spec</span> <span class="n">setWhiskerColor</span><span class="p">(</span><span class="nn">wooper</span><span class="p">:</span><span class="nf">state</span><span class="p">(),</span><span class="nn">foo</span><span class="p">:</span><span class="nf">color</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="n">oneway_return</span><span class="p">().</span>
<span class="nf">setWhiskerColor</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">NewColor</span><span class="p">)</span><span class="o">-&gt;</span>
   <span class="nv">NewState</span> <span class="o">=</span> <span class="n">setAttribute</span><span class="p">(</span> <span class="nv">State</span><span class="p">,</span> <span class="n">whisker_color</span><span class="p">,</span> <span class="nv">NewColor</span> <span class="p">),</span>
   <span class="nn">wooper</span><span class="p">:</span><span class="nf">return_state</span><span class="p">(</span><span class="nv">NewState</span><span class="p">).</span>

<span class="c">% Overrides any request method defined in the Mammal class:
% (const request)
</span><span class="nf">canEat</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="n">soup</span><span class="p">)</span> <span class="o">-&gt;</span>
   <span class="nn">wooper</span><span class="p">:</span><span class="nf">const_return_result</span><span class="p">(</span><span class="n">true</span><span class="p">);</span>

<span class="nf">canEat</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="n">croquette</span><span class="p">)</span> <span class="o">-&gt;</span>
   <span class="nn">wooper</span><span class="p">:</span><span class="nf">const_return_result</span><span class="p">(</span><span class="n">true</span><span class="p">);</span>

<span class="nf">canEat</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="n">meat</span><span class="p">)</span> <span class="o">-&gt;</span>
   <span class="nn">wooper</span><span class="p">:</span><span class="nf">const_return_result</span><span class="p">(</span><span class="n">true</span><span class="p">);</span>

<span class="nf">canEat</span><span class="p">(</span><span class="nv">State</span><span class="p">,_</span><span class="nv">OtherFood</span><span class="p">)</span> <span class="o">-&gt;</span>
   <span class="nn">wooper</span><span class="p">:</span><span class="nf">const_return_result</span><span class="p">(</span><span class="n">false</span><span class="p">).</span>

<span class="c">% Static method:
</span><span class="nf">get_default_whisker_color</span><span class="p">()</span> <span class="o">-&gt;</span>
   <span class="nn">wooper</span><span class="p">:</span><span class="nf">return_static</span><span class="p">(</span><span class="n">white</span><span class="p">).</span>
</pre>
<p>Straightforward, isn't it? We will discuss it in-depth, though.</p>
<p>To test this class (provided that <tt class="docutils literal">GNU make</tt> and the latest stable version of <tt class="docutils literal">Erlang</tt> are available in one's environment, see <a class="reference internal" href="#prerequisites">Prerequisites</a> for more information), one can easily install <tt class="docutils literal"><span class="pre">Ceylan-WOOPER</span></tt>, which depends on <a class="reference external" href="http://myriad.esperide.org">Ceylan-Myriad</a>, hence is to be installed first:</p>
<pre class="code bash literal-block">
$ git clone https://github.com/Olivier-Boudeville/Ceylan-Myriad.git myriad
$ <span class="nb">cd</span> myriad <span class="o">&amp;&amp;</span> make all <span class="o">&amp;&amp;</span> <span class="nb">cd</span> ..
</pre>
<pre class="code bash literal-block">
$ git clone https://github.com/Olivier-Boudeville/Ceylan-WOOPER.git wooper
$ <span class="nb">cd</span> wooper <span class="o">&amp;&amp;</span> make all
</pre>
<p>(for OTP compliance, using short names, such as <tt class="docutils literal">myriad</tt> or <tt class="docutils literal">wooper</tt>, for clones rather than long ones, such as <tt class="docutils literal"><span class="pre">Ceylan-Myriad</span></tt> or <tt class="docutils literal"><span class="pre">Ceylan-WOOPER</span></tt>, is recommended)</p>
<p>Running the cat-related example just then boils down to:</p>
<pre class="code bash literal-block">
$ <span class="nb">cd</span> examples <span class="o">&amp;&amp;</span> make class_Cat_run
</pre>
<p>In the <tt class="docutils literal">examples</tt> directory, the test defined in <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/blob/master/priv/examples/class_Cat_test.erl">class_Cat_test.erl</a> should run against the class defined in <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/blob/master/priv/examples/class_Cat.erl">class_Cat.erl</a>, and no error should be detected:</p>
<pre class="code bash literal-block">
Running unitary <span class="nb">test</span> class_Cat_run <span class="o">(</span>second form<span class="o">)</span>

--&gt; Testing module class_Cat_test.
<span class="o">[</span>..<span class="o">]</span>
Deleting cat &lt;<span class="m">0</span>.80.0&gt;! <span class="o">(</span>overridden destructor<span class="o">)</span>
Deleting mammal &lt;<span class="m">0</span>.80.0&gt;! <span class="o">(</span>overridden destructor<span class="o">)</span>
Actual class from destructor: class_Cat.
Deleting mammal &lt;<span class="m">0</span>.82.0&gt;! <span class="o">(</span>overridden destructor<span class="o">)</span>
This cat could be created and be synchronously deleted, as expected.
--&gt; Successful end of test.
<span class="o">(</span><span class="nb">test</span> finished, interpreter halted<span class="o">)</span>
</pre>
<p>That's it!</p>
<p>Now, more in-depth explanations.</p>
<p></p>
</div>
</div>
<div class="section" id="why-adding-object-oriented-capabilities-to-erlang">
<h1><a class="toc-backref" href="#id73">Why Adding Object-Oriented Capabilities To Erlang?</a></h1>
<p>Although applying blindly an OOP approach while using languages based on other paradigms (Erlang ones are functional and concurrent; the language is not specifically targeting OOP) is a common mistake, there are some problems that may be deemed inherently &quot;object-oriented&quot;, i.e. that cannot be effectively modelled without encapsulated abstractions sharing behaviours.</p>
<p>Examples of this kind of systems are multi-agent simulations. If they often need massive concurrency, robustness, distribution, etc. (Erlang is particularly suitable for that), the various types of agents have also often to rely on similar kinds of states and behaviours, while still being able to be further specialised on a per-type basis.</p>
<p>The <a class="reference internal" href="#example">example</a> mentioned through the current guide is an illustration <a class="footnote-reference" href="#id4" id="id3">[1]</a> of the interacting lives of numerous animals of various species. Obviously, they have to share behaviours (ex: all ovoviviparous beings may lay eggs, all creatures can live and die, all have an age, etc.), which cannot be mapped easily (read: automatically) to Erlang concepts without adding some generic constructs.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>This example is not a <em>simulation</em>, it is just a multi-agent system. For real, massive, discrete-time simulations of complex systems in Erlang (using WOOPER), one may refer to <a class="reference external" href="https://github.com/Olivier-Boudeville-EDF/Sim-Diasca">Sim-Diasca</a> instead (a free software discrete-time simulation engine).</td></tr>
</tbody>
</table>
<p>WOOPER, which stands for <em>Wrapper for OOP in Erlang</em>, is a lightweight yet effective (performance-wise, but also regarding the user-side  developing efforts) means of making these constructs available, notably in terms of state management and multiple inheritance.</p>
<p>The same programs could certainly be implemented <em>without</em> such OOP constructs, but at the expense of way too much manually-crafted, specific (per-class) code. This process would be tedious, error-prone, and most often the result could hardly be maintained.</p>
<p></p>
</div>
<div class="section" id="how-to-use-wooper-detailed-description-concept-mappings">
<h1><a class="toc-backref" href="#id74">How to Use WOOPER: Detailed Description &amp; Concept Mappings</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#classes" id="id167">Classes</a><ul>
<li><a class="reference internal" href="#classes-names" id="id168">Classes &amp; Names</a></li>
<li><a class="reference internal" href="#class-description" id="id169">Class Description</a></li>
<li><a class="reference internal" href="#inheritance-superclasses" id="id170">Inheritance &amp; Superclasses</a></li>
</ul>
</li>
<li><a class="reference internal" href="#instances" id="id171">Instances</a><ul>
<li><a class="reference internal" href="#instance-mapping" id="id172">Instance Mapping</a></li>
<li><a class="reference internal" href="#instance-state" id="id173">Instance State</a></li>
</ul>
</li>
<li><a class="reference internal" href="#methods" id="id174">Methods</a><ul>
<li><a class="reference internal" href="#method-declaration" id="id175">Method Declaration</a></li>
<li><a class="reference internal" href="#method-invocation" id="id176">Method Invocation</a></li>
<li><a class="reference internal" href="#method-name" id="id177">Method Name</a></li>
<li><a class="reference internal" href="#method-parameters" id="id178">Method Parameters</a></li>
<li><a class="reference internal" href="#two-kinds-of-member-methods" id="id179">Two Kinds of Member Methods</a></li>
<li><a class="reference internal" href="#method-results" id="id180">Method Results</a></li>
<li><a class="reference internal" href="#method-definition" id="id181">Method Definition</a></li>
<li><a class="reference internal" href="#for-requests" id="id182">For Requests</a></li>
<li><a class="reference internal" href="#for-oneways" id="id183">For Oneways</a></li>
<li><a class="reference internal" href="#usefulness-of-the-method-terminators" id="id184">Usefulness Of the Method Terminators</a></li>
<li><a class="reference internal" href="#self-invocation-calling-a-method-from-the-instance-itself" id="id185">Self-Invocation: Calling a Method From the Instance Itself</a></li>
<li><a class="reference internal" href="#static-methods" id="id186">Static Methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id25" id="id187">State Management</a><ul>
<li><a class="reference internal" href="#principles" id="id188">Principles</a></li>
<li><a class="reference internal" href="#state-implementation-details" id="id189">State Implementation Details</a></li>
<li><a class="reference internal" href="#managing-the-state-of-an-instance" id="id190">Managing the State of an Instance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#multiple-inheritance-polymorphism" id="id191">Multiple Inheritance &amp; Polymorphism</a><ul>
<li><a class="reference internal" href="#the-general-case" id="id192">The General Case</a></li>
<li><a class="reference internal" href="#the-special-case-of-diamond-shaped-inheritance" id="id193">The Special Case of Diamond-Shaped Inheritance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#life-cycle" id="id194">Life-Cycle</a><ul>
<li><a class="reference internal" href="#instance-creation-new-new-link-and-construct" id="id195">Instance Creation: <tt class="docutils literal">new</tt>/<tt class="docutils literal">new_link</tt> and <tt class="docutils literal">construct</tt></a></li>
<li><a class="reference internal" href="#instance-deletion" id="id196">Instance Deletion</a></li>
</ul>
</li>
<li><a class="reference internal" href="#passive-instances" id="id197">Passive Instances</a></li>
</ul>
</div>
<div class="section" id="classes">
<h2><a class="toc-backref" href="#id167">Classes</a></h2>
<div class="section" id="classes-names">
<h3><a class="toc-backref" href="#id168">Classes &amp; Names</a></h3>
<p>A class is a blueprint to create objects, a common scheme describing the state and behaviour of its instances, i.e. the attributes and methods that all objects created from that class shall support.</p>
<p>With WOOPER, each class has a unique name, such as <tt class="docutils literal">class_Cat</tt>.</p>
<p>To allow for <strong>encapsulation</strong>, a WOOPER class is mapped to an Erlang module, whose name is by convention made from the <tt class="docutils literal">class_</tt> prefix followed by the class name, in the so-called <a class="reference external" href="http://en.wikipedia.org/wiki/CamelCase">CamelCase</a>: all words are spelled in lower-case except their first letter, and there are no separators between words, like in: <tt class="docutils literal">ThisIsAnExample</tt>.</p>
<p>So a class modeling, for example, a cat should translate into an Erlang module named <tt class="docutils literal">class_Cat</tt>, thus in a file named <tt class="docutils literal">class_Cat.erl</tt>. At the top of this file, the corresponding module would be therefore declared with: <tt class="docutils literal"><span class="pre">-module(class_Cat).</span></tt>.</p>
<p>Similarly, a pink flamingo class could be declared as <tt class="docutils literal">class_PinkFlamingo</tt>, in <tt class="docutils literal">class_PinkFlamingo.erl</tt>, which would include a <tt class="docutils literal"><span class="pre">-module(class_PinkFlamingo).</span></tt> declaration.</p>
<p>Note that, unless specifically ambiguous, for the sake of brevity classes are often referred to by their name without their <tt class="docutils literal">class_</tt> prefix.</p>
<p>For example <tt class="docutils literal">PinkFlamingo</tt> can be understood as a shorthand for the actual classname, <tt class="docutils literal">class_PinkFlamingo</tt>.</p>
</div>
<div class="section" id="class-description">
<h3><a class="toc-backref" href="#id169">Class Description</a></h3>
<p>A class should not be implemented without adding at least a short description of it. Rather than describing it through a mere in-code comment (hence only addressed to the class maintainer), a better approach is to used the <tt class="docutils literal">class_description</tt> define, like in:</p>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">define</span><span class="p">(</span><span class="no">class_description</span><span class="p">,</span><span class="s">&quot;Class in charge of implementing the &quot;</span>
                            <span class="s">&quot;Foobar service.&quot;</span><span class="p">).</span>
</pre>
<p>Doing so allows that information to be available to humans and tools alike <a class="footnote-reference" href="#id6" id="id5">[2]</a>.</p>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[2]</a></td><td>More generally, over time we tend to see any remaining comment as a potential candidate to &quot;metadata promotion&quot;. This way, the corresponding information can be used in multiple contexts (ex: when generating documentation from code).</td></tr>
</tbody>
</table>
</div>
<div class="section" id="inheritance-superclasses">
<h3><a class="toc-backref" href="#id170">Inheritance &amp; Superclasses</a></h3>
<p>A WOOPER class can inherit from other classes, in which case the state and behaviour defined in the mother classes will be readily available to this child class.</p>
<p>Being in a <strong>multiple inheritance</strong> context, a given class can have any number (<tt class="docutils literal"><span class="pre">[0..n]</span></tt>) of direct mother classes, which themselves may have their mother classes, and so on. This is to lead to a class hierarchy that forms a direct, acyclic graph.</p>
<p>The direct mother classes (and only them) are to be declared in WOOPER thanks to the <tt class="docutils literal">superclasses</tt> define. For example, a class with no mother class should specify, once having declared its module:</p>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">define</span><span class="p">(</span><span class="no">superclasses</span><span class="p">,[]).</span>
</pre>
<p>In this particular case, with no mother class to be declared, this <tt class="docutils literal">superclasses</tt> define could be omitted as a whole (yet this would be probably less obvious to the reader).</p>
<p>As for our cat, this superb animal could be modelled both as a mammal (itself a specialised creature) and a viviparous being <a class="footnote-reference" href="#id8" id="id7">[3]</a>. Hence its direct inheritance could be defined as:</p>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">define</span><span class="p">(</span><span class="no">superclasses</span><span class="p">,[</span><span class="n">class_Mammal</span><span class="p">,</span><span class="n">class_ViviparousBeing</span><span class="p">]).</span>
</pre>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[3]</a></td><td>Neither of them is a subset of the other, these are mostly unrelated concepts, at least in the context of that example! (ex: a platypus is a mammal, but not a viviparous being, right?).</td></tr>
</tbody>
</table>
<p>The superclasses (direct mother classes) of a given class can be known thanks to its <tt class="docutils literal">get_superclasses/0</tt> static method <a class="footnote-reference" href="#id10" id="id9">[4]</a> (automatically defined by WOOPER):</p>
<pre class="code erlang literal-block">
<span class="o">&gt;</span> <span class="nn">class_Cat</span><span class="p">:</span><span class="nf">get_superclasses</span><span class="p">().</span>
<span class="p">[</span><span class="n">class_Mammal</span><span class="p">,</span><span class="n">class_ViviparousBeing</span><span class="p">]</span>
</pre>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[4]</a></td><td>Note that, to anticipate a bit, a static method (i.e. a class method that does not apply to any specific instance of it) of a class <tt class="docutils literal">X</tt> is nothing more than an Erlang function, exported by WOOPER from the corresponding <tt class="docutils literal">class_X</tt> module and which would return its result <tt class="docutils literal">R</tt> as: <tt class="docutils literal">wooper:return_static(R)</tt>. So the corresponding type specification would be <tt class="docutils literal"><span class="pre">-spec</span> get_superclasses() <span class="pre">-&gt;</span> <span class="pre">static_return([wooper:classname()]).</span></tt> here.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="instances">
<h2><a class="toc-backref" href="#id171">Instances</a></h2>
<div class="section" id="instance-mapping">
<h3><a class="toc-backref" href="#id172">Instance Mapping</a></h3>
<p>With WOOPER, which focuses on multi-agent systems, all <strong>active instances</strong> of a class are mapped to Erlang processes (one WOOPER instance is exactly one Erlang process).</p>
<p>They are therefore, in UML parlance, <em>active objects</em> (each has its own thread of execution, they may apparently &quot;live&quot; simultaneously <a class="footnote-reference" href="#id12" id="id11">[5]</a>).</p>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[5]</a></td><td><p class="first">For some uses, such a concurrent feature (with <em>active</em> instances) may not be needed, in which case one may prefer dealing with purely <em>passive</em> instances (implemented as mere Erlang <em>terms</em> instead of Erlang <em>processes</em>).</p>
<p class="last">To anticipate a bit, instead of using <tt class="docutils literal">new/N</tt> (returning the PID of a new process instance looping over its state), one may rely on <tt class="docutils literal">new_passive/N</tt>, returning to the caller process an opaque term corresponding to the initial state of a new passive instance, a term that can be then stored and interacted upon at will. See the <a class="reference internal" href="#passive-instance">passive instance</a> section for more details. Most of this document concentrates on active instances, so, unless specified otherwise, just mentioning <em>instance</em> by itself refers to an active one.</p>
</td></tr>
</tbody>
</table>
<p>Such an instance process simply loops over its state forever, waiting for incoming method calls and processing them one after the other.</p>
</div>
<div class="section" id="instance-state">
<h3><a class="toc-backref" href="#id173">Instance State</a></h3>
<p>Another common OOP need is to rely on <strong>state management</strong> and <strong>encapsulation</strong>: each instance should be stateful, have its state fully private, and be able to inherit automatically the data members defined by its mother classes.</p>
<p>In WOOPER, this is obtained thanks to a per-instance associative table, whose keys are the names of attributes and whose values are the attribute values. This will be detailed in the <a class="reference internal" href="#state-management">state management</a> section.</p>
<p></p>
</div>
</div>
<div class="section" id="methods">
<h2><a class="toc-backref" href="#id174">Methods</a></h2>
<p>They can be either:</p>
<ul class="simple">
<li><strong>member methods</strong>: they applies to a specific <em>instance</em> (of a given class), like in: <tt class="docutils literal">MyCatPid ! declareBirthday</tt></li>
<li>or <strong>static methods</strong>: they are general to a <em>class</em>, not targeting specifically an instance of it, like in: <tt class="docutils literal">class_Cat:get_default_mew_duration()</tt></li>
</ul>
<p>Unless specified otherwise, just mentioning <em>method</em> by itself refers to a <em>member method</em>. Static methods are discussed in their specific subsection (see <a class="reference internal" href="#static-methods">Static Methods</a>).</p>
<p><strong>Member methods</strong> can be publicly called by any process (be it WOOPER-based or not) - provided of course it knows the PID of that instance - whether locally or remotely (i.e. on other networked computers, like with RMI or with CORBA, or directly from the same Erlang node), distribution (and parallelism) being seamlessly managed thanks to Erlang.</p>
<p>Member methods (either inherited or defined directly in the class) are mapped to specific Erlang functions that are triggered by Erlang messages.</p>
<p>For example, our cat class may define, among others, following member methods (actual arities to be discussed later):</p>
<ul class="simple">
<li><tt class="docutils literal">canEat</tt>, taking one parameter specifying the type of food, and returning whether the corresponding cat can eat that kind of food; here the implementation should be cat-specific (i.e. specific to cats and also, possibly, specific to this very single cat), whereas the method signature shall be shared by all beings</li>
<li><tt class="docutils literal">getWhiskersColor</tt>, taking no parameter, returning the color of its whiskers; this is indeed a purely cat-specific method, and different cats may have different whisker colors; as this method, like the previous one, returns a result to the caller, it is a <em>request</em> method</li>
<li><tt class="docutils literal">declareBirthday</tt>, incrementing the age of our cat, not taking any parameter nor returning anything; it will be therefore be implemented as a <em>oneway</em> method (i.e. not returning any result to the caller, hence not even needing to know it), whose call is only interesting for its effect on the state of this cat: here, making it one year older</li>
<li><tt class="docutils literal">setWhiskerColor</tt>, assigning the specified color to the whiskers of that cat instance, not returning anything (another oneway method, then)</li>
</ul>
<p>Declaring a birthday is not cat-specific, nor mammal-specific: we can consider it being creature-specific. Cat instances should then inherit this method, preferably indirectly from the <tt class="docutils literal">class_Creature</tt> class, in all cases without having to specify anything, since the <tt class="docutils literal">superclasses</tt> define already implies it (implying one time for all that cats <em>are</em> creatures and thus, unless specified otherwise, are and behave as such). Of course this inherited method may be overridden at will anywhere in the class hierarchy.</p>
<p>We will discuss the <em>definition</em> of these methods later, but for the moment let's determine their signatures and declarations, and how we are expected to <em>call</em> them.</p>
<div class="section" id="method-declaration">
<h3><a class="toc-backref" href="#id175">Method Declaration</a></h3>
<p>All cat-specific methods (member or static ones) are to be defined in the context of <tt class="docutils literal">class_Cat</tt> (defined, as mentioned, in <tt class="docutils literal">class_Cat.erl</tt>). Defining a method automatically declares it, so no method should be explicitly exported (knowing WOOPER is to take care of it).</p>
<p>The arity of member methods should be equal to the number of parameters they should be called with, plus one that is automatically managed by WOOPER and that corresponds to the (strictly private, never exported or sent to anyone) state of that instance.</p>
<p>This <tt class="docutils literal">State</tt> variable defined by WOOPER can be somehow compared to the <tt class="docutils literal">self</tt> parameter of Python, or to the <tt class="docutils literal">this</tt> hidden pointer of C++. That state is automatically kept by WOOPER instances in their main loop, and automatically prepended, as first element, to the parameters of incoming method calls.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">To respect the principle of least astonishment, WOOPER demands that this first parameter is named exactly <tt class="docutils literal">State</tt> (doing otherwise will result in a compile-time WOOPER error being issued).</p>
</div>
</div>
<div class="section" id="method-invocation">
<h3><a class="toc-backref" href="#id176">Method Invocation</a></h3>
<p>Let's suppose that the <tt class="docutils literal">MyCat</tt> variable designates an (active) instance of <tt class="docutils literal">class_Cat</tt>. Then this <tt class="docutils literal">MyCat</tt> reference is actually just the PID of the Erlang process hosting this instance; so it may be named <tt class="docutils literal">MyCatPid</tt> instead for additional clarity.</p>
<p>All member methods (regardless of whether they are defined directly by the actual class or inherited) are to be called from outside this class thanks to a properly formatted Erlang message, sent to the targeted instance via its PID.</p>
<p>When the method is expected to return a result (i.e. when it is a request), the caller must specify in the corresponding message its own PID, so that the instance knows to whom the result should be sent.</p>
<p>Oneways, as for them, are to be triggered with no caller information <a class="footnote-reference" href="#id14" id="id13">[6]</a>, since no answer is to be sent back.</p>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[6]</a></td><td>Should the caller PID be nevertheless of use for a given oneway (this may happen), this information shall be listed among its expected parameters.</td></tr>
</tbody>
</table>
<p>Therefore the <tt class="docutils literal">self()</tt> parameter in the call tuples for requests below corresponds to the PID <em>of the caller</em>, while <tt class="docutils literal">MyCat</tt> is bound to the PID <em>of the target instance</em>.</p>
<p>The three methods previously discussed would indeed be called that way:</p>
<pre class="code erlang literal-block">
<span class="c">% Calling the canEat request of our cat instance:
</span><span class="nv">MyCat</span> <span class="o">!</span> <span class="p">{</span><span class="n">canEat</span><span class="p">,</span><span class="n">soup</span><span class="p">,</span><span class="n">self</span><span class="p">()},</span>
<span class="k">receive</span>
    <span class="p">{</span><span class="n">wooper_result</span><span class="p">,</span><span class="n">true</span><span class="p">}</span> <span class="o">-&gt;</span>
      <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;This cat likes soup!!!&quot;</span><span class="p">);</span>

    <span class="p">{</span><span class="n">wooper_result</span><span class="p">,</span><span class="n">false</span><span class="p">}</span> <span class="o">-&gt;</span>
      <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;This cat does not seem omnivorous.&quot;</span><span class="p">)</span>
<span class="k">end</span><span class="p">,</span>

<span class="c">% A parameter-less request:
</span><span class="nv">MyCat</span> <span class="o">!</span> <span class="p">{</span><span class="n">getWhiskersColor</span><span class="p">,[],</span><span class="n">self</span><span class="p">()},</span>
<span class="k">receive</span>
    <span class="p">{</span><span class="n">wooper_result</span><span class="p">,</span><span class="n">white</span><span class="p">}</span> <span class="o">-&gt;</span>
      <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;This cat has normal whiskers.&quot;</span><span class="p">);</span>

    <span class="p">{</span><span class="n">wooper_result</span><span class="p">,</span><span class="n">blue</span><span class="p">}</span> <span class="o">-&gt;</span>
      <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;What a weird cat...&quot;</span><span class="p">)</span>
<span class="k">end</span><span class="p">,</span>

<span class="c">% A parameter-less oneway:
</span><span class="nv">MyCat</span> <span class="o">!</span> <span class="n">declareBirthday</span><span class="p">.</span>
</pre>
</div>
<div class="section" id="method-name">
<h3><a class="toc-backref" href="#id177">Method Name</a></h3>
<p>Methods are designated by their name (as an atom), i.e. the one specified when defining them (ex: <tt class="docutils literal">canEat</tt>).</p>
<p>We recommend that their name is spelled in CamelCase and remains short and descriptive, and start with a verb, like in: <tt class="docutils literal">getColor</tt>, <tt class="docutils literal">computeSum</tt>, <tt class="docutils literal">registerDefaultSettings</tt>, etc.</p>
<p>Some method names are reserved for WOOPER; notably no user-defined method should have its name prefixed with <tt class="docutils literal">wooper</tt> or with <tt class="docutils literal">onWOOPER</tt>.</p>
<p>The list of the other reserved names (that shall thus not be defined by a class developer) includes:</p>
<ul class="simple">
<li><tt class="docutils literal">get_classname</tt> and <tt class="docutils literal">get_superclasses</tt></li>
<li><tt class="docutils literal">executeRequest</tt> and <tt class="docutils literal">executeRequestAs</tt>, <tt class="docutils literal">executeConstRequest</tt> and <tt class="docutils literal">executeConstRequestAs</tt></li>
<li><tt class="docutils literal">executeOneway</tt> and <tt class="docutils literal">executeOnewayAs</tt>, <tt class="docutils literal">executeConstOneway</tt> and <tt class="docutils literal">executeConstOnewayAs</tt></li>
<li><tt class="docutils literal">new</tt> and other related construction operators (<tt class="docutils literal">new_link</tt>, <tt class="docutils literal">synchronous_new</tt>, etc.; see below)</li>
<li><tt class="docutils literal">delete_any_instance_referenced_in</tt>, <tt class="docutils literal">delete_synchronously_any_instance_referenced_in</tt>, <tt class="docutils literal">delete_synchronously_instances</tt></li>
</ul>
<p>They are reserved for all arities.</p>
<p>The method name is always the first information given when calling it (typically in the method call tuple).</p>
</div>
<div class="section" id="method-parameters">
<h3><a class="toc-backref" href="#id178">Method Parameters</a></h3>
<p>All methods are free to change the state of their instance and possibly to trigger any side-effect (ex: sending a message, writing a file, kidnapping Santa Claus, etc.).</p>
<p>As detailed below, there are two kinds of member methods:</p>
<ul class="simple">
<li><em>requests</em> methods: they shall return a result to the caller (obviously they need to know it, i.e. the caller has to specify its PID)</li>
<li><em>oneway</em> methods: no specific result are expected from them (hence no caller PID is to be specified)</li>
</ul>
<p>Both can take any number of parameters, including none. As always, the <strong>marshalling</strong> of these parameters and, if relevant, of any returned value is performed automatically by Erlang.</p>
<p>Parameters are to be specified in a (possibly empty) list, as second element of the call tuple, like in: <tt class="docutils literal"><span class="pre">{getWhiskersColor,[],self()}</span></tt>.</p>
<p>If only a single, non-list, parameter is needed, the list can be omitted, and the parameter can be directly specified. So <tt class="docutils literal">Alfred ! {setAge,31}.</tt> works just as well as <tt class="docutils literal">Alfred ! <span class="pre">{setAge,[31]}.</span></tt>.</p>
<div class="admonition note" id="single-method-parameter-is-a-list">
<p class="first admonition-title">Note</p>
<p>This cannot apply if the unique parameter is a list, as this would be ambiguous.</p>
<p>For example: <tt class="docutils literal"><span class="pre">Foods=[meat,soup,croquette],</span> MyCat ! {setFavoriteFoods,Foods}</tt> would result in a call to <tt class="docutils literal">setFavoriteFoods/4</tt>, i.e. a call to <tt class="docutils literal">setFavoriteFoods(State,meat,soup,croquette)</tt>, whereas the intent of the programmer is probably to call a <tt class="docutils literal">setFavoriteFoods/2</tt> method like <tt class="docutils literal">setFavoriteFoods(State,Foods) when is_list(Foods) <span class="pre">-&gt;</span> <span class="pre">[..]</span></tt> instead.</p>
<p>The proper call would then be <tt class="docutils literal">MyCat ! <span class="pre">{setFavoriteFoods,[Foods]}</span></tt>, i.e. the parameter list should be used, and it would then contain only one element, the food list, whose content would therefore be doubly enclosed.</p>
<p class="last">Note also that, of course, strings <em>are</em> lists. So <tt class="docutils literal">Joe ! <span class="pre">{setName,&quot;Armstrong&quot;}.</span></tt> is likely not the call you are looking for. Most probably you should prefer: <tt class="docutils literal">Joe ! <span class="pre">{setName,[&quot;Armstrong&quot;]}.</span></tt>.</p>
</div>
</div>
<div class="section" id="two-kinds-of-member-methods">
<h3><a class="toc-backref" href="#id179">Two Kinds of Member Methods</a></h3>
<div class="section" id="request-methods">
<h4>Request Methods</h4>
<p>A <strong>request</strong> is a member method that returns a result to the caller.</p>
<p>For an instance to be able to send an answer to a request triggered by a caller, of course that instance needs to know the caller PID.</p>
<p>Therefore requests have to specify, as the third element of the call tuple, an additional information: the PID to which the answer should be sent, which is almost always the caller (hence the <tt class="docutils literal">self()</tt> in the actual calls).</p>
<p>So these three potential information (request name, parameters, reference of the sender - i.e. an atom, usually a list, and a PID) are gathered in a triplet (a 3-tuple) sent as a message: <tt class="docutils literal">{request_name, <span class="pre">[Arg1,Arg2,..],</span> <span class="pre">self()}</span></tt>.</p>
<p>If only one parameter is to be sent, and if that parameter is not a list, then this can become <tt class="docutils literal">{request_name, Arg, <span class="pre">self()}</span></tt>.</p>
<p>For example:</p>
<pre class="code erlang literal-block">
<span class="nv">MyCat</span> <span class="o">!</span> <span class="p">{</span><span class="n">getAge</span><span class="p">,[],</span><span class="n">self</span><span class="p">()}.</span>
</pre>
<p>or:</p>
<pre class="code erlang literal-block">
<span class="nv">Douglas</span> <span class="o">!</span> <span class="p">{</span><span class="n">askQuestionWithHint</span><span class="p">,</span> <span class="p">[{</span><span class="n">meaning_of</span><span class="p">,</span><span class="s">&quot;Life&quot;</span><span class="p">},{</span><span class="n">maybe</span><span class="p">,</span><span class="mi">42</span><span class="p">}],</span> <span class="n">self</span><span class="p">()}.</span>
</pre>
<p>or:</p>
<pre class="code erlang literal-block">
<span class="nv">MyCalculator</span> <span class="o">!</span> <span class="p">{</span><span class="n">sum</span><span class="p">,[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]],</span><span class="n">self</span><span class="p">()}.</span>
</pre>
<p>The actual result <tt class="docutils literal">R</tt>, as determined by the method, is sent back as an Erlang message, which is a <tt class="docutils literal">{wooper_result,R}</tt> pair, to help the caller pattern-matching the WOOPER messages in its mailbox.</p>
<p><tt class="docutils literal">receive</tt> should then be used by the caller to retrieve the request result, like in the case of this example of a 2D point instance:</p>
<pre class="code erlang literal-block">
<span class="nv">MyPoint</span> <span class="o">!</span> <span class="p">{</span><span class="n">getCoordinates</span><span class="p">,[],</span><span class="n">self</span><span class="p">()},</span>
<span class="k">receive</span>
   <span class="p">{</span><span class="n">wooper_result</span><span class="p">,[</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">]}</span> <span class="o">-&gt;</span>
       <span class="p">[..]</span>
<span class="k">end</span><span class="p">,</span>
<span class="p">[..]</span>
</pre>
</div>
<div class="section" id="oneway-methods">
<h4>Oneway Methods</h4>
<p>A <strong>oneway</strong> is a member method that does not return a result to the caller.</p>
<p>When calling oneway methods, the caller does not have to specify its PID, as no result is expected to be returned back to it.</p>
<p>If ever the caller sends by mistake its PID nevertheless, a warning is sent back to it, the atom <tt class="docutils literal">wooper_method_returns_void</tt>, instead of <tt class="docutils literal">{wooper_result,Result}</tt>.</p>
<p>The proper way of calling a oneway method is to send to it an Erlang message that is:</p>
<ul class="simple">
<li>either a pair, i.e. a 2-element tuple (therefore with no PID specified): <tt class="docutils literal"><span class="pre">{oneway_name,[Arg1,Arg2,..]}</span></tt> or <tt class="docutils literal">{oneway_name,Arg}</tt> if <tt class="docutils literal">Arg</tt> is not a list; for example: <tt class="docutils literal">MyPoint ! <span class="pre">{setCoordinates,[14,6]}</span></tt> or <tt class="docutils literal">MyCat ! {setAge,5}</tt></li>
<li>or, if the oneway does not take any parameter, just the atom <tt class="docutils literal">oneway_name</tt>. For example: <tt class="docutils literal">MyCat ! declareBirthday</tt></li>
</ul>
<p>No return should be expected (the called instance does not even know the PID of the caller), so no receive should be attempted on the caller side, unless wanting to wait until the end of time.</p>
<p>Due to the nature of oneways, if an error occurs instance-side during the call, the caller will never be notified of it.</p>
<p>However, to help the debugging, an error message is then logged (using <tt class="docutils literal">error_logger:error_msg</tt>) and the actual error message, the one that would be sent back to the caller if the method was a request, is given to <tt class="docutils literal">erlang:exit</tt> instead.</p>
</div>
</div>
<div class="section" id="method-results">
<h3><a class="toc-backref" href="#id180">Method Results</a></h3>
<div class="section" id="execution-success-wooper-result-actualresult">
<h4>Execution Success: <tt class="docutils literal">{wooper_result,ActualResult}</tt></h4>
<p>If the execution of a method succeeded, and if the method is a request, then <tt class="docutils literal">{wooper_result,ActualResult}</tt> will be sent back to the caller (precisely: to the process whose PID was specified in the call triplet).</p>
<p>Otherwise one of the following error messages will be emitted <a class="footnote-reference" href="#id16" id="id15">[7]</a>.</p>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[7]</a></td><td>Note, though, that in general terms there is little interest in pattern-matching these messages (defensive programming is not always the best option; linking created active instances to their creator is usually a better approach).</td></tr>
</tbody>
</table>
</div>
<div class="section" id="execution-failures">
<h4>Execution Failures</h4>
<p>When the execution of a method fails, three main error results can be output (as a message for requests, as a log for oneways).</p>
<p>A summary could be:</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="35%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Error Result</th>
<th class="head">Interpretation</th>
<th class="head">Likely guilty</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">wooper_method_not_found</tt></td>
<td>No such method exists in
the target class.</td>
<td>Caller</td>
</tr>
<tr><td><tt class="docutils literal">wooper_method_failed</tt></td>
<td>Method triggered a runtime
error (it has a bug).</td>
<td>Called instance</td>
</tr>
<tr><td><tt class="docutils literal">wooper_method_faulty_return</tt></td>
<td>Method does not respect
the WOOPER return
convention.</td>
<td>Called instance</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As mentioned above, failure detection may better be done through the use of (Erlang) links, either explicitly set (with <tt class="docutils literal">erlang:link/1</tt>) or, preferably (ex: to avoid race conditions), with a linked variation of the <tt class="docutils literal">new</tt> operator (ex: <tt class="docutils literal">new_link/N</tt>), as discussed later in this document.
So a reader in a hurry may want to skip these considerations and directly jump to the <a class="reference internal" href="#method-definition">Method Definition</a> section.</p>
</div>
<div class="section" id="wooper-method-not-found">
<h5><tt class="docutils literal">wooper_method_not_found</tt></h5>
<p>The corresponding error message is:</p>
<pre class="literal-block">
{wooper_method_not_found,InstancePid,Classname,MethodName,
 MethodArity,ListOfActualParameters}
</pre>
<p>The corresponding error message is:</p>
<pre class="literal-block">
{wooper_method_not_found,InstancePid,Classname,MethodName,
 MethodArity,ListOfActualParameters}.
</pre>
<p>For example:</p>
<pre class="literal-block">
{wooper_method_not_found,&lt;0.30.0&gt;,class_Cat,layEggs,2,...}
</pre>
<p>Note that <tt class="docutils literal">MethodArity</tt> includes the implied state parameter (that will be discussed later), i.e. here <tt class="docutils literal">layEggs/2</tt> might be defined as <tt class="docutils literal">layEggs(State,NumberOfNewEggs) <span class="pre">-&gt;</span> <span class="pre">[..]</span></tt>.</p>
<p>This error occurs whenever a called method could not be found in the whole inheritance graph of the target class. It means this method is not implemented, at least not with the deduced arity.</p>
<p>More precisely, when a message <tt class="docutils literal"><span class="pre">{method_name,[Arg1,Arg2,..,ArgN]...}</span></tt> (request or oneway) is received, <tt class="docutils literal">method_name/N+1</tt> has be to called: WOOPER tries to find <tt class="docutils literal"><span class="pre">method_name(State,Arg1,..,ArgN)</span></tt>, and the method name and arity must match.</p>
<p>If no method could be found, the <tt class="docutils literal">wooper_method_not_found</tt> atom is returned (if the method is a request, otherwise the error is logged), and the object state will not change, nor the instance will crash, as this error is deemed a caller-side one (i.e. the instance has a priori nothing to do with the error).</p>
</div>
<div class="section" id="wooper-method-failed">
<h5><tt class="docutils literal">wooper_method_failed</tt></h5>
<p>The corresponding error message is:</p>
<pre class="literal-block">
{wooper_method_failed,InstancePid,Classname,MethodName,
 MethodArity, ListOfActualParameters,ErrorTerm}
</pre>
<p>For example:</p>
<pre class="literal-block">
{wooper_method_failed,&lt;0.30.0&gt;,class_Cat,myCrashingMethod,1,[],
 {{badmatch,create_bug},[..]]}
</pre>
<p>If the exit message sent by the method specifies a PID, it is prepended to <tt class="docutils literal">ErrorTerm</tt>.</p>
<p>Such a method error means that there is a runtime failure, it is generally deemed an instance-side issue (the caller should not be responsible for it, unless it sent incorrect parameters), thus the instance process logs that error, sends an error term to the caller (if and only if it is a request), and then exits with the same error term.</p>
</div>
<div class="section" id="wooper-method-faulty-return">
<h5><tt class="docutils literal">wooper_method_faulty_return</tt></h5>
<p>The corresponding error message is:</p>
<pre class="literal-block">
{wooper_method_faulty_return,InstancePid,Classname,MethodName,
 MethodArity,ListOfActualParameters,ActualReturn}``.
</pre>
<p>For example:</p>
<pre class="literal-block">
{wooper_method_faulty_return,&lt;0.30.0&gt;,class_Cat,
 myFaultyMethod,1,[],[{{state_holder,..]}
</pre>
<p>This error occurs only when being in debug mode.</p>
<p>The main reason for this to happen is when debug mode is set and when a method implementation did not respect the expected method return convention (more on that later).</p>
<p>It means that the method is not implemented correctly (it has a bug), or, possibly, that it was not (re)compiled with the proper debug mode, i.e. the one the caller was compiled with.</p>
<p>This is an instance-side failure (the caller has no responsibility for that), thus the instance process logs that error, sends an error term to the caller (if and only if it is a request), and then exits with the same error term.</p>
</div>
<div class="section" id="caller-side-error-management">
<h5>Caller-Side Error Management</h5>
<p>As we can see, errors can be better discriminated if needed, on the caller side.
Therefore one could make use of that information, as in:</p>
<pre class="code erlang literal-block">
<span class="nv">MyPoint</span> <span class="o">!</span> <span class="p">{</span><span class="n">getCoordinates</span><span class="p">,[],</span><span class="n">self</span><span class="p">()},</span>
<span class="k">receive</span>
   <span class="p">{</span><span class="n">wooper_result</span><span class="p">,[</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">]}</span><span class="o">-&gt;</span>
       <span class="p">[..];</span>
   <span class="p">{</span><span class="n">wooper_method_not_found</span><span class="p">,</span><span class="nv">Pid</span><span class="p">,</span><span class="nv">Class</span><span class="p">,</span><span class="nv">Method</span><span class="p">,</span><span class="nv">Arity</span><span class="p">,</span><span class="nv">Params</span><span class="p">}</span><span class="o">-&gt;</span>
       <span class="p">[..];</span>
   <span class="p">{</span><span class="n">wooper_method_failed</span><span class="p">,</span><span class="nv">Pid</span><span class="p">,</span><span class="nv">Class</span><span class="p">,</span><span class="nv">Method</span><span class="p">,</span><span class="nv">Arity</span><span class="p">,</span><span class="nv">Params</span><span class="p">,</span>
         <span class="nv">ErrorTerm</span><span class="p">}</span><span class="o">-&gt;</span>
       <span class="p">[..];</span>
   <span class="c">% Error term can be a {Pid,Error} tuple as well, depending
</span>   <span class="c">% on the exit:
</span>   <span class="p">{</span><span class="n">wooper_method_failed</span><span class="p">,</span><span class="nv">Pid</span><span class="p">,</span><span class="nv">Class</span><span class="p">,</span><span class="nv">Method</span><span class="p">,</span><span class="nv">Arity</span><span class="p">,</span><span class="nv">Params</span><span class="p">,</span>
         <span class="p">{</span><span class="nv">Pid</span><span class="p">,</span><span class="nv">Error</span><span class="p">}}</span><span class="o">-&gt;</span>
       <span class="p">[..];</span>
   <span class="p">{</span><span class="n">wooper_method_faulty_return</span><span class="p">,</span><span class="nv">Pid</span><span class="p">,</span><span class="nv">Class</span><span class="p">,</span><span class="nv">Method</span><span class="p">,</span><span class="nv">Arity</span><span class="p">,</span><span class="nv">Params</span><span class="p">,</span>
                <span class="nv">UnexpectedTerm</span><span class="p">}</span><span class="o">-&gt;</span>
       <span class="p">[..];</span>
   <span class="n">wooper_method_returns_void</span><span class="o">-&gt;</span>
       <span class="p">[..];</span>
     <span class="nv">OtherError</span> <span class="o">-&gt;</span>
       <span class="c">% Should never happen:
</span>       <span class="p">[..]</span>
<span class="k">end</span><span class="p">.</span>
</pre>
<p>However defensive development is not really favoured in Erlang, one may let the caller crash on unexpected return instead. Therefore generally one may rely simply on matching the message sent in case of success <a class="footnote-reference" href="#id18" id="id17">[8]</a>:</p>
<pre class="code erlang literal-block">
<span class="nv">MyPoint</span> <span class="o">!</span> <span class="p">{</span><span class="n">getCoordinates</span><span class="p">,[],</span><span class="n">self</span><span class="p">()},</span>
<span class="k">receive</span>
     <span class="p">{</span><span class="n">wooper_result</span><span class="p">,</span> <span class="p">[</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">]</span> <span class="p">}</span> <span class="o">-&gt;</span>
       <span class="p">[..]</span>
<span class="k">end</span><span class="p">,</span>
<span class="p">[..]</span>
</pre>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[8]</a></td><td>In which case, should a failure happen, the method call will become blocking; linking or monitoring instances can then be done.</td></tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section" id="method-definition">
<h3><a class="toc-backref" href="#id181">Method Definition</a></h3>
<p>Here we reverse the point of view: instead of <strong>calling</strong> a method, we are in the process of <strong>implementing</strong> a callable one.</p>
<p>A method signature has always for first parameter the state of the instance, for example: <tt class="docutils literal">getAge(State) <span class="pre">-&gt;</span> <span class="pre">[..]</span></tt>, or <tt class="docutils literal">getCoordinate(State,Index) <span class="pre">-&gt;</span> <span class="pre">[..]</span></tt>.</p>
<p>For the sake of clarity, this variable should always be named <tt class="docutils literal">State</tt> exactly (implying it shall not be named for example <tt class="docutils literal">MyState</tt>, or muted as <tt class="docutils literal">_State</tt> <a class="footnote-reference" href="#id20" id="id19">[9]</a>). This convention is now enforced at compile-time.</p>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[9]</a></td><td>The only legit place for <tt class="docutils literal">_State</tt> is when a method clause does not use at all the state variable, which, in practice, happens only when a clause throws an exception.</td></tr>
</tbody>
</table>
<p>A method must always return at least the newer instance state, so that WOOPER can rely on it from now onward.</p>
<p>Note that when a method &quot;returns&quot; the state of the (active) instance, it returns it to the (local, process-wise) private WOOPER-based main loop of that instance: in other words, the state variable is <em>never</em> exported/sent as a message/visible from outside of its process (unless of course a developer writes specific methods for that).</p>
<p>Encapsulation is ensured, as the instance is the only process able to access its own state. On method termination, the instance then just loops again, on its updated state: that new state will be the base one for the next call, and so on.</p>
<p>One should therefore see each WOOPER instance as primarily a process executing a main loop that keeps the current state of that instance:</p>
<ul class="simple">
<li>it is waiting idle for any incoming (WOOPER) message</li>
<li>when such a message is received, based on the actual class of the instance and on the method name specified in the call, the appropriate function defined in the appropriate module is selected by WOOPER, taking into account the inheritance graph (actually a direct per-class mapping, somewhat akin to the C++ virtual table, has already been determined at start-up, for better performances)</li>
<li>then this function is called with the appropriate parameters (those of the call, in addition to the internally kept current state)</li>
<li>if the method is a request, its specified result is sent back to the caller</li>
<li>then the instance loops again, on the state possibly updated by this method call</li>
</ul>
<p>Thus the caller will only receive the <strong>result</strong> of a method, if it is a request. Otherwise, i.e. with oneways, nothing is sent back (nothing can be, anyway, short of knowing the calling PID).</p>
<p>More precisely, depending on its returning a specific result, the method signature will correspond either to the one of a request or of a oneway, and will use in its body a corresponding method terminator (typically either, respectively, <tt class="docutils literal">wooper:return_state_result/2</tt> or <tt class="docutils literal">wooper:return_state/1</tt>) to ensure that a new state <em>and</em> a result are returned, or just a new state.</p>
<p>Note that all clauses of a given method must end directly with such a method terminator; this is so not only to be clearer for the reader, but also for WOOPER itself, so that it can determine the type of method at hand.</p>
<p>Finally, a recommended good practice is to add a type specification (see <a class="reference external" href="http://erlang.org/doc/man/dialyzer.html">Dialyzer</a>) to each method definition, which allows to indicate even more clearly whether it is a request or a oneway, whether it is a <tt class="docutils literal">const</tt> method, etc. Comments are surely welcome additions as well.</p>
</div>
<div class="section" id="for-requests">
<h3><a class="toc-backref" href="#id182">For Requests</a></h3>
<div class="section" id="requests-in-general">
<h4>Requests in general</h4>
<p>Requests will use <tt class="docutils literal">wooper:return_state_result(NewState,Result)</tt> to terminate their clauses: the new state will be kept by the instance, whereas the result will be sent to the caller. Hence <tt class="docutils literal">wooper:return_state_result/2</tt> means that the method returns a state <strong>and</strong> a result.</p>
<p>For example:</p>
<pre class="code erlang literal-block">
<span class="nf">declareSettings</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">Settings</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">NewState</span> <span class="o">=</span> <span class="n">register_settings</span><span class="p">(</span><span class="nv">Settings</span><span class="p">,</span><span class="nv">State</span><span class="p">),</span>
    <span class="nn">wooper</span><span class="p">:</span><span class="nf">return_state_result</span><span class="p">(</span><span class="nv">NewState</span><span class="p">,</span><span class="n">settings_declared</span><span class="p">).</span>
</pre>
<p>Two remarks there:</p>
<ul class="simple">
<li><tt class="docutils literal">register_settings/2</tt> is an helper function here; the <tt class="docutils literal">State</tt> parameter is intentionally put in last position to help the reader distinguishing it from methods (see <a class="reference internal" href="#helper-vs-static">Helper vs Static</a> for more information on this topic)</li>
<li>returning a constant atom (<tt class="docutils literal">settings_declared</tt>) has actually an interest: it allows to make that operation synchronous (i.e. the caller is to wait for that result atom; it is only when the caller receives it that it will know for sure that the operation was performed; otherwise a oneway shall be used)</li>
</ul>
<p>All methods are of course called with the parameters that were specified in their call tuple.</p>
<p>For example, if we declare following request:</p>
<pre class="code erlang literal-block">
<span class="nf">giveBirth</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">NumberOfMaleChildren</span><span class="p">,</span><span class="nv">NumberOfFemaleChildren</span><span class="p">)</span> <span class="o">-&gt;</span>
   <span class="p">[..]</span>
</pre>
<p>Then we may call it, in the case of a cat having 2 male kitten and 3 female ones, with:</p>
<pre class="code erlang literal-block">
<span class="nv">MyCat</span> <span class="o">!</span> <span class="p">{</span><span class="n">giveBirth</span><span class="p">,[_</span><span class="nv">Male</span><span class="o">=</span><span class="mi">2</span><span class="p">,_</span><span class="nv">Female</span><span class="o">=</span><span class="mi">3</span><span class="p">],</span><span class="n">self</span><span class="p">()}.</span>
</pre>
</div>
<div class="section" id="const-requests">
<h4>Const Requests</h4>
<p>Some clauses of a request may return an unchanged state. It is then a <tt class="docutils literal">const</tt> clause, and rather than using the  <tt class="docutils literal">wooper:return_state_result/2</tt> request terminator, it shall use the <tt class="docutils literal">wooper:const_return_result/1</tt> one.</p>
<p>A request whose clauses are all <tt class="docutils literal">const</tt> is itself a const request.</p>
<p>For example, instead of:</p>
<pre class="code erlang literal-block">
<span class="nf">getWhiskerColor</span><span class="p">(</span><span class="nv">State</span><span class="p">)</span> <span class="o">-&gt;</span>
   <span class="nn">wooper</span><span class="p">:</span><span class="nf">return_state_result</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="o">?</span><span class="n">getAttr</span><span class="p">(</span><span class="n">whisker_color</span><span class="p">)).</span>
</pre>
<p>one should prefer writing this const request as (and WOOPER will enforce it):</p>
<pre class="code erlang literal-block">
<span class="nf">getWhiskerColor</span><span class="p">(</span><span class="nv">State</span><span class="p">)</span> <span class="o">-&gt;</span>
   <span class="nn">wooper</span><span class="p">:</span><span class="nf">const_return_result</span><span class="p">(</span><span class="o">?</span><span class="n">getAttr</span><span class="p">(</span><span class="n">whisker_color</span><span class="p">)).</span>
</pre>
<p>Note that <tt class="docutils literal">State</tt> can be used as always, and that even there it is not reported as unused (so one should not attempt to mute it, for example as <tt class="docutils literal">_State</tt>).</p>
</div>
<div class="section" id="sender-pid">
<h4>Sender PID</h4>
<p>Requests can access to one more information than oneways: the PID of the caller that sent the request. As WOOPER takes care automatically of sending back the result to the caller, having the request know explicitly the caller is usually not useful, thus the caller PID does not appear explicitly in request signatures, among the actual parameters.</p>
<p>However WOOPER keeps track of this information, which remains available to requests, and may be useful for some of them.</p>
<p>From a request body, the caller PID can indeed be retrieved by using the <tt class="docutils literal">getSender</tt> macro, which is automatically managed by WOOPER:</p>
<pre class="code erlang literal-block">
<span class="nf">giveBirth</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">NumberOfMaleChildren</span><span class="p">,</span><span class="nv">NumberOfFemaleChildren</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">[..]</span>
    <span class="nv">CallerPID</span> <span class="o">=</span> <span class="o">?</span><span class="n">getSender</span><span class="p">(),</span>
    <span class="p">[..]</span>
</pre>
<p>Thus a request has natively access to its caller PID, i.e. with no need to specify it in the parameters as well as in the third element of the call tuple; so, instead of having to define:</p>
<pre class="code erlang literal-block">
<span class="nv">MyCat</span> <span class="o">!</span> <span class="p">{</span><span class="n">giveBirth</span><span class="p">,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">self</span><span class="p">()],</span><span class="n">self</span><span class="p">()}</span>
</pre>
<p>one can rely on only:</p>
<pre class="code erlang literal-block">
<span class="nv">MyCat</span> <span class="o">!</span> <span class="p">{</span><span class="n">giveBirth</span><span class="p">,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="n">self</span><span class="p">()}</span>
</pre>
<p>while still letting the possibility for the called request (here <tt class="docutils literal">giveBirth/3</tt>, for a state and two parameters) to access the caller PID thanks to the <tt class="docutils literal">getSender</tt> macro, and maybe store it for a later use or do anything appropriate with it.</p>
<p>Note that:</p>
<ul class="simple">
<li>having to handle explicitly the caller PID is rather uncommon, as WOOPER takes care automatically of the sending of the result back to the caller</li>
<li>the <tt class="docutils literal">getSender</tt> macro should only be used for requests, as of course the sender PID has no meaning in the case of oneways; if that macro is called nevertheless from a oneway, then it returns the atom <tt class="docutils literal">undefined</tt>.</li>
</ul>
</div>
<div class="section" id="request-type-specifications">
<h4>Request Type Specifications</h4>
<p>Using them is not mandatory, yet is very much recommended, and WOOPER provides suitable constructs for that.</p>
<p>As mentioned, a request is to return a new state and a result. The former is always <tt class="docutils literal">wooper:state()</tt>, so it may be made implicit. The latter can be any type <tt class="docutils literal">T()</tt>. So a request may be considered as returning the WOOPER <tt class="docutils literal"><span class="pre">request_return(T())</span></tt> type.</p>
<p>As for const requests, they shall be considered returning the <tt class="docutils literal"><span class="pre">const_request_return(T())</span></tt> type.</p>
<p>Making the previous examples more complete:</p>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">spec</span> <span class="n">declareSettings</span><span class="p">(</span><span class="nn">wooper</span><span class="p">:</span><span class="nf">state</span><span class="p">(),</span><span class="n">settings</span><span class="p">())</span> <span class="o">-&gt;</span>
               <span class="n">request_return</span><span class="p">(</span><span class="n">'settings_declared'</span><span class="p">).</span>
<span class="nf">declareSettings</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">Settings</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">NewState</span> <span class="o">=</span> <span class="n">register_settings</span><span class="p">(</span><span class="nv">Settings</span><span class="p">,</span><span class="nv">State</span><span class="p">),</span>
    <span class="nn">wooper</span><span class="p">:</span><span class="nf">return_state_result</span><span class="p">(</span><span class="nv">NewState</span><span class="p">,</span><span class="n">settings_declared</span><span class="p">).</span>

<span class="p">-</span><span class="ni">spec</span> <span class="n">getWhiskerColor</span><span class="p">(</span><span class="nn">wooper</span><span class="p">:</span><span class="nf">state</span><span class="p">())</span> <span class="o">-&gt;</span>
               <span class="n">const_request_return</span><span class="p">(</span><span class="n">color</span><span class="p">()).</span>
<span class="nf">getWhiskerColor</span><span class="p">(</span><span class="nv">State</span><span class="p">)</span> <span class="o">-&gt;</span>
   <span class="nn">wooper</span><span class="p">:</span><span class="nf">const_return_result</span><span class="p">(</span><span class="o">?</span><span class="n">getAttr</span><span class="p">(</span><span class="n">whisker_color</span><span class="p">)).</span>
</pre>
<p>(of course the developer is responsible for the definition of the <tt class="docutils literal">settings()</tt> and <tt class="docutils literal">color()</tt> types here)</p>
<p>Note that we prefer surrounding atoms in single quotes when specified as a type.</p>
<p>Of course, should type specifications be used, they must be correct; WOOPER will for example raise a compile-time error should <tt class="docutils literal">request_return/1</tt> be used on a function that is not detected as a request.</p>
</div>
</div>
<div class="section" id="for-oneways">
<h3><a class="toc-backref" href="#id183">For Oneways</a></h3>
<p>After relevant adaptations, most of the conventions for requests apply to oneways.</p>
<div class="section" id="oneways-in-general">
<h4>Oneways in general</h4>
<p>Oneways will use <tt class="docutils literal">wooper:return_state(NewState)</tt> to terminate their clauses: the new state will be kept by the instance, and no result will be returned to the caller (which is not even known - hence no <tt class="docutils literal"><span class="pre">?getSender</span></tt> macro applies to oneways either).</p>
<p>For example:</p>
<pre class="code erlang literal-block">
<span class="nf">setAge</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">NewAge</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nn">wooper</span><span class="p">:</span><span class="nf">return_state</span><span class="p">(</span><span class="n">setAttribute</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="n">age</span><span class="p">,</span><span class="nv">NewAge</span><span class="p">)).</span>
</pre>
<p>This oneway can be called that way:</p>
<pre class="code erlang literal-block">
<span class="nv">MyCat</span> <span class="o">!</span> <span class="p">{</span><span class="n">setAge</span><span class="p">,</span><span class="mi">4</span><span class="p">}.</span>
<span class="c">% No result to expect.</span>
</pre>
</div>
<div class="section" id="const-oneways">
<h4>Const Oneways</h4>
<p>Even if it is less frequent than for requests, oneways may also be <tt class="docutils literal">const</tt>, i.e. may leave the state unchanged, and consequently are only called for side-effects; for example, rather than specifying:</p>
<pre class="code erlang literal-block">
<span class="nf">displayAge</span><span class="p">(</span><span class="nv">State</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;My age is </span><span class="si">~B~n</span><span class="s">.&quot;</span><span class="p">,[</span><span class="o">?</span><span class="n">getAttr</span><span class="p">(</span><span class="n">age</span><span class="p">)]),</span>
    <span class="nn">wooper</span><span class="p">:</span><span class="nf">return_state</span><span class="p">(</span><span class="nv">State</span><span class="p">).</span>
</pre>
<p>WOOPER will ensure that, in this case, <tt class="docutils literal">wooper:const_return/0</tt> is preferred to <tt class="docutils literal">wooper:return_state/1</tt>:</p>
<pre class="code erlang literal-block">
<span class="nf">displayAge</span><span class="p">(</span><span class="nv">State</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;My age is </span><span class="si">~B~n</span><span class="s">.&quot;</span><span class="p">,[</span><span class="o">?</span><span class="n">getAttr</span><span class="p">(</span><span class="n">age</span><span class="p">)]),</span>
    <span class="nn">wooper</span><span class="p">:</span><span class="nf">const_return</span><span class="p">().</span>
</pre>
<p>A oneway whose clauses are all <tt class="docutils literal">const</tt> is itself a const oneway.</p>
</div>
<div class="section" id="oneway-type-specifications">
<h4>Oneway Type Specifications</h4>
<p>The type specification of a oneway should rely, for its return type, either on <tt class="docutils literal">oneway_return()</tt> or on <tt class="docutils literal">const_oneway_return()</tt>, depending on its constness (no result to account for in either case).</p>
<p>Making the previous examples more complete:</p>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">spec</span> <span class="n">setAge</span><span class="p">(</span><span class="nn">wooper</span><span class="p">:</span><span class="n">state</span><span class="p">,</span><span class="n">age</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="n">oneway_return</span><span class="p">().</span>
<span class="nf">setAge</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">NewAge</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nn">wooper</span><span class="p">:</span><span class="nf">return_state</span><span class="p">(</span><span class="n">setAttribute</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="n">age</span><span class="p">,</span><span class="nv">NewAge</span><span class="p">)).</span>

<span class="p">-</span><span class="ni">spec</span> <span class="n">displayAge</span><span class="p">(</span><span class="nn">wooper</span><span class="p">:</span><span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">const_oneway_return</span><span class="p">().</span>
<span class="nf">displayAge</span><span class="p">(</span><span class="nv">State</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;My age is </span><span class="si">~B~n</span><span class="s">.&quot;</span><span class="p">,[</span><span class="o">?</span><span class="n">getAttr</span><span class="p">(</span><span class="n">age</span><span class="p">)]),</span>
    <span class="nn">wooper</span><span class="p">:</span><span class="nf">const_return</span><span class="p">().</span>
</pre>
</div>
</div>
<div class="section" id="usefulness-of-the-method-terminators">
<h3><a class="toc-backref" href="#id184">Usefulness Of the Method Terminators</a></h3>
<p>The actual definition of the method terminators (ex: <tt class="docutils literal">wooper:return_state_result/2</tt>, <tt class="docutils literal">wooper:return_state/1</tt>) is actually quite straightforward.</p>
<p>For example <tt class="docutils literal">wooper:return_state_result(AState,AResult)</tt> will simply translate into <tt class="docutils literal">{AState,AResult}</tt>, and <tt class="docutils literal">wooper:return_state(AState)</tt> will translate into <tt class="docutils literal">AState</tt>.</p>
<p>Their purpose is just to structure the method implementations, helping the method developer not mixing updated states and results, and helping WOOPER in categorizing appropriately all Erlang-level functions.</p>
<p>More precisely, as mentioned, all clauses of a method must directly end with a call to its corresponding WOOPER method terminator.</p>
<p>For example, the following extract is correct:</p>
<pre class="code erlang literal-block">
<span class="c">% Returns the name of this instance.
</span><span class="p">-</span><span class="ni">spec</span> <span class="n">getName</span><span class="p">(</span><span class="nn">wooper</span><span class="p">:</span><span class="nf">state</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="n">request_return</span><span class="p">(</span><span class="n">name</span><span class="p">()).</span>
<span class="nf">getName</span><span class="p">(</span><span class="nv">State</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="nv">Name</span> <span class="o">=</span> <span class="n">nested_in_request</span><span class="p">(</span><span class="nv">State</span><span class="p">),</span>
  <span class="nn">wooper</span><span class="p">:</span><span class="nf">const_return_result</span><span class="p">(</span><span class="nv">Name</span><span class="p">).</span>

<span class="c">% (helper)
</span><span class="nf">nested_in_request</span><span class="p">(</span><span class="nv">State</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">getAttr</span><span class="p">(</span><span class="n">name</span><span class="p">).</span>
</pre>
<p>Whereas the next one is wrong, as <tt class="docutils literal">getName/1</tt> would be identified as a unexported plain function (instead of as a const request), and the other way round for <tt class="docutils literal">nested_in_request/1</tt>:</p>
<pre class="code erlang literal-block">
<span class="c">% Returns the name of this instance.
</span><span class="p">-</span><span class="ni">spec</span> <span class="n">getName</span><span class="p">(</span><span class="nn">wooper</span><span class="p">:</span><span class="nf">state</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="n">request_return</span><span class="p">(</span><span class="n">name</span><span class="p">()).</span>
<span class="nf">getName</span><span class="p">(</span><span class="nv">State</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="n">nested_in_request</span><span class="p">(</span><span class="nv">State</span><span class="p">).</span>

<span class="c">% (helper)
</span><span class="nf">nested_in_request</span><span class="p">(</span><span class="nv">State</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="nn">wooper</span><span class="p">:</span><span class="nf">const_return_result</span><span class="p">(</span><span class="o">?</span><span class="n">getAttr</span><span class="p">(</span><span class="n">name</span><span class="p">)).</span>
</pre>
<p>Defining <tt class="docutils literal">nested_in_request/1</tt> as shown below would not help either of course:</p>
<pre class="code erlang literal-block">
<span class="c">% (helper)
</span><span class="nf">nested_in_request</span><span class="p">(</span><span class="nv">State</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">getAttr</span><span class="p">(</span><span class="n">name</span><span class="p">).</span>
</pre>
<p>So, should a method be reported as unused, most probably that no method terminator was used (hence it was not identified as such, and thus not auto-exported, and thus may be reported as unused).</p>
</div>
<div class="section" id="self-invocation-calling-a-method-from-the-instance-itself">
<h3><a class="toc-backref" href="#id185">Self-Invocation: Calling a Method From the Instance Itself</a></h3>
<p>When implementing a method of a class, one may want to call other methods <strong>of that same class</strong> (have they been overridden or not).</p>
<p>For example, when developing the <tt class="docutils literal">declareBirthday/1</tt> oneway of <tt class="docutils literal">class_Mammal</tt> (which, among other things, is expected to increment the mammal age), one may want to perform a call to its <tt class="docutils literal">setAge/2</tt> oneway (possibly introduced by an ancestor class like <tt class="docutils literal">class_Creature</tt>, or possibly overridden directly in <tt class="docutils literal">class_Mammal</tt>) on the current instance.</p>
<p>One <em>could</em> refer to this method respectively as a function exported by that ancestor (ex: called as <tt class="docutils literal"><span class="pre">class_Creature:setAge(...)</span></tt>) or that is local to the current module (a direct <tt class="docutils literal"><span class="pre">setAge(...)</span></tt> local call designating then <tt class="docutils literal">class_Mammal:setAge/2</tt>).</p>
<p>However, in the future, child classes of <tt class="docutils literal">class_Mammal</tt> may be introduced (ex: <tt class="docutils literal">class_Cat</tt>), and they might define their own version of <tt class="docutils literal">setAge/2</tt>.</p>
<p>Instead of hardcoding which version of that method shall be called (like in the two previous cases, which establish statically the intended version to call), a developer may desire - if not expect - that, for a cat or for any specialised version thereof, <tt class="docutils literal">declareBirthday/1</tt> calls automatically the &quot;right&quot; <tt class="docutils literal">setAge/2</tt> method (i.e. the lastly overridden one in the inheritance graph). Possibly any <tt class="docutils literal">class_Cat:setAge/2</tt> - not the version of <tt class="docutils literal">class_Creature</tt> or <tt class="docutils literal">class_Mammal</tt>.</p>
<p>Such an inheritance-aware call could be easily triggered asynchronously: a classical message-based method call directly addressed by an instance to itself could be used, like in <tt class="docutils literal"><span class="pre">self()!{setAge,10}</span></tt>, and (thanks to WOOPER) this would lead to executing the &quot;right&quot; version of that method.</p>
<p>If this approach may be useful when not directly needing, from the method, the result of the call and/or not needing to have it executed at once, in the general case one wants to have that possibly overridden method be executed <em>directly</em>, synchronously, and to obtain immediately the corresponding updated state and, if relevant, the associated output result.</p>
<div class="section" id="inheritance-based-self-invocation">
<h4>Inheritance-based Self-Invocation</h4>
<p>To perform the self-invocation of a method whose actual implementation is automatically determined based on the inheritance of the class at hand, one should call the WOOPER-defined <tt class="docutils literal"><span class="pre">executeRequest/{2,3}</span></tt> or <tt class="docutils literal"><span class="pre">executeOneway/{2,3}</span></tt> functions (or any variation thereof), depending on the type of the method to call.</p>
<p>These two helper functions behave quite similarly to the actual method calls that are based on the operator <tt class="docutils literal">!</tt>, except that no target instance has to be specified (since it is by definition a call made by an instance to itself) and that no message exchange at all is involved: the method look-up is just performed through the inheritance hierarchy, the correct method is called with the specified parameters and the result is then directly returned.</p>
<p>More precisely, <strong>executeRequest</strong> is <tt class="docutils literal">executeRequest/2</tt> or <tt class="docutils literal">executeRequest/3</tt>, its parameters being the current state, the name of the request method, and, if needed, the parameters of the called request, either as a list or as a standalone one.</p>
<p><tt class="docutils literal">executeRequest</tt> returns a pair made of the new state and of the result.</p>
<p>For example, for a request taking more than one parameter, or one list parameter:</p>
<pre class="code erlang literal-block">
<span class="p">{</span><span class="nv">NewState</span><span class="p">,</span><span class="nv">Result</span><span class="p">}</span> <span class="o">=</span> <span class="n">executeRequest</span><span class="p">(</span><span class="nv">CurrentState</span><span class="p">,</span><span class="n">myRequestName</span><span class="p">,</span>
                               <span class="p">[</span><span class="s">&quot;hello&quot;</span><span class="p">,</span><span class="mi">42</span><span class="p">])</span>
</pre>
<p>For a request taking exactly one, non-list, parameter:</p>
<pre class="code erlang literal-block">
<span class="p">{</span><span class="nv">NewState</span><span class="p">,</span><span class="nv">NewCounter</span><span class="p">}</span> <span class="o">=</span> <span class="n">executeRequest</span><span class="p">(</span><span class="nv">CurrentState</span><span class="p">,</span>
                               <span class="n">addToCurrentCounter</span><span class="p">,</span><span class="mi">78</span><span class="p">)</span>
</pre>
<p>For a request taking no parameter:</p>
<pre class="code erlang literal-block">
<span class="p">{</span><span class="nv">NewState</span><span class="p">,</span><span class="nv">Sentence</span><span class="p">}</span> <span class="o">=</span> <span class="n">executeRequest</span><span class="p">(</span><span class="nv">CurrentState</span><span class="p">,</span><span class="n">getLastSentence</span><span class="p">)</span>
</pre>
<p>Const requests can be called <a class="footnote-reference" href="#id22" id="id21">[10]</a> as well, like in:</p>
<pre class="code erlang literal-block">
<span class="nv">Color</span> <span class="o">=</span> <span class="n">executeConstRequest</span><span class="p">(</span><span class="nv">CurrentState</span><span class="p">,</span><span class="n">getColor</span><span class="p">)</span>
</pre>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id21">[10]</a></td><td>Note that currently WOOPER will not check that a called request is indeed const, and will silently drop any updated state.</td></tr>
</tbody>
</table>
<p>Regarding now <strong>executeOneway</strong>, it is either <tt class="docutils literal">executeOneway/2</tt> or <tt class="docutils literal">executeOneway/3</tt>, depending on whether the oneway takes parameters. If yes, they can be specified as a list (if there are more than one) or, as always, as a standalone non-list parameter.</p>
<p><tt class="docutils literal">executeOneway</tt> returns the new state.</p>
<p>For example, a oneway taking more than one parameter, or one list parameter:</p>
<pre class="code erlang literal-block">
<span class="nv">NewState</span> <span class="o">=</span> <span class="n">executeOneway</span><span class="p">(</span><span class="nv">CurrentState</span><span class="p">,</span><span class="n">say</span><span class="p">,[</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="mi">42</span> <span class="p">])</span>
</pre>
<p>For a oneway taking exactly one (non-list) parameter:</p>
<pre class="code erlang literal-block">
<span class="nv">NewState</span> <span class="o">=</span> <span class="n">executeOneway</span><span class="p">(</span><span class="nv">CurrentState</span><span class="p">,</span><span class="n">setAge</span><span class="p">,</span><span class="mi">78</span><span class="p">)</span>
</pre>
<p>For a oneway taking no parameter:</p>
<pre class="code erlang literal-block">
<span class="nv">NewState</span> <span class="o">=</span> <span class="n">executeOneway</span><span class="p">(</span><span class="nv">CurrentState</span><span class="p">,</span><span class="n">declareBirthday</span><span class="p">)</span>
</pre>
<p>Const oneways can also be called <a class="footnote-reference" href="#id24" id="id23">[11]</a> as well, like in:</p>
<pre class="code erlang literal-block">
<span class="nf">executeConstOneway</span><span class="p">(</span><span class="nv">CurrentState</span><span class="p">,</span><span class="n">displayAge</span><span class="p">)</span>
</pre>
<table class="docutils footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id23">[11]</a></td><td>Note that currently WOOPER will not check that a called oneway is indeed const, and will silently drop any updated state.</td></tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As discussed previously, there are caller-side errors that are not expected to crash the instance. If such a call is performed directly from that instance (i.e. with one of the <tt class="docutils literal">execute*</tt> constructs), then two errors will be output: the first, non-fatal for the instance, due to the method call, then the second, fatal for the instance, due to the failure of the <tt class="docutils literal">execute*</tt> call. This is the expected behaviour, as here the instance plays both roles, the caller and the callee.</p>
</div>
</div>
<div class="section" id="self-invocation-of-an-explicitly-designated-method">
<h4>Self-Invocation of an Explicitly-Designated Method</h4>
<p>One can specify <strong>explicitly</strong> the class (of course belonging to the inheritance graph of the class at hand) defining the version of the method that one wants to execute, bypassing the inheritance-aware overriding system.</p>
<p>For example, a method needing to call <tt class="docutils literal">setAge/2</tt> from its body would be expected to use something like: <tt class="docutils literal">AgeState = executeOneway(State,setAge,NewAge)</tt>.</p>
<p>If <tt class="docutils literal">class_Cat</tt> overrode <tt class="docutils literal">setAge/2</tt>, any cat instance would then call the overridden <tt class="docutils literal">class_Cat:setAge/2</tt> method instead of the original <tt class="docutils literal">class_Creature:setAge/2</tt>.</p>
<p>What if our specific method of <tt class="docutils literal">class_Cat</tt> wanted, for any reason, to call the <tt class="docutils literal">class_Creature</tt> version of <tt class="docutils literal">setAge/2</tt>, now shadowed by an overridden version of it? In this case a <tt class="docutils literal">execute*As</tt> function should be used.</p>
<p>These functions, which are <tt class="docutils literal"><span class="pre">executeRequestAs/{3,4}</span></tt> and <tt class="docutils literal"><span class="pre">executeOnewayAs/{3,4}</span></tt>, behave exactly as the previous <tt class="docutils literal">execute*</tt> functions, except that they take an additional parameter (to be specified just after the state) that is the name of the mother class (direct or not) having defined the version of the method that we want to execute.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This mother class does not have to have specifically defined or overridden that method: this method will just be called in the context of that class, as if it was an instance of the mother class rather than one of the actual child class.</p>
</div>
<p>In our example, we should thus use simply:</p>
<pre class="code erlang literal-block">
<span class="nv">AgeState</span> <span class="o">=</span> <span class="n">executeOnewayAs</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="n">class_Creature</span><span class="p">,</span><span class="n">setAge</span><span class="p">,</span><span class="nv">NewAge</span><span class="p">)</span>
</pre>
<p>in order to call the <tt class="docutils literal">class_Creature</tt> version of the <tt class="docutils literal">setAge/2</tt> oneway.</p>
<p>Finally, as one could expect, these functions have their const counterparts, namely: <tt class="docutils literal"><span class="pre">executeConstRequestAs/{3,4}</span></tt> and <tt class="docutils literal"><span class="pre">executeConstOnewayAs/{3,4}</span></tt>, whose usage offers no surprise, like in:</p>
<pre class="literal-block">
Color = executeConstRequestAs(MyState,class_Vehicle,
                              getColorOf,[wheels])
</pre>
</div>
</div>
<div class="section" id="static-methods">
<span id="static-method"></span><h3><a class="toc-backref" href="#id186">Static Methods</a></h3>
<p>Static methods, as opposed to member methods, do not target specifically an instance, they are defined at the class level.</p>
<p>They thus do not operate on a specified process or PID, they are just to be called thanks to their module name, exactly as any exported standard function.</p>
<p>In order to further separate them from member methods, we recommend that the names of static methods obey the <tt class="docutils literal">snake_case</tt> convention (as opposed to <tt class="docutils literal">CamelCase</tt> one): a static method may for example be named <tt class="docutils literal">get_default_settings</tt> (rather than <tt class="docutils literal">getDefaultSettings</tt>).</p>
<p>Being class-level, their actual definition does not involve any specific instance state, and so only a result is to be returned thanks to their method terminator, which is <tt class="docutils literal">wooper:return_static/1</tt>.</p>
<p>The same applies to their result type in terms of type specification, which is to be expressed using <tt class="docutils literal"><span class="pre">static_return(T())</span></tt>.</p>
<p>Here are a few examples of rather straightforward static methods, with or without type specifications:</p>
<pre class="code erlang literal-block">
<span class="nf">get_default_whisker_color</span><span class="p">()</span> <span class="o">-&gt;</span>
    <span class="nn">wooper</span><span class="p">:</span><span class="nf">return_static</span><span class="p">(</span><span class="n">black</span><span class="p">).</span>

<span class="p">-</span><span class="ni">spec</span> <span class="n">determine_croquette_appeal</span><span class="p">(</span><span class="n">cat_name</span><span class="p">())</span> <span class="o">-&gt;</span>
           <span class="n">static_return</span><span class="p">(</span><span class="n">'strong'</span><span class="p">|</span><span class="n">'moderate'</span><span class="p">|</span><span class="n">'weak'</span><span class="p">).</span>
<span class="nf">determine_croquette_appeal</span><span class="p">(_</span><span class="nv">CatName</span><span class="o">=</span><span class="s">&quot;Tortilla&quot;</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nn">wooper</span><span class="p">:</span><span class="nf">return_static</span><span class="p">(</span><span class="n">strong</span><span class="p">);</span>

<span class="nf">determine_croquette_appeal</span><span class="p">(_</span><span class="nv">CatName</span><span class="o">=</span><span class="s">&quot;Abysse&quot;</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nn">wooper</span><span class="p">:</span><span class="nf">return_static</span><span class="p">(</span><span class="n">moderate</span><span class="p">).</span>
</pre>
<p>An example of use:</p>
<pre class="code erlang literal-block">
<span class="nv">PossibleColor</span> <span class="o">=</span> <span class="nn">class_Cat</span><span class="p">:</span><span class="nf">get_default_whisker_color</span><span class="p">(),</span>
<span class="p">[..]</span>
</pre>
<p>See also the section about <a class="reference internal" href="#methods-not-returning-anything-of-interest">Methods Not Returning Anything of Interest</a>, which may apply to static methods notably.</p>
<p>Finally, having static methods leaves little interest to defining and exporting one's standard, plain (helper) functions; when doing so, one should wonder whether a static method could not be a solution at least as good.</p>
<p>So the main purpose left to helpers is to factor out common, framework-internal code (not targeted at users) across methods (and possibly classes), especially when it involves an instance state (ex: <tt class="docutils literal">display_foo(Color,Index,State) <span class="pre">-&gt;...</span></tt>).</p>
<p></p>
</div>
</div>
<div class="section" id="id25">
<span id="state-management"></span><h2><a class="toc-backref" href="#id187">State Management</a></h2>
<div class="section" id="principles">
<h3><a class="toc-backref" href="#id188">Principles</a></h3>
<p>We are discussing here about how an instance is to manage its inner state.</p>
<p>Its state is only directly accessible from inside the instance, i.e. from the body of its methods, whether they are inherited or not: the state of an instance is <strong>private</strong> (local to its process), and the outside can <em>only</em> access it through the methods defined by its class.</p>
<p>The state of an instance (corresponding to the one that is given by WOOPER as first parameter of all its methods, thanks to a variable conventionally named <tt class="docutils literal">State</tt>) is simply defined as a <strong>set of attributes</strong>.</p>
<p>Each attribute is designated by a name, defined as an atom (we recommend using <tt class="docutils literal">camel_case</tt> for them), and is associated to a mutable value, which can be any Erlang term.</p>
<p>The current state of an instance can be thought as a list of <tt class="docutils literal">{attribute_name,attribute_value}</tt> pairs, like in:</p>
<pre class="code erlang literal-block">
<span class="p">[{</span><span class="n">color</span><span class="p">,</span><span class="n">black</span><span class="p">},</span> <span class="p">{</span><span class="n">fur_color</span><span class="p">,</span><span class="n">sand</span><span class="p">},</span> <span class="p">{</span><span class="n">age</span><span class="p">,</span><span class="mi">13</span><span class="p">},</span> <span class="p">{</span><span class="n">name</span><span class="p">,</span><span class="s">&quot;Tortilla&quot;</span><span class="p">}].</span>
</pre>
</div>
<div class="section" id="state-implementation-details">
<h3><a class="toc-backref" href="#id189">State Implementation Details</a></h3>
<div class="section" id="instance-attributes">
<h4>Instance Attributes</h4>
<div class="section" id="declaring-them">
<h5>Declaring them</h5>
<p>Class-specific attributes may be <strong>declared</strong>, with some qualifiers.</p>
<p>Attribute declarations are fully optional <a class="footnote-reference" href="#id27" id="id26">[12]</a>, yet specifying them is nevertheless recommended, at the first place for the developer and for any upcoming maintainer. As a result, by default WOOPER will issue a warning should no attribute declaration be found.</p>
<table class="docutils footnote" frame="void" id="id27" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id26">[12]</a></td><td>Current versions of WOOPER do not specifically use these information, but future versions may.</td></tr>
</tbody>
</table>
<p>To do so, the <tt class="docutils literal">class_attributes</tt> define must be set (prior to including the WOOPER header) to a list of attribute declarations, like in:</p>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">define</span><span class="p">(</span><span class="no">class_attributes</span><span class="p">,[</span>
            <span class="nv">ATTR_DECL1</span><span class="p">,</span>
            <span class="nv">ATTR_DECL2</span><span class="p">,</span>
            <span class="p">[...]</span>
            <span class="nv">ATTR_DECLN</span><span class="p">]).</span>
<span class="p">[...]</span>
<span class="p">-</span><span class="ni">include</span><span class="p">(</span><span class="s">&quot;wooper.hrl&quot;</span><span class="p">).</span>
<span class="p">[...]</span>
</pre>
<p>These declarations are to relate only to the <strong>class-specific</strong> attributes, i.e. the ones specifically introduced by the class at hand, regardless of the ones inherited from the mother classes.</p>
<p>The most general form of an <strong>attribute declaration</strong> includes the following four information:</p>
<pre class="literal-block">
{Name,Type,QualifierInfo,Description}
</pre>
<p>where:</p>
<ul class="simple" id="attribute-declaration">
<li><tt class="docutils literal">Name</tt> is the name of that attribute, as an atom (ex: <tt class="docutils literal">fur_color</tt>)</li>
<li><tt class="docutils literal">Type</tt> corresponds to the <a class="reference external" href="http://erlang.org/doc/reference_manual/typespec.html">type specification</a> of that attribute (ex: <tt class="docutils literal"><span class="pre">[atom()]</span></tt>, <tt class="docutils literal">foo:color_index()</tt>); note that the Erlang parser will not support the <tt class="docutils literal">|</tt> (i.e. union) operator, like in <tt class="docutils literal"><span class="pre">'foo'|integer()</span></tt>; we recommend to use the <tt class="docutils literal">union</tt> variadic pseudo-function instead (with any arity greater or equal to 2), like in: <tt class="docutils literal"><span class="pre">union('foo',integer())</span></tt></li>
<li><tt class="docutils literal">QualifierInfo</tt> is detailed just below</li>
<li><tt class="docutils literal">Description</tt> is a plain string describing the purpose of this attribute; this is a comment aimed only at humans, which preferably does not start with a capital letter and does not end with a dot (ex: <tt class="docutils literal">&quot;describes the color of the fur of this animal (not including whiskers)&quot;</tt> or a shorter, maybe better, <tt class="docutils literal">&quot;color of the fur of this animal (not including whiskers)&quot;</tt>)</li>
</ul>
<p>A <strong>qualifier information</strong> is either a single qualifier, or a list of qualifiers.</p>
<p>A <strong>qualifier</strong> can be:</p>
<ul>
<li><p class="first">a <em>scope</em> qualifier: <tt class="docutils literal">public</tt>, <tt class="docutils literal">protected</tt> or <tt class="docutils literal">private</tt>; in future versions, a public attribute will correspond to the union of <tt class="docutils literal">settable</tt> and <tt class="docutils literal">gettable</tt> and will result in accessor methods being automatically generated; for example, should the <tt class="docutils literal">fur_color</tt> attribute be declared public, then:</p>
<ul>
<li><p class="first">the <tt class="docutils literal">getFurColor/1</tt> const request would be added (with its spec):</p>
<pre class="literal-block">
getFurColor(State) -&gt;
     wooper:const_return_result(?getAttr(fur_color)).
</pre>
</li>
<li><p class="first">the <tt class="docutils literal">setFurColor/2</tt> oneway would be added (with its spec):</p>
<pre class="literal-block">
setFurColor(State,FurColor) -&gt;
     wooper:return_state(setAttribute(State,fur_color,
                                      FurColor)).
</pre>
</li>
</ul>
</li>
<li><p class="first">an <em>initialisation</em> qualifier: <tt class="docutils literal">{initial,18}</tt> would denote that the initial value of the corresponding attribute is <tt class="docutils literal">18</tt> (this value would then be set even before entering any constructor)</p>
</li>
<li><p class="first">a <em>mutability</em> qualifier: <tt class="docutils literal">{const,24}</tt> would denote that the corresponding attribute is <tt class="docutils literal">const</tt> and that its (fixed) value is <tt class="docutils literal">24</tt> (thus <tt class="docutils literal">const</tt> implies here <tt class="docutils literal">initial</tt>, which should not specified in that case); <tt class="docutils literal">const</tt> can also be specified just by itself (with no initial value), so that it can be initialised later, in constructors, and, of course, just once (this is useful for non-immediate, yet const, values)</p>
</li>
<li><p class="first">the <em>none</em> qualifier: <tt class="docutils literal">none</tt> implies that no specific qualifier is specified, and as a result the defaults apply; this qualifier can only be used by itself (not in a list), as an alternative to specifying an empty qualifier list</p>
</li>
</ul>
<p>The defaults are:</p>
<ul class="simple">
<li><tt class="docutils literal">protected</tt></li>
<li>mutable (i.e. non-<tt class="docutils literal">const</tt>)</li>
<li>no specific initial value enforced (not even <tt class="docutils literal">undefined</tt>)</li>
</ul>
<p>So an example of attribute declaration could be:</p>
<pre class="literal-block">
{age,integer(),{initial,18},
 &quot;stores the current age of this creature&quot;}
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently, these information are only of use for the developer (i.e. for documentation purpose). No check is made about whether they are used, whether no other attributes are used, whether the type is meaningful and indeed enforced, the default initial value is not set, etc. Some of these information might be handled by future WOOPER versions.</p>
</div>
<p>Shorter attribute declarations can also used, then with less than the 4 aforementioned pieces of information mentioned:</p>
<ul class="simple">
<li>only 3 of them: <tt class="docutils literal">{Name,Type,Description}</tt> (implying: qualifier is <tt class="docutils literal">none</tt>)</li>
<li>only 2 of them: <tt class="docutils literal">{Name,Description}</tt> (implying: type is <tt class="docutils literal">any()</tt>, qualifier is <tt class="docutils literal">none</tt>)</li>
<li>only 1 of them: <tt class="docutils literal">Name</tt> (implying: type is <tt class="docutils literal">any()</tt>, qualifier is <tt class="docutils literal">none</tt>, no description)</li>
</ul>
<p>(and, of course, any number of attributes may not be specified at all)</p>
<p>Finally, a full example of the declaration of class attributes can be:</p>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">define</span><span class="p">(</span><span class="no">class_attributes</span><span class="p">,[</span>
          <span class="n">name</span><span class="p">,</span>
          <span class="p">{</span><span class="n">age</span><span class="p">,</span><span class="n">integer</span><span class="p">(),{</span><span class="n">initial</span><span class="p">,</span><span class="mi">18</span><span class="p">},</span>
               <span class="s">&quot;stores the current age of this creature&quot;</span><span class="p">},</span>
          <span class="n">birth_date</span><span class="p">,</span>
          <span class="p">{</span><span class="n">weight</span><span class="p">,</span><span class="s">&quot;total weight measured&quot;</span><span class="p">}]).</span>
</pre>
</div>
<div class="section" id="storing-them">
<h5>Storing them</h5>
<p>The attributes of a class instance can be seen as a series of key/value pairs stored in an associative table, whose type has been chosen for its look-up/update efficiency and scalability.</p>
<p>This is a dynamic datastructure, allowing attributes to be added, removed or modified at any time (the safer conventions that apply will be discussed later).</p>
<p>This table, among other elements, is itself stored in the overall instance state, i.e. in the variable designated by <tt class="docutils literal">State</tt> specified at the beginning of each member method (and constructors, and destructor), on which the process corresponding to active instances is looping, and whose type is <tt class="docutils literal">wooper:state()</tt>.</p>
<p>We strongly advise to suffix the name of the various state variables used with <tt class="docutils literal">State</tt> (ex: <tt class="docutils literal">RegisteredState</tt>, <tt class="docutils literal">FinalState</tt>, etc.).</p>
<p></p>
</div>
</div>
</div>
<div class="section" id="managing-the-state-of-an-instance">
<h3><a class="toc-backref" href="#id190">Managing the State of an Instance</a></h3>
<p>A set of WOOPER-provided functions allows to operate on these state variables, notably to read and write the attributes that they contain.</p>
<p>As seen in the various examples, method implementations will access (read/write) attributes stored in the instance state, whose original version (i.e. the state of the instance at the method beginning) is always specified as their first parameter, conventionally named <tt class="docutils literal">State</tt>.</p>
<p>This current state can be then modified in the method, and a final state (usually an updated version of the initial one) will be returned locally to WOOPER, thanks to a method terminator.</p>
<p>Then the code (automatically instantiated by the WOOPER header in the class implementation) will loop again for this instance with this updated state, waiting for the next method call, which will possibly change again the state (and trigger side-effects), and so on.</p>
<p>One may refer to <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/blob/master/include/wooper.hrl">wooper.hrl</a> for the actual definition of most of these WOOPER constructs.</p>
<div class="section" id="modifying-state">
<h4>Modifying State</h4>
<div class="section" id="the-setattribute-3-function">
<h5>The <tt class="docutils literal">setAttribute/3</tt> function</h5>
<p>Setting an attribute (creating <a class="footnote-reference" href="#id30" id="id29">[13]</a> and/or modifying it) should be done with the <tt class="docutils literal">setAttribute/3</tt> function:</p>
<pre class="code erlang literal-block">
<span class="nv">NewState</span> <span class="o">=</span> <span class="n">setAttribute</span><span class="p">(</span><span class="nv">AState</span><span class="p">,</span><span class="nv">AttributeName</span><span class="p">,</span><span class="nv">NewAttributeValue</span><span class="p">)</span>
</pre>
<table class="docutils footnote" frame="void" id="id30" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id29">[13]</a></td><td>Attribute creation should (by convention) only be done in constructors (not in methods).</td></tr>
</tbody>
</table>
<p>For example, <tt class="docutils literal">AgeState = setAttribute(State,age,3)</tt> will return a new state, bound to <tt class="docutils literal">AgeState</tt>, exact copy of <tt class="docutils literal">State</tt> (notably with all the attribute pairs equal) but for the <tt class="docutils literal">age</tt> attribute, whose value will be set to 3.</p>
<p>Therefore, during the execution of a method, any number of states can be defined (ex: <tt class="docutils literal">State</tt>, <tt class="docutils literal">InitialisedState</tt>, <tt class="docutils literal">AgeState</tt>, etc.) before all, but the one that is returned, are garbage-collected.</p>
<p>Note that the corresponding state duplication remains efficient both in terms of processing and memory, as the different underlying state structures (ex: <tt class="docutils literal">State</tt> and <tt class="docutils literal">AgeState</tt>) actually <strong>share</strong> all their terms except the one modified - thanks to the immutability of Erlang variables that allows to reference rather than copy, be these datastructures tables, records, or anything else.</p>
<p>In various cases, notably in constructors, one needs to define a series of attributes in a row, but chaining <tt class="docutils literal">setAttribute/3</tt> calls with intermediate states that have each to be named is not really convenient.</p>
<p>A better solution is to use the <tt class="docutils literal">setAttributes/2</tt> function (note the plural) to set a list of attribute name/attribute value pairs in a row.</p>
<p>For example:</p>
<pre class="code erlang literal-block">
<span class="nv">ConstructedState</span> <span class="o">=</span> <span class="n">setAttributes</span><span class="p">(</span><span class="nv">MyState</span><span class="p">,</span>
         <span class="p">[{</span><span class="n">age</span><span class="p">,</span><span class="mi">3</span><span class="p">},{</span><span class="n">whisker_color</span><span class="p">,</span><span class="n">white</span><span class="p">}])</span>
</pre>
<p>will return a new state, exact copy of <tt class="docutils literal">MyState</tt> but for the listed attributes, set to their respective specified value.</p>
</div>
<div class="section" id="the-swapinattribute-3-function">
<h5>The <tt class="docutils literal">swapInAttribute/3</tt> function</h5>
<p>This function allows to swap, in the specified state, the current value of the specified attribute with the specified value; for example:</p>
<pre class="code erlang literal-block">
<span class="p">{</span><span class="nv">NewState</span><span class="p">,</span><span class="nv">PastColor</span><span class="p">}</span> <span class="o">=</span> <span class="n">swapInAttribute</span><span class="p">(</span><span class="nv">AState</span><span class="p">,</span><span class="n">fur_color</span><span class="p">,_</span><span class="nv">NewValue</span><span class="o">=</span><span class="n">black</span><span class="p">)</span>
</pre>
</div>
<div class="section" id="the-removeattribute-2-function">
<h5>The <tt class="docutils literal">removeAttribute/2</tt> function</h5>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <tt class="docutils literal">removeAttribute/2</tt> function is now deprecated and should not be used anymore.</p>
</div>
<p>This function was used in order to fully remove an attribute entry (i.e. the whole key/value pair).</p>
<p>This function is deprecated now, as we prefer defining all attributes once for all, at construction time, and never adding or removing them dynamically: the good practice is just to operate on their value, which can by example be set to <tt class="docutils literal">undefined</tt>, without having to deal with the fact that, depending on the context, a given attribute may or may not be defined (kids: don't do that).</p>
<p>For example <tt class="docutils literal">NewState = removeAttribute(State,an_attribute)</tt> could be used, for a resulting state having no key corresponding to <tt class="docutils literal">an_attribute</tt>.</p>
<p>Neither the <tt class="docutils literal">setAttribute*</tt> variants nor <tt class="docutils literal">removeAttribute/2</tt> can fail, regardless of the attribute being already existing or not.</p>
</div>
</div>
<div class="section" id="reading-state">
<h4>Reading State</h4>
<div class="section" id="the-hasattribute-2-function">
<h5>The <tt class="docutils literal">hasAttribute/2</tt> function</h5>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <tt class="docutils literal">hasAttribute/2</tt> function is now deprecated and should not be used anymore, as no attribute is expected to be removed anymore either.</p>
</div>
<p>To test whether an attribute is defined, one could use the <tt class="docutils literal">hasAttribute/2</tt> function: <tt class="docutils literal">hasAttribute(AState,AttributeName)</tt>, which returns either <tt class="docutils literal">true</tt> or <tt class="docutils literal">false</tt>, and cannot fail.</p>
<p>For example, <tt class="docutils literal">true = hasAttribute(State,whisker_color)</tt> matches if and only if the attribute <tt class="docutils literal">whisker_color</tt> is defined in state <tt class="docutils literal">State</tt>.</p>
<p>Note that generally, as already mentioned, it is a bad practice to define attributes outside of the constructor of an instance, as the availability of an attribute could then depend on the actual state, which is an eventuality generally difficult to manage reliably.</p>
<p>A better approach is instead to define all possible attributes directly from the constructor. They would then be assigned to their initial value and, if none is appropriate, they should be set to the atom <tt class="docutils literal">undefined</tt> (instead of not being defined at all).</p>
</div>
<div class="section" id="the-getattribute-2-function">
<h5>The <tt class="docutils literal">getAttribute/2</tt> function</h5>
<p>Getting the value of an attribute is to be done with the <tt class="docutils literal">getAttribute/2</tt> function:</p>
<pre class="code erlang literal-block">
<span class="nv">AttributeValue</span> <span class="o">=</span> <span class="n">getAttribute</span><span class="p">(</span><span class="nv">AState</span><span class="p">,</span><span class="nv">AttributeName</span><span class="p">)</span>
</pre>
<p>For example, <tt class="docutils literal">MyColor = getAttribute(State,whisker_color)</tt> returns the value of the attribute <tt class="docutils literal">whisker_color</tt> from state <tt class="docutils literal">State</tt>.</p>
<p>The requested attribute may not exist in the specified state. In this case, a runtime error is issued.</p>
<p>Requesting a non-existing attribute triggers a bad match. In the previous example, should the attribute <tt class="docutils literal">whisker_color</tt> not have been defined, <tt class="docutils literal">getAttribute/2</tt> would return:</p>
<pre class="code erlang literal-block">
<span class="p">{</span><span class="n">key_not_found</span><span class="p">,</span><span class="n">whisker_color</span><span class="p">}</span>
</pre>
</div>
<div class="section" id="the-getattr-2-macro">
<h5>The <tt class="docutils literal">getAttr/2</tt> macro</h5>
<p>Quite often, when having to retrieve the value of an attribute from a state variable, that variable will be named <tt class="docutils literal">State</tt>, notably when using directly the original state specified in the method declaration.</p>
<p>Indeed, when a method needs a specific value, generally either this value was already available in the state it began with (then we can read it from <tt class="docutils literal">State</tt>), or is computed in the course of the method, in which case that value is most often already bound to a variable, which can then be re-used directly rather than be fetched from a state.</p>
<p>In this case, the <tt class="docutils literal">getAttr/2</tt> macro can be used: <tt class="docutils literal"><span class="pre">?getAttr(whisker_color)</span></tt> expands (literally) as <tt class="docutils literal">getAttribute(State,whisker_color)</tt>, and is a tad shorter.</p>
<p>This is implemented as a macro so that the user remains aware that an implicit variable named <tt class="docutils literal">State</tt> is then used.</p>
<p>The less usual cases where a value must be read from a state variable that is <em>not</em> the initial <tt class="docutils literal">State</tt> one occur mostly when wanting to read a value from the updated state returned by a <tt class="docutils literal">execute*</tt> function call. In this case the <tt class="docutils literal">getAttribute/2</tt> function should be used.</p>
</div>
</div>
<div class="section" id="read-modify-write-operations">
<h4>Read-Modify-Write Operations</h4>
<p>Some additional helper functions are provided for the most common operations, to keep the syntax as lightweight as possible.</p>
<div class="section" id="the-addtoattribute-3-function">
<h5>The <tt class="docutils literal">addToAttribute/3</tt> function</h5>
<p>When having a numerical attribute, <tt class="docutils literal">addToAttribute/3</tt> adds the specified number to the attribute.</p>
<p>To be used like in:</p>
<pre class="code erlang literal-block">
<span class="nv">NewState</span> <span class="o">=</span> <span class="n">addToAttribute</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">AttributeName</span><span class="p">,</span><span class="nv">Value</span><span class="p">)</span>
</pre>
<p>For example:</p>
<pre class="code erlang literal-block">
<span class="nv">MyState</span> <span class="o">=</span> <span class="n">addToAttribute</span><span class="p">(</span><span class="nv">FirstState</span><span class="p">,</span><span class="n">a_numerical_attribute</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
</pre>
<p>In <tt class="docutils literal">MyState</tt>, the value of attribute <tt class="docutils literal">a_numerical_attribute</tt> is increased of 6, compared to the one in <tt class="docutils literal">FirstState</tt>.</p>
<p>Calling <tt class="docutils literal">addToAttribute/3</tt> on a non-existing attribute will trigger a runtime error (<tt class="docutils literal">{key_not_found,AttributeName}</tt>).</p>
<p>If the attribute exists, but no addition can be performed on it (i.e. if it is meaningless for the type of the current value), a <tt class="docutils literal">badarith</tt> runtime error will be issued.</p>
</div>
<div class="section" id="the-subtractfromattribute-3-function">
<h5>The <tt class="docutils literal">subtractFromAttribute/3</tt> function</h5>
<p>When having a numerical attribute, <tt class="docutils literal">subtractFromAttribute/3</tt> subtracts the specified number from the attribute.</p>
<p>To be used like in:</p>
<pre class="code erlang literal-block">
<span class="nv">NewState</span> <span class="o">=</span> <span class="n">subtractFromAttribute</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">AttributeName</span><span class="p">,</span><span class="nv">Value</span><span class="p">)</span>
</pre>
<p>For example:</p>
<pre class="code erlang literal-block">
<span class="nv">MyState</span> <span class="o">=</span> <span class="n">subtractFromAttribute</span><span class="p">(</span><span class="nv">FirstState</span><span class="p">,</span><span class="n">a_numerical_attribute</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span>
</pre>
<p>In <tt class="docutils literal">MyState</tt>, the value of attribute <tt class="docutils literal">a_numerical_attribute</tt> is decreased of 7, compared to the one in <tt class="docutils literal">FirstState</tt>.</p>
<p>Calling <tt class="docutils literal">subtractFromAttribute/3</tt> on a non-existing attribute will trigger a runtime error (<tt class="docutils literal">{key_not_found,AttributeName}</tt>).
If the attribute exists, but no subtraction can be performed on it (meaningless for the type of the current value), a <tt class="docutils literal">badarith</tt> runtime error will be issued.</p>
</div>
<div class="section" id="the-toggleattribute-2-function">
<h5>The <tt class="docutils literal">toggleAttribute/2</tt> function</h5>
<p>Flips the value of the specified (supposedly boolean) attribute: when having a boolean attribute, whose value is either <tt class="docutils literal">true</tt> or <tt class="docutils literal">false</tt>, sets the opposite logical value to the current one.</p>
<p>To be used like in:</p>
<pre class="code erlang literal-block">
<span class="nv">NewState</span> <span class="o">=</span> <span class="n">toggleAttribute</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">BooleanAttributeName</span><span class="p">)</span>
</pre>
<p>For example:</p>
<pre class="code erlang literal-block">
<span class="nv">NewState</span> <span class="o">=</span> <span class="n">toggleAttribute</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="n">a_boolean_attribute</span><span class="p">)</span>
</pre>
<p>Calling <tt class="docutils literal">toggleAttribute/2</tt> on a non-existing attribute will trigger a runtime error (<tt class="docutils literal">{key_not_found,AttributeName}</tt>). If the attribute exists, but has not a boolean value, a <tt class="docutils literal">badarith</tt> runtime error will be issued.</p>
</div>
<div class="section" id="the-appendtoattribute-3-function">
<h5>The <tt class="docutils literal">appendToAttribute/3</tt> function</h5>
<p>The corresponding signature is:</p>
<pre class="literal-block">
NewState = appendToAttribute(State,AttributeName,Element)
</pre>
<p>When having a list attribute, appends specified element to the attribute list, in first position.</p>
<p>For example, if <tt class="docutils literal">a_list_attribute</tt> was already set to <tt class="docutils literal">[see_you,goodbye]</tt> in <tt class="docutils literal">State</tt>, then after <tt class="docutils literal">NewState = appendToAttribute(State,a_list_attribute,hello)</tt>, the <tt class="docutils literal">a_list_attribute</tt> attribute defined in <tt class="docutils literal">NewState</tt> will be equal to <tt class="docutils literal">[hello,see_you,goodbye]</tt>.</p>
<p>Calling <tt class="docutils literal">appendToAttribute/3</tt> on a non-existing attribute will trigger a a <tt class="docutils literal">badmatch</tt> runtime error. If the attribute exists, but is not a list, an ill-formed list will be created (ex: <tt class="docutils literal">[8|false]</tt> when appending 8 to <tt class="docutils literal">false</tt>, which is not a list).</p>
</div>
<div class="section" id="the-deletefromattribute-3-function">
<h5>The <tt class="docutils literal">deleteFromAttribute/3</tt> function</h5>
<p>The corresponding signature is:</p>
<pre class="literal-block">
NewState = deleteFromAttribute(State,AttributeName,
                               Element)
</pre>
<p>When having a list attribute, deletes first match of specified element from the attribute list.</p>
<p>For example: <tt class="docutils literal">NewState = deleteFromAttribute(State,a_list_attribute,hello)</tt>, with the value corresponding to the <tt class="docutils literal">a_list_attribute</tt> attribute in <tt class="docutils literal">State</tt> variable being <tt class="docutils literal">[goodbye,hello,cheers,hello,see_you]</tt> should return a state whose <tt class="docutils literal">a_list_attribute</tt> attribute would be equal to <tt class="docutils literal">[goodbye,cheers,hello,see_you]</tt>, all other attributes being unchanged.</p>
<p>If no element in the list matches the specified one, no error will be triggered and the list will be kept as is.</p>
<p>Calling <tt class="docutils literal">deleteFromAttribute/3</tt> on a non-existing attribute will trigger a <tt class="docutils literal">badmatch</tt> runtime error. If the attribute exists, but is not a list, a <tt class="docutils literal">function_clause</tt> runtime error will be issued.</p>
</div>
<div class="section" id="the-popfromattribute-2-function">
<h5>The <tt class="docutils literal">popFromAttribute/2</tt> function</h5>
<p>The corresponding signature is <tt class="docutils literal">{NewState,Head} = popFromAttribute(State,AttributeName)</tt>: when having an attribute of type list, this function removes the head from the list and returns a pair made of the updated state (same state except that the corresponding list attribute has lost its head, it is equal to the list tail now) and of that head.</p>
<p>For example: <tt class="docutils literal">{NewState,Head} = popFromAttribute(State,a_list_attribute)</tt>. If the value of the attribute <tt class="docutils literal">a_list_attribute</tt> was <tt class="docutils literal">[5,8,3]</tt>, its new value (in <tt class="docutils literal">NewState</tt>) will be <tt class="docutils literal">[8,3]</tt> and <tt class="docutils literal">Head</tt> will be bound to <tt class="docutils literal">5</tt>.</p>
</div>
<div class="section" id="the-addkeyvaluetoattribute-4-function">
<h5>The <tt class="docutils literal">addKeyValueToAttribute/4</tt> function</h5>
<p>The corresponding signature is <tt class="docutils literal">NewState = addKeyValueToAttribute(State,AttributeName,Key,Value)</tt>: when having an attribute whose value is a table (a Myriad <tt class="docutils literal">table:table()</tt> pseudo-type), adds specified key/value pair to that table attribute.</p>
<p>For example: <tt class="docutils literal">TableState = <span class="pre">setAttribute(State,my_table,table:new()),</span> NewState = addKeyValueToAttribute(TableState,my_table,my_key,my_value)</tt> will result in having the attribute <tt class="docutils literal">my_table</tt> in state variable <tt class="docutils literal">TableState</tt> being a table with only one entry, whose key is <tt class="docutils literal">my_key</tt> and whose value is <tt class="docutils literal">my_value</tt>.</p>
<p></p>
</div>
</div>
</div>
</div>
<div class="section" id="multiple-inheritance-polymorphism">
<h2><a class="toc-backref" href="#id191">Multiple Inheritance &amp; Polymorphism</a></h2>
<div class="section" id="the-general-case">
<h3><a class="toc-backref" href="#id192">The General Case</a></h3>
<p>Both multiple inheritance and polymorphism are automatically managed by WOOPER: even if our cat class does not define a <tt class="docutils literal">getAge/1</tt> request, it can nevertheless readily be called on a cat instance, as it is inherited from its mother classes (here from <tt class="docutils literal">class_Creature</tt>, an indirect mother class).</p>
<p>Therefore all creature instances can be handled the same, regardless of their actual classes:</p>
<pre class="code erlang literal-block">
<span class="c">% Inherited methods work exactly the same as methods defined
% directly in the class:
</span><span class="nv">MyCat</span> <span class="o">!</span> <span class="p">{</span><span class="n">getAge</span><span class="p">,[],</span><span class="n">self</span><span class="p">()},</span>
<span class="k">receive</span>
  <span class="p">{</span><span class="n">wooper_result</span><span class="p">,</span><span class="nv">Age</span><span class="p">}</span> <span class="o">-&gt;</span>
    <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span> <span class="s">&quot;This is a </span><span class="si">~B</span><span class="s"> year old cat.&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nv">Age</span><span class="p">]</span> <span class="p">)</span>
<span class="k">end</span><span class="p">,</span>

<span class="c">% Polymorphism is immediate:
% (class_Platypus inheriting too from class_Mammal,
% hence from class_Creature).
</span><span class="nv">MyPetList</span> <span class="o">=</span> <span class="p">[</span><span class="nv">MyCat</span><span class="p">,</span><span class="nv">MyPlatypus</span><span class="p">],</span>
<span class="p">[</span> <span class="k">begin</span>
    <span class="nv">PetPid</span> <span class="o">!</span> <span class="p">{</span><span class="n">getAge</span><span class="p">,[],</span><span class="n">self</span><span class="p">()},</span>
    <span class="k">receive</span>
      <span class="p">{</span><span class="n">wooper_result</span><span class="p">,</span><span class="nv">Age</span><span class="p">}</span> <span class="o">-&gt;</span>
        <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;This is a </span><span class="si">~B</span><span class="s"> year old creature.&quot;</span><span class="p">,[</span><span class="nv">Age</span><span class="p">])</span>
    <span class="k">end</span>
  <span class="k">end</span> <span class="p">||</span> <span class="nv">PetPid</span> <span class="o">&lt;-</span> <span class="nv">MyPetList</span> <span class="p">].</span>
</pre>
<p>Running this code should output something like:</p>
<pre class="literal-block">
This is a 4 year old cat.
This is a 4 year old creature.
This is a 9 year old creature.
</pre>
<p>The point here is that the implementer does not have to know what are the actual classes of the instances that are interacted with, provided that they share a common ancestor; polymorphism allows to handle them transparently.</p>
</div>
<div class="section" id="the-special-case-of-diamond-shaped-inheritance">
<h3><a class="toc-backref" href="#id193">The Special Case of Diamond-Shaped Inheritance</a></h3>
<p>In the case of a <a class="reference external" href="http://en.wikipedia.org/wiki/Diamond_problem">diamond-shaped inheritance</a>, as the method table is constructed in the order specified in the declaration of the superclasses, like in:</p>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">define</span><span class="p">(</span><span class="no">superclasses</span><span class="p">,[</span><span class="n">class_X</span><span class="p">,</span><span class="n">class_Y</span><span class="p">,...]).</span>
</pre>
<p>and as child classes override mother ones, when an incoming WOOPER message arrives the selected <strong>method</strong> should be the one defined in the last inheritance branch of the last child (if any), otherwise the one defined in the next to last branch of the last child, etc.</p>
<p>Generally speaking, overriding in that case the relevant methods that were initially defined in the child class at the base of the diamond, in order that they perform explicitly a direct call to the wanted module, is by far the most reasonable solution, in terms of clarity and maintainability, compared to trying to guess which version of the method in the inheritance graph should be called.</p>
<p>Regarding the instance state, the <strong>attributes</strong> are set by the constructors, and the developer can select in which order the direct mother classes should be constructed.</p>
<p>However, in such a diamond-shaped inheritance scheme, the constructor of the class that sits at the top of a given diamond will be called more than once.</p>
<p>Any side-effect that it would induce would then occur as many times as this class is a common ancestor of the actual class; it may be advisable to create idempotent constructors in that case.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">More generally speaking, diamond-shaped inheritance is seldom necessary. More often than not, it is the consequence of a less-than-ideal OOP design, and should be avoided anyway.</p>
</div>
<p></p>
</div>
</div>
<div class="section" id="life-cycle">
<h2><a class="toc-backref" href="#id194">Life-Cycle</a></h2>
<p>Basically, creation and destruction of instances are managed respectively thanks to the <tt class="docutils literal">new</tt>/<tt class="docutils literal">new_link</tt> and the <tt class="docutils literal">delete</tt> operators (all these operators are WOOPER-reserved function names, for all arities, and are automatically generated), like in:</p>
<pre class="code erlang literal-block">
<span class="nv">MyCat</span> <span class="o">=</span> <span class="nn">class_Cat</span><span class="p">:</span><span class="nf">new</span><span class="p">(</span><span class="nv">Age</span><span class="p">,</span><span class="nv">Gender</span><span class="p">,</span><span class="nv">FurColor</span><span class="p">,</span><span class="nv">WhiskerColor</span><span class="p">),</span>
<span class="nv">MyCat</span> <span class="o">!</span> <span class="n">delete</span><span class="p">.</span>
</pre>
<div class="section" id="instance-creation-new-new-link-and-construct">
<h3><a class="toc-backref" href="#id195">Instance Creation: <tt class="docutils literal">new</tt>/<tt class="docutils literal">new_link</tt> and <tt class="docutils literal">construct</tt></a></h3>
<div class="section" id="role-of-a-new-construct-pair">
<h4>Role of a  <tt class="docutils literal">new</tt> /<tt class="docutils literal">construct</tt> Pair</h4>
<p>Whereas the purpose of the <tt class="docutils literal">new</tt> / <tt class="docutils literal">new_link</tt> operators is to <em>create</em> a working (active) instance on the user's behalf, the role of <tt class="docutils literal">construct</tt> is to <em>initialise</em> an instance of that class (regardless of how it was created, i.e. of which <tt class="docutils literal">new</tt> variation was triggered), while being able to be chained for inheritance, as explained later.</p>
<p>Such an initialisation is of course part of the instance creation: all calls to any of the <tt class="docutils literal">new</tt> operators result in an underlying call to the corresponding constructor (<tt class="docutils literal">construct</tt> operator).</p>
<p>For example, both creations stemming from <tt class="docutils literal">MyCat = class_Cat:new(A,B,C,D)</tt> and <tt class="docutils literal">MyCat = class_Cat:new_link(A,B,C,D)</tt> will rely on <tt class="docutils literal">class_Cat:construct/5</tt> to set up a proper initial state for the <tt class="docutils literal">MyCat</tt> instance.</p>
<p>The same <tt class="docutils literal">class_Cat:construct(State,A,B,C,D)</tt> will be called for all creation cases (one may note that, because of its first parameter, which accounts for the WOOPER-provided initial <tt class="docutils literal">State</tt> parameter, the arity of <tt class="docutils literal">construct</tt> is equal to the one of <tt class="docutils literal">new</tt> / <tt class="docutils literal">new_link</tt> plus one).</p>
<p>The <tt class="docutils literal">new_link</tt> operator behaves exactly as the <tt class="docutils literal">new</tt> operator, except that it creates an instance that is Erlang-linked with the process that called that operator, exactly like <tt class="docutils literal">spawn_link</tt> behaves compared to <tt class="docutils literal">spawn</tt> <a class="footnote-reference" href="#id32" id="id31">[14]</a>.</p>
<table class="docutils footnote" frame="void" id="id32" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id31">[14]</a></td><td>For example it induces no race condition between linking and termination in the case of a very short-lived spawned process.</td></tr>
</tbody>
</table>
<p>The <tt class="docutils literal">new</tt> and <tt class="docutils literal">new_link</tt> operators are automatically defined by WOOPER (thanks to a relevant parse transform), but they rely on their corresponding, class-specific, user-defined <tt class="docutils literal">construct</tt> operator (only WOOPER is expected to make use of it). More precisely, for each of the <tt class="docutils literal">construct/N+1</tt> operator defined by the class developer, WOOPER creates a full set of corresponding <tt class="docutils literal">new</tt> variations, including <tt class="docutils literal">new/N</tt> and <tt class="docutils literal">new_link/N</tt>.</p>
<p>At least one <tt class="docutils literal">construct</tt> operator must be defined by the class developer (otherwise WOOPER will raise a compile-time error), knowing that any number of them can then be defined, each with its own arity (ex: <tt class="docutils literal">construct/1, construct/2, construct/3</tt>, etc.), and each with possibly multiple clauses that will be, as usual, selected at runtime based on pattern-matching.</p>
<p><tt class="docutils literal">construct</tt> operators may not be exported explicitly by the class developer, as WOOPER will automatically take care of that if necessary.</p>
<p>For example:</p>
<pre class="code erlang literal-block">
<span class="c">% If having defined class_Dog:construct/{1,3}:
</span><span class="nv">MyFirstDog</span>  <span class="o">=</span> <span class="nn">class_Dog</span><span class="p">:</span><span class="nf">new</span><span class="p">(),</span>
<span class="nv">MySecondDog</span> <span class="o">=</span> <span class="nn">class_Dog</span><span class="p">:</span><span class="nf">new</span><span class="p">(_</span><span class="nv">Weight</span><span class="o">=</span><span class="mi">4</span><span class="p">.</span><span class="mi">4</span><span class="p">,_</span><span class="nv">Colors</span><span class="o">=</span><span class="p">[</span><span class="n">sand</span><span class="p">,</span><span class="n">white</span><span class="p">]).</span>
</pre>
</div>
<div class="section" id="the-various-ways-of-creating-an-instance">
<h4>The Various Ways of Creating an Instance</h4>
<p>As shown with the <tt class="docutils literal">new_link</tt> operator, even for a given set of construction parameters, many variations of <tt class="docutils literal">new</tt> can be of use: linked or not, synchronous or not, with a time-out or not, on current node or on a user-specified one, etc.</p>
<p>For a class whose instances can be constructed from <tt class="docutils literal">N</tt> actual parameters (hence having a <tt class="docutils literal">construct/N+1</tt> defined), the following new operator variations, detailed in the next section, are built-in:</p>
<ul class="simple">
<li>if an <strong>active</strong> instance is to be created on the <strong>local</strong> node:<ul>
<li>non-blocking creation: <tt class="docutils literal">new/N</tt> and <tt class="docutils literal">new_link/N</tt></li>
<li>blocking creation: <tt class="docutils literal">synchronous_new/N</tt> and <tt class="docutils literal">synchronous_new_link/N</tt></li>
<li>blocking creation with time-out: <tt class="docutils literal">synchronous_timed_new/N</tt> and <tt class="docutils literal">synchronous_timed_new_link/N</tt></li>
</ul>
</li>
<li>if an <strong>active</strong> instance is to be created on any specified <strong>remote</strong> node:<ul>
<li>non-blocking creation: <tt class="docutils literal">remote_new/N+1</tt> and <tt class="docutils literal">remote_new_link/N+1</tt></li>
<li>blocking creation: <tt class="docutils literal">remote_synchronous_new/N+1</tt> and <tt class="docutils literal">remote_synchronous_new_link/N+1</tt></li>
<li>blocking creation with time-out: <tt class="docutils literal">remote_synchronous_timed_new/N+1</tt> and <tt class="docutils literal">remote_synchronous_timed_new_link/N+1</tt></li>
</ul>
</li>
<li>if a <strong>passive</strong> instance is to be created by the current <strong>process</strong>: <tt class="docutils literal">new_passive/N</tt></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All <tt class="docutils literal">remote_*</tt> variations require one additional parameter (that shall be specified first), since the remote node on which the instance should be created has of course to be specified.</p>
</div>
<p>All supported <tt class="docutils literal">new</tt> variations are detailed below.</p>
<div class="section" id="asynchronous-new">
<h5>Asynchronous new</h5>
<p>This corresponds to the plain <tt class="docutils literal">new</tt>, <tt class="docutils literal">new_link</tt> operators discussed earlier, relying internally on the usual <tt class="docutils literal">spawn*</tt> primitives . These basic operators are <strong>asynchronous</strong> (non-blocking): they trigger the creation of a new instance, and return immediately, without waiting for it to complete and succeed, and the execution of the calling process continues while (hopefully, i.e. with no guarantee - the corresponding process may immediately crash) the instance is being created and executed.</p>
</div>
<div class="section" id="synchronous-new">
<h5>Synchronous new</h5>
<p>As mentioned, with the previous asynchronous forms, the caller has no way of knowing when the spawned instance is up and running (if it ever happens), unless triggering a later request on it.</p>
<p>Thus two counterpart operators, <tt class="docutils literal">synchronous_new/synchronous_new_link</tt> are also automatically generated.</p>
<p>They behave like <tt class="docutils literal">new/new_link</tt> except that they will return only when (and if) the created instance is up and running: they are blocking, synchronous, operators.</p>
<p>For example, once (if) <tt class="docutils literal">MyMammal = <span class="pre">class_Mammal:synchronous_new(...)</span></tt> returns, one knows that the <tt class="docutils literal">MyMammal</tt> instance is fully created and waiting for incoming messages.</p>
<p>The implementation of these synchronous operations relies on a message (precisely: <tt class="docutils literal">{spawn_successful,InstancePid}</tt>) being automatically sent by the created instance to the WOOPER code on the caller side, so that the <tt class="docutils literal">synchronous_new</tt> operator will return to the user code only once successfully constructed and ready to handle messages.</p>
</div>
<div class="section" id="timed-synchronous-new">
<h5>Timed Synchronous new</h5>
<p>Note that, should the instance creation fail, the caller of a synchronous new would then be blocked for ever, as the awaited message would actually never be sent by the failed new instance. In some cases a time-out may be useful, so that the caller may be unblocked and may react appropriately.</p>
<p>This is why the <tt class="docutils literal">synchronous_timed_new*</tt> operators have been introduced: if the caller-side time-out <a class="footnote-reference" href="#id34" id="id33">[15]</a> expires while waiting for the created instance to answer, then they will throw an appropriate exception:</p>
<ul class="simple">
<li>either <tt class="docutils literal">{synchronous_time_out,Classname}</tt> if it was a node-local creation (where <tt class="docutils literal">Classname</tt> is the name of the class corresponding to the instance to create; ex: <tt class="docutils literal">class_Cat</tt>)</li>
<li>or <tt class="docutils literal">{remote_synchronous_time_out,Node,Classname}</tt>, where <tt class="docutils literal">Node</tt> is the name of the node (as an atom) on which the instance was to be created</li>
</ul>
<table class="docutils footnote" frame="void" id="id34" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id33">[15]</a></td><td>Depending on whether or not the class to instantiate was compiled in debug mode, the time-out is to last by default for, respectively, 5 seconds (shorter, to ease debugging) or for 30 minutes (longer, to favor robustness).</td></tr>
</tbody>
</table>
<p>Then the caller may or may not catch this exception.</p>
</div>
<div class="section" id="remote-new">
<h5>Remote new</h5>
<p>Exactly like a process might be spawned on another Erlang node, a WOOPER (active) instance can be created on any user-specified available Erlang node.</p>
<p>To do so, the <tt class="docutils literal">remote_*new*</tt> variations shall be used. They behave exactly like their local counterparts, except that they take an additional information, as first parameter: the node on which the specified instance must be created.</p>
<p>For example:</p>
<pre class="code erlang literal-block">
<span class="nv">MyCat</span> <span class="o">=</span> <span class="nn">class_Cat</span><span class="p">:</span><span class="nf">remote_new</span><span class="p">(</span><span class="nv">TargetNode</span><span class="p">,</span> <span class="nv">Age</span><span class="p">,</span> <span class="nv">Gender</span><span class="p">,</span>
                             <span class="nv">FurColor</span><span class="p">,</span> <span class="nv">WhiskerColor</span><span class="p">).</span>
</pre>
<p>Of course:</p>
<ul class="simple">
<li>the remote node must be already existing</li>
<li>the current node must be able to connect to it (shared cookie)</li>
<li>all modules that the instance will make use of must be available on the remote node, including the ones of all relevant classes (i.e. the class of the instance but also its whole class hierarchy)</li>
</ul>
<p>All variations of the <tt class="docutils literal">new</tt> operator are always defined automatically by WOOPER: nothing special is to be done for them, provided of course that a corresponding constructor has been defined indeed.</p>
</div>
</div>
<div class="section" id="some-examples-of-instance-creation">
<h4>Some Examples of Instance Creation</h4>
<p>Knowing that a cat can be created here out of four parameters (<tt class="docutils literal">Age</tt>, <tt class="docutils literal">Gender</tt>, <tt class="docutils literal">FurColor</tt>, <tt class="docutils literal">WhiskerColor</tt>), various cat (active) instances could be created thanks to:</p>
<pre class="code erlang literal-block">
<span class="c">% Local asynchronous creation:
</span><span class="nv">MyFirstCat</span> <span class="o">=</span> <span class="nn">class_Cat</span><span class="p">:</span><span class="nf">new</span><span class="p">(_</span><span class="nv">Age</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">male</span><span class="p">,</span><span class="n">brown</span><span class="p">,</span><span class="n">white</span><span class="p">),</span>

<span class="c">% The same, but a crash of this cat will crash the current
% process too:
</span><span class="nv">MySecondCat</span> <span class="o">=</span> <span class="nn">class_Cat</span><span class="p">:</span><span class="nf">new_link</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">female</span><span class="p">,</span><span class="n">black</span><span class="p">,</span><span class="n">white</span><span class="p">),</span>

<span class="c">% This cat will be created on OtherNode, and the call will
% return only once it is up and running or once the creation
% failed. As moreover the cat instance is linked to the
% instance process, it may crash this calling process
% (unless it traps EXIT signals):
</span><span class="nv">MyThirdCat</span> <span class="o">=</span> <span class="nn">class_Cat</span><span class="p">:</span><span class="nf">remote_synchronous_timed_new_link</span><span class="p">(</span>
                               <span class="nv">OtherNode</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">male</span><span class="p">,</span><span class="n">grey</span><span class="p">,</span><span class="n">black</span><span class="p">),</span>
<span class="p">[...]</span>
</pre>
</div>
<div class="section" id="definition-of-the-construct-operator">
<h4>Definition of the <tt class="docutils literal">construct</tt> Operator</h4>
<p>Each class must define at least one <tt class="docutils literal">construct</tt> operator, whose role is to fully initialise, based on the specified construction parameters, the state of new instances in compliance with the class inheritance - regardless of the <tt class="docutils literal">new</tt> variation being used.</p>
<p>The type specification of a constructor relying on <tt class="docutils literal">N</tt> construction parameters (hence <tt class="docutils literal">construct/N+1</tt>) is:</p>
<pre class="literal-block">
-spec construct(wooper:state(),P1,P2,..,PN) -&gt; wooper:state().
</pre>
<p>In the context of class inheritance, the <tt class="docutils literal">construct</tt> operators are expected to be chained: they must be designed to be called by the ones of their child classes, and in turn they must call themselves the constructors of their direct mother classes, if any (should there be multiple direct mother classes, usually their constructors are to be called in the same order as their declaration order in the <tt class="docutils literal">superclasses</tt> define).</p>
<p>Hence they always take the current state of the instance being created as a starting base, and returns it once updated, first from the direct mother classes, then by this class itself.</p>
<p>For example, let's suppose <tt class="docutils literal">class_Cat</tt> inherits directly both from <tt class="docutils literal">class_Mammal</tt> and from <tt class="docutils literal">class_ViviparousBeing</tt>, has only one attribute (<tt class="docutils literal">whisker_color)</tt> of its own, and that a new cat is to be created out of four pieces of information:</p>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">define</span><span class="p">(</span><span class="no">superclasses</span><span class="p">,[</span><span class="n">class_Mammal</span><span class="p">,</span><span class="n">class_ViviparousBeing</span><span class="p">]).</span>

<span class="p">-</span><span class="ni">define</span><span class="p">(</span><span class="no">class_attributes</span><span class="p">,[</span><span class="n">whisker_color</span><span class="p">]).</span>

<span class="c">% Constructs a new Cat.
</span><span class="nf">construct</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">Age</span><span class="p">,</span><span class="nv">Gender</span><span class="p">,</span><span class="nv">FurColor</span><span class="p">,</span><span class="nv">WhiskerColor</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="c">% First the (chained) direct mother classes:
</span>  <span class="nv">MammalState</span> <span class="o">=</span> <span class="nn">class_Mammal</span><span class="p">:</span><span class="nf">construct</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">Age</span><span class="p">,</span><span class="nv">Gender</span><span class="p">,</span>
                                       <span class="nv">FurColor</span><span class="p">),</span>
  <span class="nv">ViviparousMammalState</span> <span class="o">=</span>
      <span class="nn">class_ViviparousBeing</span><span class="p">:</span><span class="nf">construct</span><span class="p">(</span><span class="nv">MammalState</span><span class="p">),</span>
  <span class="c">% Then the class-specific attributes:
</span>  <span class="n">setAttribute</span><span class="p">(</span><span class="nv">ViviparousMammalState</span><span class="p">,</span><span class="n">whisker_color</span><span class="p">,</span>
               <span class="nv">WhiskerColor</span><span class="p">).</span>
</pre>
<p>The fact that the <tt class="docutils literal">Mammal</tt> class itself inherits from the <tt class="docutils literal">Creature</tt> class does not have to appear here: it is to be managed directly by <tt class="docutils literal">class_Mammal:construct/4</tt> (at any given inheritance level, only direct mother classes must be taken into account).</p>
<p>One should ensure that, in constructors, the successive states are always built from the last updated one, unlike this case (where no mother class has been declared):</p>
<pre class="code erlang literal-block">
<span class="c">% WRONG, the age update is lost:
</span><span class="nf">construct</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">Age</span><span class="p">,</span><span class="nv">Gender</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="nv">AgeState</span> <span class="o">=</span> <span class="n">setAttribute</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="n">age</span><span class="p">,</span><span class="nv">Age</span><span class="p">),</span>
  <span class="c">% AgeState should be used here, not State:
</span>  <span class="n">setAttribute</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="n">gender</span><span class="p">,</span><span class="nv">Gender</span><span class="p">),</span>
</pre>
<p>This would be correct:</p>
<pre class="code erlang literal-block">
<span class="c">% RIGHT but a bit clumsy:
</span><span class="nf">construct</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">Age</span><span class="p">,</span><span class="nv">Gender</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="nv">AgeState</span> <span class="o">=</span> <span class="n">setAttribute</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="n">age</span><span class="p">,</span><span class="nv">Age</span><span class="p">),</span>
  <span class="n">setAttribute</span><span class="p">(</span><span class="nv">AgeState</span><span class="p">,</span><span class="n">gender</span><span class="p">,</span><span class="nv">Gender</span><span class="p">).</span>
</pre>
<p>Recommended form:</p>
<pre class="code erlang literal-block">
<span class="c">% BEST:
</span><span class="nf">construct</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">Age</span><span class="p">,</span><span class="nv">Gender</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="n">setAttributes</span><span class="p">(</span><span class="nv">State</span><span class="p">,[{</span><span class="n">age</span><span class="p">,</span><span class="nv">Age</span><span class="p">},{</span><span class="n">gender</span><span class="p">,</span><span class="nv">Gender</span><span class="p">}]).</span>
</pre>
<p>The WOOPER defaults would imply that, in the first case, at compilation time the <tt class="docutils literal">AgeState</tt> variable would be reported as unused, and this warning would be considered as a fatal error.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>There is no strict relationship between <em>construction parameters</em> and <em>instance attributes</em>, neither in terms of cardinality, type nor value.</p>
<p>For example, attributes could be set to default values, a point could be created from an angle and a distance but its actual state may consist on two cartesian coordinates instead, etc.</p>
<p class="last">Therefore both have to be defined by the class developer, and, in the general case, attributes cannot be inferred from construction parameters.</p>
</div>
<p>Finally, a class can define multiple clauses for any of its constructors: the proper one will be called based on the pattern-matching performed on these parameters.</p>
</div>
</div>
<div class="section" id="instance-deletion">
<h3><a class="toc-backref" href="#id196">Instance Deletion</a></h3>
<div class="section" id="automatic-chaining-of-destructors">
<h4>Automatic Chaining Of Destructors</h4>
<p>We saw that, when implementing a constructor (<tt class="docutils literal">construct/N</tt>), like in all other OOP approaches the constructors of the direct mother classes have to be explicitly called, so that they can be given the proper parameters, as determined by the class developer.</p>
<p>Conversely, with WOOPER, when defining a destructor for a class (<tt class="docutils literal">destruct/1</tt>), one only has to specify what are the <em>specific</em> operations and state changes (if any) that are required so that an instance of that class is deleted: the proper calling of the destructors of mother classes across the inheritance graph is automatically taken in charge by WOOPER.</p>
<p>Once the user-specified actions have been processed by the destructor (ex: releasing a resource, unsubscribing from a registry, deleting other instances, closing properly a file, etc.), it is expected to return an updated state, which will be given in turn to the destructors of the instance direct mother classes.</p>
<p>WOOPER will automatically make use of any user-defined destructor, otherwise the default one will be used, doing nothing (i.e. returning the exact same state that it was given).</p>
<p>Note also that, as always, there is a single destructor associated to a given class.</p>
<p>As constructors, destructors should not be exported, as WOOPER is to automatically take care of that.</p>
</div>
<div class="section" id="asynchronous-destruction-using-destruct-1">
<h4>Asynchronous Destruction: using <tt class="docutils literal">destruct/1</tt></h4>
<p>The type specification of a destructor (<tt class="docutils literal">destruct/1</tt>) is:</p>
<pre class="literal-block">
-spec destruct(wooper:state()) -&gt; wooper:state().
</pre>
<p>More precisely, either the class implementer does not define at all a <tt class="docutils literal">destruct/1</tt> operator (and therefore uses the default do-nothing destructor), or it defines it explicitly, like in:</p>
<pre class="code erlang literal-block">
<span class="nf">destruct</span><span class="p">(</span><span class="nv">State</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;An instance of class </span><span class="si">~w</span><span class="s"> is being deleted now!&quot;</span><span class="p">,[</span><span class="o">?</span><span class="nv">MODULE</span><span class="p">]),</span>
    <span class="c">% Quite often the destructor does not need to modify the state of
</span>    <span class="c">% the instance:
</span>    <span class="nv">State</span><span class="p">.</span>
</pre>
<p>In both cases (default or user-defined destructor), when the instance will be deleted (ex: <tt class="docutils literal">MyInstance ! delete</tt> is issued), WOOPER will take care of:</p>
<ul class="simple">
<li>calling any user-defined destructor for that class</li>
<li>then calling the ones of the direct mother classes, which will in turn call the ones of their mother classes, and so on</li>
</ul>
<p>Note that the destructors for direct mother classes will be called in the reverse order of the one according to the constructors ought to have been called: if a class <tt class="docutils literal">class_X</tt> declares <tt class="docutils literal">class_A</tt> and <tt class="docutils literal">class_B</tt> as mother classes (in that order), then in the <tt class="docutils literal">class_X:construct</tt> definition the implementer is expected to call <tt class="docutils literal">class_A:construct</tt> and then <tt class="docutils literal">class_B:construct</tt>, whereas on deletion the WOOPER-enforced order of execution will be: <tt class="docutils literal">class_X:destruct/1</tt>, then <tt class="docutils literal">class_B:destruct/1</tt>, then <tt class="docutils literal">class_A:destruct/1</tt>, for the sake of symmetry.</p>
</div>
<div class="section" id="synchronous-destruction-using-synchronous-delete-1">
<h4>Synchronous Destruction: using <tt class="docutils literal">synchronous_delete/1</tt></h4>
<p>WOOPER automatically defines as well a way of deleting <em>synchronously</em> a given instance: a caller can request a synchronous (blocking) deletion of that instance so that, once notified of the deletion, it knows for sure the instance does not exist anymore, like in:</p>
<pre class="code erlang literal-block">
<span class="nv">InstanceToDelete</span> <span class="o">!</span> <span class="p">{</span><span class="n">synchronous_delete</span><span class="p">,</span><span class="n">self</span><span class="p">()},</span>
<span class="c">% Then the caller can block as long as the deletion did not occur:
</span><span class="k">receive</span>
  <span class="p">{</span><span class="n">deleted</span><span class="p">,</span><span class="nv">InstanceToDelete</span><span class="p">}</span> <span class="o">-&gt;</span>
      <span class="n">doSomething</span><span class="p">()</span>
<span class="k">end</span><span class="p">.</span>
</pre>
<p>The class implementer does not have to do anything to support this feature, as the synchronous deletion is automatically built by WOOPER on top of the usual asynchronous one (both thus rely on <tt class="docutils literal">destruct/1</tt>).</p>
<p>For a more concise way of doing the same, see also:</p>
<ul class="simple">
<li><tt class="docutils literal">wooper:delete_synchronously_instance/1</tt> (for a single instance)</li>
<li><tt class="docutils literal">wooper:delete_synchronously_instances/1</tt> (for multiple ones)</li>
</ul>
<p></p>
</div>
</div>
</div>
<div class="section" id="passive-instances">
<span id="passive-instance"></span><h2><a class="toc-backref" href="#id197">Passive Instances</a></h2>
<p>A passive instance is an instance of a WOOPER class that is not powered by a dedicated (Erlang) process: it is just a mere (opaque) term, a pure data-structure that holds the state <a class="footnote-reference" href="#id36" id="id35">[16]</a> of that instance, and that is returned to the process having created that instance (which can then do whatever it wants with it - most probably store it as a &quot;super attribute&quot;).</p>
<table class="docutils footnote" frame="void" id="id36" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id35">[16]</a></td><td>This term is mostly the same state term as the one on which the process dedicated to an active instance is looping. So one could even imagine a WOOPER instance going back and forth between an active and a passive mode of operation, if it was useful.</td></tr>
</tbody>
</table>
<p>As a consequence, such a passive instance will not be able to perform any spontaneous behaviour on its own, or to have its member methods triggered by other processes. However most operations that can be done on &quot;standard&quot; (active) WOOPER instances can also be done on passive ones: like their active counterparts, they are constructed thanks to, well, one of the constructors defined by their class, they are destructed thanks to, well, their destructor, and in-between they will retain their inner state and be able to execute any request or oneway triggered by the process holding that term (and of course any underlying multiple inheritance will be respected).</p>
<p>Triggering a method onto a passive instance will result in a relevant function to be evaluated, not involving any message.</p>
<p>To create a passive instance, the <tt class="docutils literal">new_passive</tt> operator shall be used, like in:</p>
<pre class="literal-block">
MyPassiveCat = class_Cat:new_passive(_Age=2, female, _Fur=brown, _Whiskers=white)
</pre>
<p>Then methods can be triggered on it, like in:</p>
<pre class="literal-block">
{WhiskerCat,white} = wooper:execute_request(MyPassiveCat, getWhiskerColor),
OlderCat = wooper:execute_oneway(WhiskerCat, declareBirthday),
RedCat = wooper:execute_oneway(OlderCat, setFurColor, red),
[...]
</pre>
<p>Note that, in addition to <tt class="docutils literal"><span class="pre">execute_request/{2,3}</span></tt>, <tt class="docutils literal"><span class="pre">execute_const_request/{2,3}</span></tt> are available; the latter return only the request result, as the state of the passive instance shall be constant (this is checked in debug mode).</p>
<p>Symmetrically, in addition to <tt class="docutils literal"><span class="pre">execute_oneway/{2,3}</span></tt>, <tt class="docutils literal"><span class="pre">execute_const_oneway/{2,3}</span></tt> are available even though their use is less common.</p>
<p>Until, finally:</p>
<pre class="literal-block">
wooper:delete_passive(RedCat).
</pre>
<p><strong>Types</strong> may be defined in order to clarify the fact that a term corresponds to a (WOOPER) passive instance.</p>
<p>For example, for any kind of instance owning a passive calendar instance (created with, say, <tt class="docutils literal">class_Calendar:new_passive/2</tt>), one could define and use, as attribute type <a class="footnote-reference" href="#id38" id="id37">[17]</a>:</p>
<pre class="literal-block">
-type calendar_passive() :: wooper:passive_instance().
</pre>
<table class="docutils footnote" frame="void" id="id38" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id37">[17]</a></td><td>A type preferably defined that way and exported in <tt class="docutils literal">class_Calendar</tt>.</td></tr>
</tbody>
</table>
<p>See the <tt class="docutils literal">passive_instance_test</tt> module for more details about passive instances.</p>
<p></p>
</div>
</div>
<div class="section" id="miscellaneous-technical-points">
<h1><a class="toc-backref" href="#id106">Miscellaneous Technical Points</a></h1>
<div class="section" id="helper-vs-static">
<span id="helpers"></span><h2><a class="toc-backref" href="#id107">Helper vs Static</a></h2>
<p>In the context of a class, one may wonder what is the difference between an <strong>exported helper function</strong> and a <strong>static method</strong>?</p>
<p>In terms of actual runtime evaluation, none.</p>
<p>In terms of source code, there is little difference: the former just has to use the <tt class="docutils literal">wooper:return_static/1</tt> to terminate its clauses and, should it use a type spec, this one should specify a return type based on <tt class="docutils literal">return_static/1</tt>.</p>
<p>In terms of semantics, there are more differences: a static method is meant to stand by itself, whether or not an instance of that class exists, and to provide higher-level services.</p>
<p>On the contrary, an exported helper function is just a convenience for code-reuse, a means of sharing code between classes. Typically it centralises code of use by multiple methods, which often results in such an helper to have as a parameter a <tt class="docutils literal">State</tt> variable (preferably listed last among its parameters, for clarity/uniformity) - whereas this cannot happen with static methods.</p>
</div>
<div class="section" id="calling-a-method-clause-from-another">
<h2><a class="toc-backref" href="#id108">Calling a Method Clause from Another</a></h2>
<p>Sometimes, defining a clause based on the result of another one (of the same function) proves convenient. With methods, there are different ways to do so, some better than others.</p>
<p>For example, let's suppose we defined this (non-const) request:</p>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">spec</span> <span class="n">getPriceFor</span><span class="p">(</span><span class="nn">wooper</span><span class="p">:</span><span class="nf">state</span><span class="p">(),</span><span class="n">string</span><span class="p">())</span> <span class="o">-&gt;</span>
        <span class="n">request_return</span><span class="p">(</span><span class="n">price</span><span class="p">()).</span>
<span class="nf">getPriceFor</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">ArticleStringDescription</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="p">{</span><span class="nv">Price</span><span class="p">,</span><span class="nv">NewState</span><span class="p">}</span> <span class="o">=</span> <span class="p">[...</span><span class="n">some</span> <span class="n">code</span><span class="p">...]</span>
  <span class="nn">wooper</span><span class="p">:</span><span class="nf">return_state_result</span><span class="p">(</span><span class="nv">NewState</span><span class="p">,</span><span class="nv">Price</span><span class="p">).</span>
</pre>
<p>Now, we would like to support article descriptions being also possibly binary strings, without having to bother introducing a new price-establishing intermediary function (such as the <tt class="docutils literal">foo/2</tt> one, below) that would be common to the two corresponding clauses, like in:</p>
<pre class="code erlang literal-block">
<span class="nf">getPriceFor</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">ArticleStringDescription</span><span class="p">)</span> <span class="o">-&gt;</span>
       <span class="k">when</span> <span class="nb">is_list</span><span class="p">(</span><span class="nv">ArticleStringDescription</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="p">{</span><span class="nv">Price</span><span class="p">,</span><span class="nv">NewState</span><span class="p">}</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="nv">ArticleStringDescription</span><span class="p">,</span><span class="nv">State</span><span class="p">),</span>
  <span class="nn">wooper</span><span class="p">:</span><span class="nf">return_state_result</span><span class="p">(</span><span class="nv">NewState</span><span class="p">,</span><span class="nv">Price</span><span class="p">);</span>

<span class="nf">getPriceFor</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">ArticleBinDescription</span><span class="p">)</span>
       <span class="k">when</span> <span class="nb">is_binary</span><span class="p">(</span><span class="nv">ArticleBinDescription</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="p">{</span><span class="nv">Price</span><span class="p">,</span><span class="nv">NewState</span><span class="p">}</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="nb">binary_to_list</span><span class="p">(</span><span class="nv">ArticleBinDescription</span><span class="p">),</span>
                         <span class="nv">State</span><span class="p">),</span>
  <span class="nn">wooper</span><span class="p">:</span><span class="nf">return_state_result</span><span class="p">(</span><span class="nv">NewState</span><span class="p">,</span><span class="nv">Price</span><span class="p">).</span>

<span class="c">% Too cumbersome to define an extra function such as:
</span><span class="nf">foo</span><span class="p">(</span><span class="nv">ArticleStringDescription</span><span class="p">,</span><span class="nv">State</span><span class="p">)</span><span class="o">-&gt;</span>
  <span class="p">[...</span><span class="n">some</span> <span class="n">code</span><span class="p">...]</span>
</pre>
<p>So our first impulse would be to write instead something like:</p>
<pre class="code erlang literal-block">
<span class="c">% (same clause)
</span><span class="nf">getPriceFor</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">ArticleStringDescription</span><span class="p">)</span> <span class="o">-&gt;</span>
       <span class="k">when</span> <span class="nb">is_list</span><span class="p">(</span><span class="nv">ArticleStringDescription</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="p">{</span><span class="nv">Price</span><span class="p">,</span><span class="nv">NewState</span><span class="p">}</span> <span class="o">=</span> <span class="p">[...</span><span class="n">some</span> <span class="n">code</span><span class="p">...]</span>
  <span class="nn">wooper</span><span class="p">:</span><span class="nf">return_state_result</span><span class="p">(</span><span class="nv">NewState</span><span class="p">,</span><span class="nv">Price</span><span class="p">);</span>

<span class="c">% Added clause:
</span><span class="nf">getPriceFor</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">ArticleBinDescription</span><span class="p">)</span> <span class="o">-&gt;</span>
       <span class="k">when</span> <span class="nb">is_binary</span><span class="p">(</span><span class="nv">ArticleBinDescription</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="n">getPriceFor</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span>
      <span class="nb">binary_to_list</span><span class="p">(</span><span class="nv">ArticleBinDescription</span><span class="p">)).</span>
</pre>
<p>However this would not be correct, as the second clause lacks a terminator, and WOOPER does not accept that (it might be the sign that the developer believes he is writing an helper function).</p>
<p>So we would like to use <tt class="docutils literal">wooper:return_state_result/2</tt> for the second clause as well, however we shall then have a state and a price to feed this terminator. How can we obtain them from the presumably opaque term returned by the <tt class="docutils literal">wooper:return_state_result/2</tt> call of the first clause?</p>
<p>The answer is quite simple: all WOOPER method terminators being actually no-op, they are replaced at compilation-time by the actual terms they were given.</p>
<p>So a terminator taking only a state as parameter is replaced literally by this state (ex: <tt class="docutils literal">wooper:return_state(FooState)</tt> is actually <tt class="docutils literal">FooState</tt>), while one taking two returns a pair (ex: <tt class="docutils literal">wooper:return_state_result(FooState,Res)</tt> is actually <tt class="docutils literal">{FooState,Res}</tt>). No black magic here!</p>
<p>Therefore the implementation we target could be best <a class="footnote-reference" href="#id40" id="id39">[18]</a> written as:</p>
<pre class="code erlang literal-block">
<span class="c">% (same clause)
</span><span class="nf">getPriceFor</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">ArticleStringDescription</span><span class="p">)</span> <span class="o">-&gt;</span>
        <span class="k">when</span> <span class="nb">is_list</span><span class="p">(</span><span class="nv">ArticleStringDescription</span><span class="p">)</span> <span class="o">-&gt;</span>
   <span class="p">{</span><span class="nv">Price</span><span class="p">,</span><span class="nv">NewState</span><span class="p">}</span> <span class="o">=</span> <span class="p">[...</span><span class="n">some</span> <span class="n">code</span><span class="p">...]</span>
   <span class="nn">wooper</span><span class="p">:</span><span class="nf">return_state_result</span><span class="p">(</span><span class="nv">NewState</span><span class="p">,</span><span class="nv">Price</span><span class="p">);</span>

 <span class="c">% Added clause:
</span> <span class="n">getPriceFor</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">ArticleBinDescription</span><span class="p">)</span>
        <span class="k">when</span> <span class="nb">is_binary</span><span class="p">(</span><span class="nv">ArticleBinDescription</span><span class="p">)</span> <span class="o">-&gt;</span>
   <span class="p">{</span><span class="nv">NewState</span><span class="p">,</span><span class="nv">Price</span><span class="p">}</span> <span class="o">=</span> <span class="n">getPriceFor</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span>
       <span class="nb">binary_to_list</span><span class="p">(</span><span class="nv">ArticleBinDescription</span><span class="p">)),</span>
   <span class="nn">wooper</span><span class="p">:</span><span class="nf">return_state_result</span><span class="p">(</span><span class="nv">NewState</span><span class="p">,</span><span class="nv">Price</span><span class="p">).</span>
</pre>
<table class="docutils footnote" frame="void" id="id40" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id39">[18]</a></td><td><tt class="docutils literal">wooper:executeRequest/3</tt> could be used instead of matching the result of <tt class="docutils literal">wooper:return_state_result/2</tt> and breaking its opaqueness - but (even it is a matter of taste here) we prefer the more direct and efficient approach that was presented. Note though that in general they do not bear the same semantics: <tt class="docutils literal">wooper:executeRequest/3</tt> calls a possibly overridden version of the specified method, whereas a direct call targets specifically the class-local version of that method.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="integrated-call-apis">
<h2><a class="toc-backref" href="#id109">Integrated Call APIs</a></h2>
<div class="section" id="single-calls">
<h3><a class="toc-backref" href="#id110">Single Calls</a></h3>
<p>Calls made to <strong>passive instances</strong> require the use of a dedicated API that is provided by the <tt class="docutils literal">wooper</tt> module, namely:</p>
<ul class="simple">
<li>for requests: <tt class="docutils literal"><span class="pre">execute_request/{2,3}</span></tt> and <tt class="docutils literal"><span class="pre">execute_const_request/{2,3}</span></tt></li>
<li>for oneways: <tt class="docutils literal"><span class="pre">execute_oneway/{2,3}</span></tt> and <tt class="docutils literal"><span class="pre">execute_const_oneway/{2,3}</span></tt></li>
</ul>
<p>As for <strong>active instances</strong>, doing the same directly through Erlang base constructs (message sending and receiving) is so easy that generally no specific API is involved - even though it exists (notably to allow for a few usage variations):</p>
<ul class="simple">
<li>for requests: <tt class="docutils literal"><span class="pre">execute_request/{2,3,4}</span></tt></li>
<li>for oneways: <tt class="docutils literal"><span class="pre">execute_oneway/{2,3}</span></tt></li>
</ul>
<p>(with active instances, constness does not need to be taken at this level)</p>
</div>
<div class="section" id="multi-calls">
<h3><a class="toc-backref" href="#id111">Multi-Calls</a></h3>
<p>Sometimes, in the context of <em>active instances</em>, it may be more convenient to reason not in terms of single calls, but of multiple calls, with various flavours in the number of callers, callees, method calls involved, parallelism and synchronisation.</p>
<p>So the <tt class="docutils literal">wooper</tt> module provides facilities in order to execute:</p>
<ul class="simple">
<li>a given <strong>request</strong> <strong>sequentially</strong> on <strong>multiple callees</strong>: <tt class="docutils literal">send_request_in_turn/3</tt> or, if wanting that a time-out applies, <tt class="docutils literal">send_request_in_turn/4</tt></li>
<li>the same for a <strong>oneway</strong> sending (off-band, through a direct message sending) a user-specified <strong>acknowledgement term</strong> (ex: a conventional atom): <tt class="docutils literal">send_acknowledged_oneway_in_turn/5</tt></li>
<li>a given <strong>request</strong>, whose only result in a user-specified <strong>acknowledgement term</strong>, in <strong>parallel</strong> on <strong>multiple callees</strong>: <tt class="docutils literal">send_requests_and_wait_acks/4</tt> or, if wanting that a time-out applies, <tt class="docutils literal">send_requests_and_wait_acks/5</tt></li>
<li>a given <strong>request</strong> in <strong>parallel</strong> on <strong>multiple callees</strong>, obtaining back an <strong>unordered</strong> list of their results: <tt class="docutils literal">obtain_results_for_requests/3</tt></li>
<li>a <strong>series of requests</strong> on a <strong>single</strong> callee: <tt class="docutils literal">send_request_series/2</tt> (just for the sending) and <tt class="docutils literal">obtain_results_for_request_series/2</tt> (to include also the collecting of their ordered results)</li>
</ul>
<p>Many more flavours can be considered (ex: for active/passive instances, requests or oneways, with or without time-out, synchronisable or not, etc.) and may be supported in the future, on a per-need basis.</p>
<p>However it may be more convenient to compose any extra multi-call that is needed thanks to the various basic helpers that are provided in the <tt class="docutils literal">wooper</tt> module in order to send calls or to collect their results. Doing so allows for example to perform interleaving (triggering concurrent calls as soon as possible, collecting their results as late as possible) and maximise the overall parallelism.</p>
</div>
</div>
<div class="section" id="methods-not-returning-anything-of-interest">
<h2><a class="toc-backref" href="#id112">Methods Not Returning Anything of Interest</a></h2>
<p>Not all functions or static methods (or even requests) are pure, and sometimes only the side-effects of their execution are of interest, in which case nothing relevant may have to be returned <a class="footnote-reference" href="#id42" id="id41">[19]</a>.</p>
<table class="docutils footnote" frame="void" id="id42" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id41">[19]</a></td><td>So, why one use a request instead of a oneway then? One reason is synchronisation, so that the caller code can block until the request has completed. Nevertheless for that use case we recommend that such a request returns a conventional, self-describing, preferably unique atom, such as <tt class="docutils literal">foobar_server_stopped</tt>. We will focus here mostly on the static methods that would have no meaningful value to return.</td></tr>
</tbody>
</table>
<p>For such needs, our <a class="reference external" href="http://myriad.esperide.org">Myriad</a> base layer introduced the opaque pseudo-builtin type <tt class="docutils literal">void()</tt> (nothing fancy), which is to be used by WOOPER methods as well.</p>
<p>Should one need a value of the <tt class="docutils literal">void/0</tt> type, we recommend using the <tt class="docutils literal">void</tt> atom.</p>
<p>As a result (pun!), one may define:</p>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">spec</span> <span class="n">stop</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">static_return</span><span class="p">(</span><span class="n">void</span><span class="p">()).</span>
<span class="nf">stop</span><span class="p">()</span> <span class="o">-&gt;</span>
  <span class="p">[...]</span> <span class="c">% Do some side-effects
</span>  <span class="nn">wooper</span><span class="p">:</span><span class="nf">return_static</span><span class="p">(</span><span class="n">void</span><span class="p">).</span>
</pre>
<p>Introducing specific method terminators to convey that meaning would have been possible, yet multiplying the syntactical constructs would probably hurt the terseness of the underlying language.</p>
<p>However, as, fairly frequently, static methods have nothing meaningful to return, the <tt class="docutils literal">wooper:return_static_void/0</tt> method terminator and its spec-level counterpart <tt class="docutils literal">static_void_return()</tt> type have been introduced <a class="footnote-reference" href="#id45" id="id44">[20]</a>.</p>
<table class="docutils footnote" frame="void" id="id45" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id44">[20]</a></td><td>This method terminator is replaced at compilation-time by a no-op, thus the static method returns actually the previous expression - unless there is none, in which case the <tt class="docutils literal">wooper_void_return</tt> atom is returned (the caller is not expected to match a void result anyway).</td></tr>
</tbody>
</table>
</div>
<div class="section" id="exception-throwing-methods">
<h2><a class="toc-backref" href="#id113">Exception-Throwing Methods</a></h2>
<p>A <strong>clause of a method may simply always throw an exception</strong>, and WOOPER will manage it automatically if possible.</p>
<p>More precisely, such a clause is considered licit yet not giving information about the method type. So, should there be other, non-throwing clauses, WOOPER will still be able to identify the nature of the method.</p>
<p>Otherwise (all clauses always throw), the class developer will have to give a hint about the actual nature of that function - thanks to a type specification.</p>
<p>For example, if defining the API of an abstract class (say, an <tt class="docutils literal">AbstractShape</tt> class) whereas, for a given method signature (ex: <tt class="docutils literal">getArea/1</tt>), there is no meaningful default implementation, one may for example write:</p>
<pre class="code erlang literal-block">
<span class="nf">getArea</span><span class="p">(_</span><span class="nv">State</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="c">% For an abstract shape, no possible definition;
</span>    <span class="c">% so catching any child class not overriding it,
</span>    <span class="c">% thanks to:
</span>    <span class="c">%
</span>    <span class="n">throw</span><span class="p">(</span><span class="n">not_overridden</span><span class="p">).</span>
</pre>
<p>However, from the point of view of WOOPER, <tt class="docutils literal">getArea/1</tt>, short of using any method terminator, can be of any nature (for example a method or an helper function). WOOPER will then request the developer to clarify this ambiguity by adding a type spec, such as:</p>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">spec</span> <span class="n">getArea</span><span class="p">(</span><span class="nn">wooper</span><span class="p">:</span><span class="nf">state</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="n">const_request_return</span><span class="p">(</span><span class="n">area</span><span class="p">()).</span>
</pre>
<p>This will be sufficient for WOOPER.</p>
<p>In other related cases, it may be convenient instead to centralise the management of a range of failures in specific <strong>helper functions that always throw</strong> (such a function never returns), like in:</p>
<pre class="code erlang literal-block">
<span class="nf">manage_foobar_failure</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">[...]</span>
    <span class="n">throw</span><span class="p">({</span><span class="n">foobar_failed</span><span class="p">,{</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">}}).</span>
</pre>
<p>Writing a method relying on such an helper function could be:</p>
<pre class="code erlang literal-block">
<span class="nf">doSomething</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">A</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">case</span> <span class="n">foobar</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">State</span><span class="p">)</span> <span class="k">of</span>

       <span class="p">{</span><span class="n">value</span><span class="p">,</span><span class="nv">Result</span><span class="p">}</span> <span class="o">-&gt;</span>
           <span class="nn">wooper</span><span class="p">:</span><span class="nf">const_return_result</span><span class="p">(</span><span class="nv">Result</span><span class="p">);</span>

       <span class="p">{</span><span class="n">error</span><span class="p">,</span><span class="nv">Error</span><span class="p">}</span> <span class="o">-&gt;</span>
           <span class="n">manage_foobar_failure</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">Error</span><span class="p">)</span>

    <span class="k">end</span><span class="p">.</span>
</pre>
<p>The problem is that this call to <tt class="docutils literal">manage_foobar_failure/2</tt> does not include a method terminator, and thus this branch would be, from the WOOPER point of view, the one of an helper function, thus clashing with the other branches (here telling it is a const request).</p>
<p>A solution could be to write instead:</p>
<pre class="code erlang literal-block">
<span class="p">[...]</span>
        <span class="p">{</span><span class="n">error</span><span class="p">,</span><span class="nv">Error</span><span class="p">}</span> <span class="o">-&gt;</span>
            <span class="nv">Dummy</span> <span class="o">=</span> <span class="n">manage_foobar_failure</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">Error</span><span class="p">),</span>
            <span class="nn">wooper</span><span class="p">:</span><span class="nf">const_return_result</span><span class="p">(</span><span class="nv">Dummy</span><span class="p">)</span>
</pre>
<p>but that resulting code would not be that satisfactory (a bit ugly, not so readable).</p>
<p>So, instead, WOOPER introduced the <tt class="docutils literal">throwing/1</tt> method terminator, allowing the following, clearer, more elegant, code:</p>
<pre class="code erlang literal-block">
<span class="p">[...]</span>
        <span class="p">{</span><span class="n">error</span><span class="p">,</span><span class="nv">Error</span><span class="p">}</span> <span class="o">-&gt;</span>
            <span class="nn">wooper</span><span class="p">:</span><span class="nf">throwing</span><span class="p">(</span> <span class="n">manage_foobar_failure</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">Error</span><span class="p">)</span> <span class="p">)</span>
</pre>
</div>
<div class="section" id="delete-any-instance-referenced-in-2">
<h2><a class="toc-backref" href="#id114"><tt class="docutils literal">delete_any_instance_referenced_in/2</tt></a></h2>
<p>When an attribute contains either a single instance reference (i.e. the PID of the corresponding process) or a list of instance references, this WOOPER-defined helper function will automatically delete (asynchronously) these instances, and will return an updated state in which this attribute is set to <tt class="docutils literal">undefined</tt>.</p>
<p>This function is especially useful in destructors.</p>
<p>For example, if <tt class="docutils literal">State</tt> contains:</p>
<ul class="simple">
<li>an attribute named <tt class="docutils literal">my_pid</tt> whose value is the PID of an instance</li>
<li>and also an attribute named <tt class="docutils literal">my_pids</tt> containing a list of PID instances</li>
</ul>
<p>and if the instance at hand that shall be deleted took ownership of these instances, then:</p>
<pre class="code erlang literal-block">
<span class="nf">delete</span><span class="p">(</span><span class="nv">State</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">TempState</span> <span class="o">=</span> <span class="nn">wooper</span><span class="p">:</span><span class="nf">delete_any_instance_referenced_in</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="n">my_pid</span><span class="p">),</span>
    <span class="nn">wooper</span><span class="p">:</span><span class="nf">delete_any_instance_referenced_in</span><span class="p">(</span><span class="nv">TempState</span><span class="p">,</span><span class="n">my_pids</span><span class="p">).</span>
</pre>
<p>will automatically delete all these instances (if any) and return an updated state.</p>
<p>Then the destructors of the mother classes can be chained by WOOPER.</p>
<p>See also the various other helpers defined in <tt class="docutils literal">wooper.erl</tt>.</p>
</div>
<div class="section" id="exit-signals-messages">
<h2><a class="toc-backref" href="#id115"><tt class="docutils literal">EXIT</tt> Signals / Messages</a></h2>
<p>A class instance may (if trapping EXIT signals) receive EXIT messages from other processes.</p>
<p>A given class can process these EXIT notifications:</p>
<ul class="simple">
<li>either by defining and exporting the <tt class="docutils literal">onWOOPERExitReceived/3</tt> oneway</li>
<li>or by inheriting it</li>
</ul>
<p>For example:</p>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">spec</span> <span class="n">onWOOPERExitReceived</span><span class="p">(</span><span class="nn">wooper</span><span class="p">:</span><span class="nf">state</span><span class="p">(),</span><span class="nn">basic_utils</span><span class="p">:</span><span class="nf">pid_or_port</span><span class="p">(),</span>
             <span class="nn">basic_utils</span><span class="p">:</span><span class="nf">exit_reason</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="n">const_oneway_return</span><span class="p">().</span>
<span class="nf">onWOOPERExitReceived</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">PidOrPort</span><span class="p">,</span><span class="nv">ExitReason</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;MyClass EXIT handler ignored signal '</span><span class="si">~p</span><span class="s">' &quot;</span>
                <span class="s">&quot;from </span><span class="si">~w</span><span class="s">.</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nv">ExitReason</span><span class="p">,</span><span class="nv">PidOrPort</span><span class="p">]),</span>
      <span class="nn">wooper</span><span class="p">:</span><span class="nf">const_return</span><span class="p">().</span>
</pre>
<p>may result in an output like:</p>
<pre class="literal-block">
MyClass EXIT handler ignored signal 'normal' from &lt;0.40.0&gt;.
</pre>
<p>If no class-level <tt class="docutils literal">onWOOPERExitReceived/3</tt> oneway is available, the default WOOPER EXIT handler (namely <tt class="docutils literal">wooper:default_exit_handler/3</tt>) will be used (it just performs console-based notification).</p>
<p>It will just notify the signal to the user, by displaying a message like:</p>
<pre class="literal-block">
WOOPER default EXIT handler for instance &lt;0.36.0&gt; of class class_Cat
  ignored signal 'normal' from &lt;0.40.0&gt;.
</pre>
</div>
<div class="section" id="down-messages-for-process-monitors">
<h2><a class="toc-backref" href="#id116"><tt class="docutils literal">DOWN</tt> Messages for Process Monitors</a></h2>
<p>A class instance may receive DOWN messages from other (monitored) processes.</p>
<p>A given class can process these DOWN notifications:</p>
<ul class="simple">
<li>either by defining and exporting the <tt class="docutils literal">onWOOPERDownNotified/5</tt> oneway</li>
<li>or by inheriting it</li>
</ul>
<p>If no class-level <tt class="docutils literal">onWOOPERDownNotified/5</tt> oneway is available, the default WOOPER DOWN handler (namely <tt class="docutils literal">wooper:default_down_handler/5</tt>) will be used (it just performs console-based notification).</p>
<p>Note that <tt class="docutils literal">DOWN</tt> messages shall not be mixed up with the <tt class="docutils literal">nodedown</tt> messages of the next section.</p>
</div>
<div class="section" id="node-monitors">
<h2><a class="toc-backref" href="#id117">Node Monitors</a></h2>
<p>Quite similarly to <tt class="docutils literal">EXIT</tt> messages, node monitors and <tt class="docutils literal">nodeup</tt> / <tt class="docutils literal">nodedown</tt> messages are also managed by WOOPER, see the <tt class="docutils literal">onWOOPERNodeConnection/3</tt> and <tt class="docutils literal">onWOOPERNodeDisconnection/3</tt> oneways.</p>
<p>Should these oneways be not available for the class at hand, the default WOOPER node handlers (namely <tt class="docutils literal">wooper:default_node_up_handler/3</tt> and <tt class="docutils literal">default_node_down_handler/3</tt> respectively) will be used (they just perform console-based notifications).</p>
<p>Note that <tt class="docutils literal">nodedown</tt> messages shall not be mixed up with the <tt class="docutils literal">DOWN</tt> messages of the previous section.</p>
</div>
<div class="section" id="a-bit-of-introspection">
<h2><a class="toc-backref" href="#id118">A bit of Introspection</a></h2>
<p>Here are the class-level information that can be fetched from the name of a class (as a result they are static methods):</p>
<ul class="simple">
<li><tt class="docutils literal">get_superclasses/0</tt> will return the (ordered) list of the declared direct mother classes of this class</li>
<li><tt class="docutils literal">get_class_specific_attributes/0</tt> will return the (in-order) list of declared class-specific attribute metadata, as a list of <tt class="docutils literal">wooper_info:attribute_info/0</tt> records, containing, for a given attribute: its name, type, qualifiers and textual description</li>
</ul>
<p>For example:</p>
<pre class="code erlang literal-block">
<span class="nn">class_Platypus</span><span class="p">:</span><span class="nf">get_superclasses</span><span class="p">().</span>
<span class="p">[</span><span class="n">class_Mammal</span><span class="p">,</span><span class="n">class_OvoviviparousBeing</span><span class="p">]</span>
</pre>
</div>
<div class="section" id="developer-guidelines">
<h2><a class="toc-backref" href="#id119">Developer Guidelines</a></h2>
<div class="section" id="general-guidelines">
<h3><a class="toc-backref" href="#id120">General Guidelines</a></h3>
<p>All WOOPER classes must include <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/blob/master/include/wooper.hrl">wooper.hrl</a>:</p>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">include</span><span class="p">(</span><span class="s">&quot;wooper.hrl&quot;</span><span class="p">).</span>
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This include should come, in the source file of a class, <em>after</em> all WOOPER-related defines (such as <tt class="docutils literal">superclasses</tt>, <tt class="docutils literal">class_attributes</tt>, etc.).</p>
</div>
<p>To help declaring the right defines in the right order, using the WOOPER <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/blob/master/priv/examples/class_WOOPERTemplate.erl.sample">template</a> is recommended.</p>
<p>One may also have a look at the full <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/priv/examples">test examples</a>, as a source of inspiration.</p>
<p>For examples of re-use of WOOPER by upper layers, one may refer to <a class="reference external" href="http://traces.esperide.org">Ceylan-Traces</a>, to <a class="reference external" href="http://us-web.esperide.org">US-Web</a> or to the <a class="reference external" href="http://sim-diasca.com">Sim-Diasca</a> simulation engine.</p>
</div>
<div class="section" id="otp-guidelines">
<h3><a class="toc-backref" href="#id121">OTP Guidelines</a></h3>
<p>For server-like activities, it may be useful to have instances of WOOPER classes (ex: <tt class="docutils literal">class_Foobar</tt>) behave like OTP workers in supervision trees.</p>
<p>Exactly like by default any Erlang process is not able to readily take part to an OTP supervision tree <a class="footnote-reference" href="#id49" id="id48">[21]</a>, a WOOPER instance must specifically support such an integration.</p>
<table class="docutils footnote" frame="void" id="id49" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id48">[21]</a></td><td>For that, such process has to comply with a relevant applicative protocol in order to properly interact with its supervisor, either directly by itself or through its implementation of a worker-compliant OTP behaviour like <a class="reference external" href="https://erlang.org/doc/man/gen_server.html">gen_server</a>.</td></tr>
</tbody>
</table>
<p>A <a class="reference external" href="https://erlang.org/doc/man/supervisor_bridge.html">supervisor bridge</a> (i.e. a process in charge of integrating properly such a non-OTP process into an OTP supervision tree) is the tool of choice here <a class="footnote-reference" href="#id51" id="id50">[22]</a>.</p>
<table class="docutils footnote" frame="void" id="id51" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id50">[22]</a></td><td><p class="first">Otherwise, as we understand it, should WOOPER instances be directly declared in a supervision tree as mere workers, they would have to implement typically the <tt class="docutils literal">gen_server</tt> behaviour, which implies relying on <tt class="docutils literal">handle_{call,cast,info}</tt> functions and on a behaviour-specific main loop - rather than on the counterpart method-based facilities offered by WOOPER.</p>
<p class="last">A consequence is the need for an extra, mostly idle process sitting between such a supervised WOOPER instance and its supervisor. In some cases (ex: a webserver processing each request based on a WOOPER instance), this overhead would be excessive; then defining a WOOPER-specific supervisor, able to handle directly its WOOPER instances as workers, could be devised.</p>
</td></tr>
</tbody>
</table>
<p>Rather than declaring the corresponding behaviour and its implemented API directly in the target class (ex: in <tt class="docutils literal">class_Foobar</tt>), we recommend for <em>clarity</em> (as, even if the bridge was declared in the same module, it would be still an intermediate, autonomous process sitting between the OTP supervisor and the WOOPER instance of interest) and for <em>separation of concerns</em> (leaving an OTP integration as an optional feature) to introduce a specific module for that, like done with <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Traces/blob/master/src/traces_bridge_sup.erl">traces_bridge_sup</a> for <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Traces/blob/master/src/class_TraceAggregator.erl">class_TraceAggregator.erl</a> or <a class="reference external" href="https://github.com/Olivier-Boudeville/us-common/blob/master/src/us_common_config_bridge_sup.erl">us_common_config_bridge_sup</a> for <a class="reference external" href="https://github.com/Olivier-Boudeville/us-common/blob/master/src/class_USConfigServer.erl">class_USConfigServer.erl</a>.</p>
<p>However, when the purpose of a given class is solely to integrate within an OTP application through a supervision tree, one may of course have the bridge directly defined in the WOOPER class the interfacing of which it is enabling; see <a class="reference external" href="https://github.com/Olivier-Boudeville/us-main/blob/master/src/class_USSensorManager.erl">class_USSensorManager.erl</a> for an example thereof.</p>
<p>In all cases, following the aforementioned <a class="reference external" href="https://github.com/Olivier-Boudeville/us-common/blob/master/src/us_common_config_bridge_sup.erl">us_common_config_bridge_sup</a> simple example, the additions mostly boil down to, in a relevant module as discussed above:</p>
<ul class="simple">
<li>declaring the corresponding OTP behaviour, the exported functions that this implies, and any relevant define, like in:</li>
</ul>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">behaviour</span><span class="p">(</span><span class="n">supervisor_bridge</span><span class="p">).</span>

<span class="c">% User API of the bridge (can be arbitrarily chosen, including of course the arity):
</span><span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">start_link</span><span class="o">/</span><span class="mi">2</span><span class="p">]).</span>

<span class="c">% Callbacks of the supervisor_bridge behaviour:
</span><span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">init</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span> <span class="n">terminate</span><span class="o">/</span><span class="mi">2</span><span class="p">]).</span>

<span class="p">-</span><span class="ni">define</span><span class="p">(</span><span class="no">bridge_name</span><span class="p">,</span> <span class="o">?</span><span class="nv">MODULE</span><span class="p">).</span>
</pre>
<ul class="simple">
<li>implementing how the bridge shall be spawned by the user, like in:</li>
</ul>
<pre class="code erlang literal-block">
<span class="nf">start_link</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="nv">Z</span><span class="o">=</span><span class="n">f</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span>
  <span class="c">% Supposing here that a local registration of the bridge is wanted:
</span>  <span class="nn">supervisor_bridge</span><span class="p">:</span><span class="nf">start_link</span><span class="p">({</span><span class="n">local</span><span class="p">,</span> <span class="o">?</span><span class="n">bridge_name</span><span class="p">},</span>
      <span class="p">_</span><span class="nv">Module</span><span class="o">=?</span><span class="nv">MODULE</span><span class="p">,</span> <span class="p">_</span><span class="nv">InitArgs</span><span class="o">=</span><span class="p">[</span><span class="nv">Y</span><span class="p">,</span><span class="n">hello</span><span class="p">,</span><span class="nv">Z</span><span class="p">]).</span>
</pre>
<ul class="simple">
<li>implementing what the bridge shall do in terms of initialisation once spawned (notably regarding the WOOPER instance that it interfaces), like in:</li>
</ul>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">spec</span> <span class="n">init</span><span class="p">(</span> <span class="n">list</span><span class="p">()</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">'ok'</span><span class="p">,</span> <span class="n">pid</span><span class="p">(),</span> <span class="nv">BridgeState</span> <span class="p">::</span> <span class="n">term</span><span class="p">()}</span>
      <span class="p">|</span> <span class="n">'ignore'</span> <span class="p">|</span> <span class="p">{</span><span class="n">'error'</span><span class="p">,</span> <span class="nv">Error</span> <span class="p">::</span> <span class="n">term</span><span class="p">()}.</span>
<span class="nf">init</span><span class="p">(_</span><span class="nv">Args</span><span class="o">=</span><span class="p">[_</span><span class="nv">A</span><span class="p">,</span> <span class="nv">Atom</span><span class="p">,</span> <span class="nv">B</span><span class="p">])</span> <span class="o">-&gt;</span>
  <span class="c">% No synchronous creation supposed useful here:
</span>  <span class="nv">MyFoobarInstancePid</span> <span class="o">=</span> <span class="nn">class_Foobar</span><span class="p">:</span><span class="nf">new_link</span><span class="p">(</span><span class="nv">Atom</span><span class="p">,</span><span class="nv">B</span><span class="p">),</span>

  <span class="nv">InitialBridgeState</span> <span class="o">=</span> <span class="p">{</span><span class="nv">MyFoobarInstancePid</span><span class="p">,</span> <span class="nv">Atom</span><span class="p">},</span>

  <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">MyFoobarInstancePid</span><span class="p">,</span> <span class="nv">InitialBridgeState</span><span class="p">}.</span>
</pre>
<ul class="simple">
<li>do the same regarding termination, like in:</li>
</ul>
<pre class="code erlang literal-block">
<span class="nf">terminate</span><span class="p">(</span><span class="nv">Reason</span><span class="p">,</span> <span class="p">_</span><span class="nv">BridgeState</span><span class="o">=</span><span class="p">{</span><span class="nv">FoobarPid</span><span class="p">,</span> <span class="p">_</span><span class="nv">Atom</span><span class="p">})</span> <span class="o">-&gt;</span>
  <span class="c">% No synchronicity especially needed:
</span>  <span class="nv">FoobarPid</span> <span class="o">!</span> <span class="n">delete</span><span class="p">.</span>
</pre>
<p>Of course:</p>
<ul class="simple">
<li>any user API and bridge state can be elected, but the <a class="reference external" href="https://erlang.org/doc/man/supervisor_bridge.html#Module:init-1">supervisor_bridge behaviour</a> requires <tt class="docutils literal">init/1</tt> and <tt class="docutils literal">terminate/2</tt> to be defined with these arities and to return the terms documented</li>
<li>the various functions introduced here could be defined as static methods instead, but maybe such exported plain functions will be clearer for developers with an OTP background</li>
<li>spawned processes must be linked, so that crashes do not remain unnoticed</li>
<li>we recommend to add type specs and relevant traces in actual code</li>
</ul>
</div>
</div>
<div class="section" id="wooper-api">
<h2><a class="toc-backref" href="#id122">WOOPER API</a></h2>
<p>One can browse the <a class="reference external" href="api-doc/index.html">WOOPER API documentation</a>. WOOPER being, in some way, a dialect deriving from Erlang (hence closer to a language of its own than to a pure library), such an API documentation is most probably less useful than counterpart ones made for libraries like <a class="reference external" href="https://myriad.esperide.org/api-doc/index.html">Myriad</a>.</p>
<p>The next level of information is simply to read the corresponding <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER">source files</a>, which are intensely commented and generally straightforward.</p>
</div>
<div class="section" id="class-developer-cheat-sheet">
<span id="cheat-sheet"></span><h2><a class="toc-backref" href="#id123">Class Developer Cheat Sheet</a></h2>
<p>When specifying a <strong>class</strong>: <tt class="docutils literal"><span class="pre">-module(class_Foobar).</span></tt></p>
<p>Any <strong>description</strong> thereof: <tt class="docutils literal"><span class="pre">-define(class_description,&quot;Class</span> <span class="pre">for...&quot;).</span></tt></p>
<p>When specifying its <strong>superclasses</strong>: <tt class="docutils literal"><span class="pre">-define(superclasses,[A,B]).</span></tt></p>
<p>When specifying its <strong>class attributes</strong>: <tt class="docutils literal"><span class="pre">-define(class_attributes,[ATTR1,ATTR2,...])</span></tt></p>
<p>A given <tt class="docutils literal">ATTRn</tt> may be one of:</p>
<ul class="simple">
<li><tt class="docutils literal">{Name,Type,QualifierInfo,Description}</tt></li>
<li><tt class="docutils literal">{Name,Type,Description}</tt></li>
<li><tt class="docutils literal">{Name,Description}</tt></li>
<li><tt class="docutils literal">Name</tt></li>
</ul>
<p><tt class="docutils literal">QualifierInfo</tt> can be, for example, <tt class="docutils literal">public</tt>, or <tt class="docutils literal">[private,const]</tt>.</p>
<p>All member methods have <tt class="docutils literal">State</tt> for initial parameter, and are expected to return at least a (possibly const) state.</p>
<p>When defining a <strong>request</strong>:</p>
<ul class="simple">
<li>its <strong>spec</strong> should rely, for its return type, either on <tt class="docutils literal"><span class="pre">request_return(T())</span></tt> or on <tt class="docutils literal"><span class="pre">const_request_return(T())</span></tt></li>
<li>each of its clause should terminate with either <tt class="docutils literal">wooper:return_state_result(S,R)</tt> or <tt class="docutils literal">wooper:const_return_result(R)</tt></li>
</ul>
<p>When defining a <strong>oneway</strong>:</p>
<ul class="simple">
<li>its <strong>spec</strong> should rely, for its return type, either on <tt class="docutils literal">oneway_return()</tt> or on <tt class="docutils literal">const_oneway_return()</tt></li>
<li>each of its clause should terminate with either <tt class="docutils literal">wooper:return_state(S)</tt> or <tt class="docutils literal">wooper:const_return()</tt></li>
</ul>
<p>When defining a <strong>static method</strong>:</p>
<ul class="simple">
<li>its <strong>spec</strong> should rely, for its return type, either on <tt class="docutils literal"><span class="pre">static_return(T())</span></tt> or on <tt class="docutils literal">static_void_return()</tt></li>
<li>each of its clause should terminate with <tt class="docutils literal">wooper:return_static(R)</tt> or with <tt class="docutils literal">wooper:return_static_void()</tt></li>
</ul>
<p>Finding it difficult not to mix the keywords for spec return types (ex: <tt class="docutils literal">request_return/1</tt>) and method terminators (ex: <tt class="docutils literal">wooper:return_state_result/2</tt>)?</p>
<p>A mnemonic could be that a spec return type designates a returned <em>term</em> (hence for example a <tt class="docutils literal">request_return/1</tt> - more generally such types always end with <tt class="docutils literal">_return</tt>) whereas a method terminator designates an <em>action</em> (returning a state and a result, hence to <tt class="docutils literal">wooper:return_state_result/2</tt> for example).</p>
</div>
<div class="section" id="source-editors">
<h2><a class="toc-backref" href="#id124">Source Editors</a></h2>
<p>We use <tt class="docutils literal">Emacs</tt> but of course any editor will be fine.</p>
<p>For Nedit users, a WOOPER-aware <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Myriad/blob/master/conf/nedit.rc">nedit.rc</a> configuration file for syntax highlighting (on black backgrounds), inspired from Daniel Solaz's <a class="reference external" href="http://www.trapexit.org/forum/viewtopic.php?p=30189">Erlang Nedit mode</a>, is available.</p>
</div>
<div class="section" id="similarity-with-other-languages">
<h2><a class="toc-backref" href="#id125">Similarity With other Languages</a></h2>
<p>WOOPER is in some ways adding features quite similar to the ones available with other languages, including Python (simple multiple inheritance, implied <tt class="docutils literal">self/State</tt> parameter, attribute dictionaries/associative tables, etc.) while still offering the major strengths of Erlang (concurrency, distribution, functional paradigm) and not hurting too much the overall performances (mainly thanks to the prebuilt attribute and method tables).</p>
</div>
<div class="section" id="wooper-limitations">
<h2><a class="toc-backref" href="#id126">WOOPER limitations</a></h2>
<p>Actually no significant implementation shortcoming has been identified.</p>
<p>The main limitations that existed beforehand were (from the most recently alleviated to the earlier ones):</p>
<ul class="simple">
<li>the per-instance memory footprint has been reduced by sharing the &quot;virtual table&quot; of a given class between all its instances, thanks to <tt class="docutils literal">persistent_term</tt></li>
<li>the efficiency of the per-instance associative table to store the attribute values has been improved by switching from our hashtable implementation to a map-based one</li>
<li>the macro-based constructor declarations were too cumbersome and limiting (ex: a single constructor per class was supported); this is fully addressed thanks to the WOOPER parse transform now</li>
</ul>
<p>We expect the upcoming JIT compilation to benefit a lot to WOOPER, with no change having to be operated at its level.</p>
<p>As always, there is certainly room for improvement, to grind a bit more runtime performances and/or to further reduce the per-instance memory footprint. Profiling actions welcome!</p>
<p></p>
</div>
</div>
<div class="section" id="wooper-example">
<h1><a class="toc-backref" href="#id127">WOOPER Example</a></h1>
<p>We defined a small set of classes in order to serve as an example and demonstrate multiple inheritance:</p>
<p><span class="raw-html"><center><img src="wooper-example.png" id="responsive-image-large" alt="WOOPER Example"></img></center></span>
</p>
<div class="section" id="class-implementations">
<h2><a class="toc-backref" href="#id128">Class implementations</a></h2>
<ul class="simple">
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/priv/examples/class_Creature.erl">class_Creature.erl</a></li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/priv/examples/class_ViviparousBeing.erl">class_ViviparousBeing.erl</a></li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/priv/examples/class_OvoviviparousBeing.erl">class_OvoviviparousBeing.erl</a></li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/priv/examples/class_Mammal.erl">class_Mammal.erl</a></li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/priv/examples/class_Reptile.erl">class_Reptile.erl</a></li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/priv/examples/class_Cat.erl">class_Cat.erl</a></li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/priv/examples/class_Platypus.erl">class_Platypus.erl</a></li>
</ul>
</div>
<div class="section" id="tests">
<h2><a class="toc-backref" href="#id129">Tests</a></h2>
<p>Here are a few examples of tests:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/priv/examples/class_Creature_test.erl">class_Creature_test.erl</a></li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/priv/examples/class_ViviparousBeing_test.erl">class_ViviparousBeing_test.erl</a></li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/priv/examples/class_OvoviviparousBeing_test.erl">class_OvoviviparousBeing_test.erl</a></li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/priv/examples/class_Mammal_test.erl">class_Mammal_test.erl</a></li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/priv/examples/class_Reptile_test.erl">class_Reptile_test.erl</a></li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/priv/examples/class_Cat_test.erl">class_Cat_test.erl</a></li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/priv/examples/class_Platypus_test.erl">class_Platypus_test.erl</a></li>
</ul>
<p>To run a test (ex: <tt class="docutils literal">class_Cat_test.erl</tt>), when WOOPER has already been compiled, one just has to enter, from the corresponding directory: <tt class="docutils literal">make class_Cat_run</tt>.</p>
<p></p>
</div>
</div>
<div class="section" id="good-practices">
<h1><a class="toc-backref" href="#id130">Good Practices</a></h1>
<p>When using WOOPER, the following conventions are deemed useful to respect (even if they are not mandatory).</p>
<p>No <strong>warning</strong> should be tolerated in code using WOOPER, as we <em>never</em> found useless notifications.</p>
<p>All <strong>attributes</strong> of an instance should better be defined <strong>from the constructor</strong>, instead of being dynamically added during the life of the instance; otherwise the methods would have to deal with some attributes that may, or may not, be defined; if no proper value exists for an attribute at the creation of an instance, then its value should just be set to the atom <tt class="docutils literal">undefined</tt>; its type should then go from <tt class="docutils literal">T()</tt> to <tt class="docutils literal"><span class="pre">maybe(T())</span></tt>.</p>
<p><strong>Class-specific attributes</strong> should be specified (using the <tt class="docutils literal">class_attributes</tt> define), as doing so brings up much useful information to the developer/maintainer.</p>
<p><strong>Type specifications</strong> should be used for at least most non-internal functions (such as constructors, methods, etc.).</p>
<p>There are always welcome, and in some corner cases they are also needed by WOOPER in order to discriminate between equally possible cases (see <a class="reference internal" href="#exception-throwing-methods">Exception-Throwing Methods</a> for more information).</p>
<p>The <strong>naming conventions</strong> (ex: <tt class="docutils literal">CamelCase</tt> / <tt class="docutils literal">snake_case</tt>) shall be respected; notably, helper functions and static methods (which, from an Erlang point of view, are mostly just exported functions) should be named like C functions, in <tt class="docutils literal">snake_case</tt> (ex: <tt class="docutils literal">compute_sum</tt>) rather than being written in CamelCase (ex: no helper function should be named <tt class="docutils literal">computeSum</tt>), to avoid mixing up these different kinds of code.</p>
<p>To further separate helper functions from instance methods, an helper function taking a <tt class="docutils literal">State</tt> parameter should better place it at the end of its parameter list rather than in first position (ex: <tt class="docutils literal">compute_sum(X,Y,State)</tt> rather than <tt class="docutils literal">compute_sum(State,X,Y)</tt>).</p>
<p>In a method body, the various state variables being introduced should be properly named, i.e. their name should start with a self-documenting prefix followed by the <tt class="docutils literal">State</tt> suffix, like in: <tt class="docutils literal"><span class="pre">SeededState=setAttribute(State,seed,{1,7,11})</span></tt>.</p>
<p>Some more general (mostly unrelated) <strong>Erlang-level conventions</strong> that we like:</p>
<ul class="simple">
<li>when, in code, more than one parameter is specified in a function signature, parameter names can be surrounded by spaces (ex: <tt class="docutils literal">f( Color )</tt>, or <tt class="docutils literal">g( Age, Height )</tt>)</li>
<li>functions should be separated by (at least) three newlines, whereas clauses for a given function should be separated by one or two newlines, depending on their size</li>
<li>to auto-document parameters, a &quot;mute&quot; variable is preferably to be used: for example, instead of <tt class="docutils literal">f( Color, true )</tt> use <tt class="docutils literal">f( Color, _Dither=true )</tt>; however note that (unfortunately) these mute variables are still bound and thus pattern-matched: for example, if multiple <tt class="docutils literal">_Dither</tt> mute variables are bound in the same scope to different values, a bad match will be triggered at runtime.</li>
</ul>
<p></p>
</div>
<div class="section" id="supported-platforms">
<h1><a class="toc-backref" href="#id131">Supported Platforms</a></h1>
<p>WOOPER can be readily built and run on most Unices (including of course GNU/Linux) and on Windows.</p>
<p>Refer to <a class="reference external" href="http://myriad.esperide.org/#supported-platforms">the Myriad counterpart section</a> for more details.</p>
</div>
<div class="section" id="troubleshooting">
<h1><a class="toc-backref" href="#id132">Troubleshooting</a></h1>
<div class="section" id="debug-mode">
<h2><a class="toc-backref" href="#id133">Debug Mode</a></h2>
<p>We recommend that, as a WOOPER user, one enables its debug mode when developing (ensure in <tt class="docutils literal">GNUmakevars.inc</tt> that <tt class="docutils literal">ENABLE_DEBUG</tt> has been set to true - which is the case by default), as it may catch various user errors more easily (not only WOOPER-internal errors, but also, and most importantly, any user-originating mistake).</p>
<p>Then only, once one's code is mature enough, this debug mode may be disabled in order to obtain best performances.</p>
</div>
<div class="section" id="no-attribute-declaration-found-whereas-a-class-attributes-define-exists">
<h2><a class="toc-backref" href="#id134">&quot;No attribute declaration found&quot; whereas a <tt class="docutils literal">class_attributes</tt> define exists</a></h2>
<p>Most probably that your <tt class="docutils literal"><span class="pre">-define(class_attributes,[...]).</span></tt> define happens <em>after</em> the WOOPER header include.</p>
<p>The correct order is:</p>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">define</span><span class="p">(</span><span class="no">class_attributes</span><span class="p">,[</span>
            <span class="nv">ATTR_DECL1</span><span class="p">,</span>
            <span class="nv">ATTR_DECL2</span><span class="p">,</span>
            <span class="p">[...]</span>
            <span class="nv">ATTR_DECLN</span><span class="p">]).</span>
<span class="p">[...]</span>
<span class="p">-</span><span class="ni">include</span><span class="p">(</span><span class="s">&quot;wooper.hrl&quot;</span><span class="p">).</span>
<span class="p">[...]</span>
</pre>
</div>
<div class="section" id="compilation-error-pointing-to-wooper-for-classes-hrl">
<h2><a class="toc-backref" href="#id135">Compilation Error Pointing to <tt class="docutils literal">wooper_for_classes.hrl</tt></a></h2>
<p>As the comment in <tt class="docutils literal">wooper_get_class_attributes/0</tt> (in said header file) hints, the <tt class="docutils literal">class_attributes</tt> define in the class at hand is most probably incorrect (syntax error).</p>
<p>The compilation error message should help; if it is <tt class="docutils literal">syntax error before: '|'</tt>, a union type for an attribute must have been defined with <tt class="docutils literal">|</tt>, instead of with the <tt class="docutils literal">union</tt> variadic pseudo-operator. See the section about <a class="reference internal" href="#attribute-declaration">attribute declaration</a> for more details.</p>
</div>
<div class="section" id="general-case">
<h2><a class="toc-backref" href="#id136">General Case</a></h2>
<div class="section" id="compilation-warnings">
<h3><a class="toc-backref" href="#id137">Compilation Warnings</a></h3>
<p>A basic rule of thumb in all languages is to enable all warnings and eradicate them before even trying to test a program.</p>
<p>This is still more valid when using WOOPER, whose proper use should never result in any warning being issued by the compiler.</p>
<p>Notably warnings about unused variables are precious in order to catch mistakes when state variables are not being properly taken care of (ex: when a state is defined but never re-used later).</p>
</div>
<div class="section" id="runtime-errors">
<h3><a class="toc-backref" href="#id138">Runtime Errors</a></h3>
<p>Most errors while using WOOPER should result in relatively clear messages (ex: <tt class="docutils literal">wooper_method_failed</tt> or <tt class="docutils literal">wooper_method_faulty_return</tt>), associated with all relevant runtime information that was available to WOOPER, including context and stacktrace.</p>
<p>Another way of overcoming WOOPER issues is to activate the debug mode for all WOOPER-enabled compiled modules (ex: uncomment <tt class="docutils literal"><span class="pre">-define(wooper_debug_mode,).</span></tt> in <tt class="docutils literal">wooper.hrl</tt> or, preferably, ensure in <tt class="docutils literal">GNUmakevars.inc</tt> that <tt class="docutils literal">ENABLE_DEBUG</tt> has been set to true), and recompile your classes.</p>
<p>The debug mode tries to perform extensive checking on all WOOPER entry points, from incoming messages to the user class itself, catching mistakes from the class developer as well as from the class user.</p>
<p>For example, the validity of states returned by a constructor, by each method and by the destructor is checked, as the one of states specified to the <tt class="docutils literal">execute*</tt> constructs.</p>
<p>If it is not enough to clear things up, an additional step can be to add, on a per-class basis (ex: in <tt class="docutils literal">class_Cat.erl</tt>), before the WOOPER include, <tt class="docutils literal"><span class="pre">-define(wooper_log_wanted,).</span></tt>.</p>
<p>Then all incoming method calls will be traced, for easier debugging. It is seldom necessary to go till this level of detail.</p>
<p>As there are a few common WOOPER gotchas though, the main ones are listed below.</p>
<div class="section" id="mismatches-in-method-call">
<h4>Mismatches In Method Call</h4>
<div class="section" id="oneway-versus-request-calls">
<h5>Oneway Versus Request Calls</h5>
<p>One of these gotchas - experienced even by the WOOPER author - is to define a two-parameter oneway, whose second parameter is a PID, and to call this method wrongly as a request, instead of as a oneway.</p>
<p>For example, let's suppose the <tt class="docutils literal">class_Dog</tt> class defines the oneway method <tt class="docutils literal">startBarkingAt/3</tt> as:</p>
<pre class="code erlang literal-block">
<span class="nf">startBarkingAt</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">Duration</span><span class="p">,</span><span class="nv">ListenerPID</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">...</span>
</pre>
<p>The correct approach to call this <strong>oneway</strong> would be:</p>
<pre class="code erlang literal-block">
<span class="nv">MyDogPid</span> <span class="o">!</span> <span class="p">{</span><span class="n">startBarkingAt</span><span class="p">,[</span><span class="nv">MyDuration</span><span class="p">,</span><span class="n">self</span><span class="p">()]}</span>
</pre>
<p>An absent-minded developer could have written instead:</p>
<pre class="code erlang literal-block">
<span class="nv">MyDogPid</span> <span class="o">!</span> <span class="p">{</span><span class="n">startBarkingAt</span><span class="p">,</span><span class="nv">MyDuration</span><span class="p">,</span><span class="n">self</span><span class="p">()}</span>
</pre>
<p>This would have called a <tt class="docutils literal">request</tt> method <tt class="docutils literal">startBarkingAt/2</tt> (which could have been for example <tt class="docutils literal">startBarkingAt(State,TerminationOffset) <span class="pre">-&gt;</span> ...</tt>, the PID being interpreted by WOOPER as the request sender PID), a method that most probably does not even exist.</p>
<p>This would result in a bit obscure error message like:</p>
<pre class="literal-block">
Error in process &lt;0.43.0&gt; on node 'XXXX' with exit value:
  {badarg,[{class_Dog,wooper_main_loop,1}]}.
</pre>
</div>
<div class="section" id="list-parameter-incorrectly-specified-in-call">
<h5>List Parameter Incorrectly Specified In Call</h5>
<p>As explained in the <a class="reference internal" href="#method-parameters">Method Parameters</a> section,
if a method takes only one parameter and if this parameter is a list, then in a call this parameter cannot be specified as a standalone one: a parameter list with only one element, this parameter, should be used instead.</p>
</div>
</div>
<div class="section" id="error-with-exit-value-undef-map-hashtable-new">
<h4>Error With Exit Value: <tt class="docutils literal"><span class="pre">{undef,[{map_hashtable,new,[..]}..</span></tt></h4>
<p>You most probably forgot to build the <tt class="docutils literal">myriad</tt> directory that contains, among other modules, the <tt class="docutils literal">map_hashtable.erl</tt> source file.</p>
<p>Check that you have a <tt class="docutils literal">map_hashtable.beam</tt> file indeed, and that it can be found from the paths specified to the virtual machine.</p>
<p>Note that the WOOPER code designates this module as the <tt class="docutils literal">table</tt> one (ex: <tt class="docutils literal">table:new()</tt>), for a better substituability (this is obtained thanks to a parse-transform provided by <tt class="docutils literal"><span class="pre">Ceylan-Myriad</span></tt>) .</p>
<p></p>
</div>
</div>
</div>
</div>
<div class="section" id="current-stable-version-download">
<h1><a class="toc-backref" href="#id139">Current Stable Version &amp; Download</a></h1>
<div class="section" id="prerequisites">
<h2><a class="toc-backref" href="#id140">Prerequisites</a></h2>
<p>This OOP layer, <tt class="docutils literal"><span class="pre">Ceylan-WOOPER</span></tt>, relies (only) on:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.erlang.org/">Erlang</a></li>
<li>the <a class="reference external" href="http://myriad.esperide.org">Ceylan-Myriad</a> base layer</li>
</ul>
<p>We prefer using GNU/Linux, sticking to the latest stable release of Erlang, and building it from sources, thanks to GNU <tt class="docutils literal">make</tt>.</p>
<p>Refer to the corresponding <a class="reference external" href="http://myriad.esperide.org#prerequisites">Myriad prerequisite section</a>  for more precise guidelines, knowing that Ceylan-WOOPER does not need modules with conditional support such as <tt class="docutils literal">crypto</tt> or <tt class="docutils literal">wx</tt>.</p>
</div>
<div class="section" id="using-cutting-edge-git">
<h2><a class="toc-backref" href="#id141">Using Cutting-Edge GIT</a></h2>
<p>This is the installation method that we use and recommend; the WOOPER <tt class="docutils literal">master</tt> branch is meant to stick to the latest stable version: we try to ensure that this main line always stays functional (sorry for the pun). Evolutions are to take place in feature branches and to be merged only when ready.</p>
<p>As a result, once a proper Erlang version is available, the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Myriad">Ceylan-Myriad repository</a> should be cloned and built, before doing the same with the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER">Ceylan-WOOPER repository</a>, like in:</p>
<pre class="code bash literal-block">
$ git clone https://github.com/Olivier-Boudeville/Ceylan-Myriad myriad
$ <span class="nb">cd</span> myriad <span class="o">&amp;&amp;</span> make all <span class="o">&amp;&amp;</span> <span class="nb">cd</span> ..
$ git clone https://github.com/Olivier-Boudeville/Ceylan-WOOPER wooper
$ <span class="nb">cd</span> wooper <span class="o">&amp;&amp;</span> make all
</pre>
<p><span class="raw-html"><a name="otp"></a></span></p>
</div>
<div class="section" id="using-otp-related-build-runtime-conventions">
<span id="otp-build"></span><h2><a class="toc-backref" href="#id142">Using OTP-Related Build/Runtime Conventions</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Over the years, we slowly migrated from our custom, make-based build to integrate more closely to the OTP ecosystem (using applications, releases; then rebar3, hex).
Only mixed results were obtained (operations were slower, more complex, more fragile, and not always suitable for &quot;complex&quot; builds involving parse transforms).
So, at least for the moment, we prefer mostly relying on our custom build system (still supporting OTP conventions) and experience no drawback.</p>
</div>
<p>As discussed for <a class="reference external" href="http://myriad.esperide.org/myriad.html#otp">Myriad</a>, we added the (optional) possibility of generating a WOOPER <em>OTP application</em> out of the build tree (obtained thanks to the method described in the previous section), ready to be integrated into an <em>(OTP) release</em>. For that we rely on <a class="reference external" href="https://www.rebar3.org/">rebar3</a>, <a class="reference external" href="https://github.com/erlware/relx">relx</a> and <a class="reference external" href="https://hex.pm/">hex</a>.</p>
<p>OTP conventions mandate using:</p>
<pre class="literal-block">
-include_lib(&quot;wooper/include/wooper.hrl&quot;).
</pre>
<p>rather than:</p>
<pre class="literal-block">
-include(&quot;wooper.hrl&quot;).
</pre>
<p>Unlike Myriad, which is an OTP <em>library</em> application, WOOPER is an OTP <em>active</em> application, meaning the reliance on an application that can be started/stopped (<tt class="docutils literal">wooper_app</tt>), a root supervisor (<tt class="docutils literal">wooper_sup</tt>) and a class manager that is a background server process (<tt class="docutils literal">gen_server</tt>) in a supervision tree.</p>
<p><span class="raw-html"><a name="otp_for_instances"></a></span></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">By the way, why are the WOOPER instances not more tightly integrated within the OTP framework? The most natural match would be to have them implement as well the <tt class="docutils literal">gen_server</tt> behaviour - yet this would involve non-negligible overhead in terms of additional messages exchanges and function calls, and the API would not as pleasant as the current form (requests would have to be aggregated in <tt class="docutils literal">handle_call/3</tt>, oneways in <tt class="docutils literal">handle_cast/2</tt>, etc.).</p>
</div>
<div class="section" id="using-rebar3">
<h3><a class="toc-backref" href="#id143">Using Rebar3</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>In a nutshell: the usual rebar3 machinery is in place and functional, so the only WOOPER prerequisite (<a class="reference external" href="https://myriad.esperide.org">Myriad</a>) and WOOPER itself can be obtained simply thanks to:</p>
<pre class="code bash literal-block">
$ git clone https://github.com/Olivier-Boudeville/Ceylan-WOOPER.git wooper
$ <span class="nb">cd</span> wooper
$ rebar3 compile
</pre>
<p>Then WOOPER and its tests shall be ready for a successful execution.</p>
<p class="last">Note that rebar3 is an alternate way of building WOOPER, as one may rely directly on our make-based system instead.</p>
</div>
<p>The same procedures as <a class="reference external" href="http://myriad.esperide.org/myriad.html#otp">explained for Myriad</a> apply, once rebar3 is available:</p>
<pre class="code bash literal-block">
$ make rebar3-application
$ make rebar3-release
</pre>
<p>More precisely, to test the WOOPER OTP application support, provided that <tt class="docutils literal">make <span class="pre">rebar3-compile</span></tt> was issued beforehand, one can run from the root of the WOOPER source tree:</p>
<pre class="code bash literal-block">
$ <span class="nb">cd</span> <span class="nb">test</span>
$ make wooper_otp_application_run
       Running unitary <span class="nb">test</span> wooper_otp_application_run <span class="o">(</span>third form<span class="o">)</span>
            from wooper_otp_application_test

--&gt; Testing module wooper_otp_application_test.

Starting the WOOPER application.
<span class="o">[</span>debug<span class="o">]</span> Starting WOOPER application <span class="o">(</span>type: normal, start arguments: <span class="o">[])</span>.
<span class="o">[</span>debug<span class="o">]</span> Starting the WOOPER root supervisor.
<span class="o">[</span>debug<span class="o">]</span> Initializing the WOOPER root supervisor <span class="o">(</span>args: <span class="o">[])</span>.
<span class="o">[</span>debug<span class="o">]</span> Starting and linking the WOOPER class manager.
<span class="o">[</span>debug<span class="o">]</span> WOOPER class manager created, as &lt;<span class="m">0</span>.87.0&gt;.
WOOPER version: <span class="o">{</span><span class="m">2</span>,0,5<span class="o">}</span>.
Class filename corresponding to <span class="s1">'class_Tiger'</span>: <span class="s1">'class_Tiger.erl'</span>.
Stopping the WOOPER application.
<span class="o">[</span>debug<span class="o">]</span> Stopping WOOPER application <span class="o">(</span>state: <span class="o">[])</span>.
Successful end of <span class="nb">test</span> of the WOOPER application.
<span class="o">=</span>INFO <span class="nv">REPORT</span><span class="o">====</span> <span class="m">19</span>-Jul-2019::22:53:28.243821 <span class="o">===</span>
   application: wooper
   exited: stopped
   type: <span class="nv">temporary</span>
<span class="o">=</span>INFO <span class="nv">REPORT</span><span class="o">====</span> <span class="m">19</span>-Jul-2019::22:53:28.260437 <span class="o">===</span>
   application: myriad
   exited: stopped
   type: temporary

--&gt; Successful end of test.

<span class="o">(</span><span class="nb">test</span> finished, interpreter halted<span class="o">)</span>
</pre>
<p>One may run <tt class="docutils literal">make <span class="pre">create-wooper-checkout</span></tt> in order to create, based on our conventions, a suitable <tt class="docutils literal">_checkouts</tt> directory so that rebar3 can directly take into account local, directly available (in-development) dependencies (here, only Myriad).</p>
</div>
</div>
<div class="section" id="using-hex">
<h2><a class="toc-backref" href="#id144">Using Hex</a></h2>
<p><a class="reference external" href="https://hex.pm/packages/wooper">Hex packages for WOOPER</a> used to be published for most versions, yet finally our workflow does not rely on Hex, so we do not update the Hex packages anymore. Just drop us an email if needing a recent one.</p>
<p>For more details, one may have a look at:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/blob/master/conf/rebar.config.template">rebar.config.template</a>, the general rebar configuration file used when generating the WOOPER OTP application and release (implying the automatic management of Myriad)</li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/blob/master/conf/rebar-for-hex.config.template">rebar-for-hex.config.template</a>, to generate a corresponding Hex package for WOOPER (whose structure and conventions is quite different from the previous OTP elements)</li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/blob/master/conf/rebar-for-testing.config.template">rebar-for-testing.config.template</a>, the simplest test of the previous Hex package: an empty rebar project having for sole dependency that Hex package</li>
</ul>
</div>
<div class="section" id="testing-wooper">
<h2><a class="toc-backref" href="#id145">Testing WOOPER</a></h2>
<p>Once <a class="reference external" href="https://myriad.esperide.org">Myriad</a> and WOOPER itself have been built (for that refer to either <a class="reference internal" href="#using-cutting-edge-git">Using Cutting-Edge GIT</a> or <a class="reference internal" href="#using-rebar3">Using Rebar3</a>), just run from the root directory of WOOPER:</p>
<pre class="code bash literal-block">
$ make <span class="nb">test</span>
</pre>
<p>The testing shall complete successfully (if it is not the case, see our <a class="reference internal" href="#support">support</a> section).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">WOOPER is built and tested at each commit through <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/actions?query=workflow%3A%22Erlang+CI%22">continuous integration</a>, and the same holds for its only prerequisite (<a class="reference external" href="https://myriad.esperide.org">Myriad</a>).
Reciprocally this procedure applies to the projects based on it, directly (ex: <a class="reference external" href="https://traces.esperide.org/">Traces</a>) or not (ex: <a class="reference external" href="https://us-web.esperide.org/">US-Web</a>), so in terms of usability, confidence should be high.</p>
</div>
<p></p>
</div>
</div>
<div class="section" id="version-history-changes">
<h1><a class="toc-backref" href="#id146">Version History &amp; Changes</a></h1>
<div class="section" id="version-2-0-current-stable">
<h2><a class="toc-backref" href="#id147">Version 2.0 [current stable]</a></h2>
<p>Released officially on Sunday, February 3, 2019.</p>
<p>It has been a large rewriting of this layer, with much improvements notably:</p>
<ul class="simple">
<li>multiple different-arity constructors per class are supported now</li>
<li>no more <tt class="docutils literal">wooper_construct_parameters</tt>, longer <tt class="docutils literal">wooper_construct_export</tt> or <tt class="docutils literal">wooper_construct_export</tt> defines</li>
<li>automatic detection and export of constructors, any destructor and methods</li>
<li>WOOPER method terminators introduced (ex: <tt class="docutils literal">wooper:return_state_result/2</tt>, instead of the <tt class="docutils literal"><span class="pre">?wooper_return_state_result</span></tt> macro)</li>
<li>the <tt class="docutils literal">class_attributes</tt> optional parse attribute define introduced (<tt class="docutils literal"><span class="pre">-define(class_attributes,[...]).</span></tt></li>
<li><tt class="docutils literal">execute*With</tt> renamed as <tt class="docutils literal">execute*As</tt> (clearer)</li>
<li>convenience method wrappers such as <tt class="docutils literal">wooper:execute_request/3</tt> have their parameters reordered (target - either a PID or a passive instance - comes first now)</li>
<li>passive instances supported (still a bit experimental, not used a lot, yet working)</li>
</ul>
<p>More generally, many macros and definitions in the WOOPER header files moved to code generated thanks to a parse-transform.</p>
<p>Although this version does not share any code with the various experiments and candidate 2.0 versions that had been previously developed (thanks at least to Ulf and Nicolas in 2010, and to Enrique and Roland in 2013, both operating at that time on the so-called <em>Zero-Overhead WOOPER</em> version), these preliminary works surely helped defining the API that we deem suitable now, and that we implemented in the current version.</p>
</div>
<div class="section" id="version-1-x">
<h2><a class="toc-backref" href="#id148">Version 1.x</a></h2>
<p>Since 2016 we switched back to a &quot;rolling version&quot;, not really defining specific release milestones.</p>
<p>Many minor improvements integrated, API enriched in a backward compatible manner.</p>
<p>These versions have been pretty stable very soon, and did the job for nearly a decade (2008-2018), during which various attempts of radical improvements were performed.</p>
</div>
<div class="section" id="version-1-0">
<h2><a class="toc-backref" href="#id149">Version 1.0</a></h2>
<p>Countless improvements have been integrated in the course of the use of WOOPER, which has been now been stable for years.</p>
<p>The main change since the 0.4 version is the use of the newly-introduced <tt class="docutils literal">map</tt> Erlang datatype, resulting in the <tt class="docutils literal">hashtable</tt> module being replaced by the <tt class="docutils literal">map_hashtable</tt>. They obey to the same API and the <tt class="docutils literal">table</tt> pseudo-type abstracts out the actual choice in that matter (it is transparently parse-transformed into the currently-retained datatype).</p>
</div>
<div class="section" id="version-0-4">
<h2><a class="toc-backref" href="#id150">Version 0.4</a></h2>
<p>It is mainly a BFO (<em>Bug Fixes Only</em>) version, as functional coverage is pretty complete already.</p>
<p>Main changes are:</p>
<ul class="simple">
<li>debug mode enhanced a lot: many checkings are made at all fronteers between WOOPER and either the user code (messages) or the class code (constructors, methods, destructor, execute requests); user-friendly explicit error messages are displayed instead of raw errors in most cases; <tt class="docutils literal">is_record</tt> used to better detect when an expected state is not properly returned</li>
<li><tt class="docutils literal">wooper_result</tt> not appended any more to method returns in debug mode</li>
<li>release mode tested and fixed</li>
<li><tt class="docutils literal">exit</tt> replaced by <tt class="docutils literal">throw</tt>, use of newer and better <tt class="docutils literal">try/catch</tt> instead of mere <tt class="docutils literal">catch</tt></li>
<li>destructor chained calls properly fixed this time</li>
<li><tt class="docutils literal">delete_any_instance_referenced_in/2</tt> added, <tt class="docutils literal">wooper:return_state_*</tt> macros simplified, <tt class="docutils literal">remote_*</tt> bug fixed</li>
</ul>
</div>
<div class="section" id="version-0-3">
<h2><a class="toc-backref" href="#id151">Version 0.3</a></h2>
<p>Released on Wednesday, March 25, 2009.</p>
<p>Main changes are:</p>
<ul class="simple">
<li>destructors are automatically chained as appropriate, and they can be overridden at will</li>
<li>incoming EXIT messages are caught by a default WOOPER handler which can be overridden on a per-class basis by the user-specified <tt class="docutils literal">onWOOPERExitReceived/3</tt> method</li>
<li>direct method invocation supported, thanks to the <tt class="docutils literal">executeRequest</tt> and <tt class="docutils literal">executeOneway</tt> constructs, and <tt class="docutils literal">wooper_result</tt> no more appended to the result tuple</li>
<li>synchronous spawn operations added or improved: <tt class="docutils literal">synchronous_new/synchronous_new_link</tt> and al; corresponding template updated</li>
<li>state management enriched: <tt class="docutils literal">popFromAttribute</tt> added</li>
<li>all new variations on remote nodes improved or added</li>
<li>major update of the documentation</li>
</ul>
</div>
<div class="section" id="version-0-2">
<h2><a class="toc-backref" href="#id152">Version 0.2</a></h2>
<p>Released on Friday, December 21, 2007. Still fully functional!</p>
<p>Main changes are:</p>
<ul class="simple">
<li>the sender PID is made available to requests in the instance state variable (see <tt class="docutils literal">request_sender</tt> member, used automatically by the <tt class="docutils literal">getSender</tt> macro)</li>
<li>runtime errors better identified and notified</li>
<li>macros for attribute management added, existing ones more robust and faster</li>
<li>fixed a potential race condition when two callers request nearly at the same time the WOOPER class manager (previous mechanism worked, class manager was a singleton indeed, but second caller was not notified)</li>
<li>improved build (Emakefile generated), comments, error output</li>
<li>test template added</li>
<li>documentation updated</li>
</ul>
</div>
<div class="section" id="version-0-1">
<h2><a class="toc-backref" href="#id153">Version 0.1</a></h2>
<p>Released on Sunday, July 22, 2007. Already fully functional!</p>
<p></p>
</div>
</div>
<div class="section" id="wooper-inner-workings">
<h1><a class="toc-backref" href="#id154">WOOPER Inner Workings</a></h1>
<div class="section" id="general-principles">
<h2><a class="toc-backref" href="#id155">General Principles</a></h2>
<div class="section" id="understanding-compilation">
<h3><a class="toc-backref" href="#id156">Understanding Compilation</a></h3>
<p>WOOPER is the second level of a software stack beginning with Erlang and then Myriad.</p>
<p>If the initial versions of WOOPER were mostly based on macros and headers, newer ones rely on the Erlang way of doing metaprogramming, namely parse-transforms.</p>
<p>More precisely, the sources of a user-defined class are transformed by the standard Erlang toolchain (<tt class="docutils literal">erlc</tt> compiler) into an AST (<em>Abstract Syntax Tree</em>), which is first transformed by WOOPER (ex: to generate the new operators, to export any destructor, etc.) and then by Myriad (ex: to support newer types such as <tt class="docutils literal">void/0</tt>, <tt class="docutils literal">maybe/1</tt> or <tt class="docutils literal">table/2</tt>), which also provides much of the AST transformation support.</p>
</div>
<div class="section" id="understanding-the-mode-of-operation-of-a-wooper-instance">
<h3><a class="toc-backref" href="#id157">Understanding the Mode of Operation of a WOOPER Instance</a></h3>
<p>Each instance runs a main loop (<tt class="docutils literal">wooper_main_loop/1</tt>, defined in <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/blob/master/include/wooper.hrl">wooper.hrl</a>) that keeps its internal state and, through a blocking <tt class="docutils literal">receive</tt>, serves the methods as specified by incoming messages, quite similarly to a classical server that loops on an updated state, like in:</p>
<pre class="code erlang literal-block">
<span class="nf">my_server</span><span class="p">(</span><span class="nv">State</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="k">receive</span>
    <span class="p">{</span><span class="n">command</span><span class="p">,{</span><span class="nv">M</span><span class="p">,</span><span class="nv">P</span><span class="p">}}</span> <span class="o">-&gt;</span>
      <span class="nv">NewState</span> <span class="o">=</span> <span class="n">execute_command</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">M</span><span class="p">,</span><span class="nv">P</span><span class="p">),</span>
      <span class="n">my_server</span><span class="p">(</span><span class="nv">NewState</span><span class="p">)</span>
  <span class="k">end</span><span class="p">.</span>
</pre>
<p>In each instance, WOOPER manages the tail-recursive infinite surrounding loop, <tt class="docutils literal">State</tt> corresponding to the (private) state of the instance, and <tt class="docutils literal">execute_command(State,M,P)</tt> corresponding to the WOOPER logic that triggers the user-defined method <tt class="docutils literal">M</tt> with the current state (<tt class="docutils literal">State</tt>) and the specified parameters (<tt class="docutils literal">P</tt>), and that may return a result.</p>
<p>The per-instance kept state is twofold, in the sense that it contains two associative tables, one to route method calls and one to store the instance attributes, as explained below.</p>
</div>
</div>
<div class="section" id="method-virtual-table">
<h2><a class="toc-backref" href="#id158">Method Virtual Table</a></h2>
<div class="section" id="general-principle">
<h3><a class="toc-backref" href="#id159">General Principle</a></h3>
<p>This associative table allows, for a given class, to determine which module implements actually each supported method.</p>
<p>For example, all instances of <tt class="docutils literal">class_Cat</tt> have to know that their <tt class="docutils literal">getWhiskerColor/1</tt> method is defined directly in that class, as opposed to their <tt class="docutils literal">setAge/2</tt> method whose actual implementation is to be found, say, in <tt class="docutils literal">class_Mammal</tt>, should this class have overridden it from <tt class="docutils literal">class_Creature</tt>.</p>
<p>As performing a method look-up through the entire inheritance graph at each call would waste resources, the look-up is precomputed for each class.</p>
<p>Indeed a per-class table is built at runtime, on the first creation of an instance of this class, and stored by the unique (singleton) WOOPER class manager that shares it to all the class instances.</p>
<p>This manager is itself spawned the first time it is needed, and stays ready for all instances of various classes being created (it uses a table to associate to each class its specific virtual table).</p>
<p>This per-class method table has for keys the known method names (atoms) for this class, associated to the values being the most specialised module, in the inheritance graph, that defines that method.</p>
<p>Hence each instance has a reference to a shared table that allows for a direct method look-up.</p>
<p>As the table is built only once and is theoritically shared by all instances of that class <a class="footnote-reference" href="#id63" id="id62">[23]</a>, it adds very little overhead, space-wise and time-wise. Thanks to the table, method look-up is expected to be quite efficient too (constant-time).</p>
<table class="docutils footnote" frame="void" id="id63" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id62">[23]</a></td><td>Provided that Erlang does not copy these shared immutable structures, which unfortunately does not seem to be currently the case with the vanilla virtual machine. In a later version of WOOPER, the per-class table will be precompiled and shared as a module, thus fully removing that per-instance overhead.</td></tr>
</tbody>
</table>
<p>Taking <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/blob/master/priv/examples/class_Platypus.erl">class_Platypus.erl</a> as a (small) example (shallow inheritance tree, and just a few attributes), by uncommenting traces in the class manager, we can see that the size of the <tt class="docutils literal">class_Platypus</tt> virtual table is 1040 bytes.</p>
<p>At runtime, after its full construction, the total size of a Platypus instance (i.e. the overall size of its corresponding process) is 8712 bytes.</p>
<p>Knowing that (with OTP 23, AMD64 on GNU/Linux) the size of a blank process is 2688 bytes <a class="footnote-reference" href="#id65" id="id64">[24]</a>, the actual payload specific to this instance is <tt class="docutils literal"><span class="pre">8712-2688=6024</span> bytes</tt> (and the virtual table accounts for roughly 17% of it).</p>
<table class="docutils footnote" frame="void" id="id65" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id64">[24]</a></td><td>Measured with <tt class="docutils literal">P=spawn(basic_utils, freeze, [])</tt>, then <tt class="docutils literal">basic_utils:get_process_size(P)</tt>.</td></tr>
</tbody>
</table>
<p>After having used the <a class="reference external" href="https://erlang.org/doc/man/persistent_term.html">persistent_term</a> module (see our <tt class="docutils literal">persistent_term</tt> branch) to share these (immutable) per-class virtual tables, the size of the same test Platypus instance became 6840 bytes, corresponding thus to a per-instance shrinking of <tt class="docutils literal"><span class="pre">8712-6840=1872</span> bytes</tt> here.</p>
<p>When the class manager registers (once for all) the class_Platypus virtual table, the size of the persistent_term registry grows of 1072 bytes (which is consistent with a virtual table of 1040 bytes).</p>
</div>
</div>
<div class="section" id="attribute-table">
<h2><a class="toc-backref" href="#id160">Attribute Table</a></h2>
<p>This is another associative table, this time necessarily per-instance.</p>
<p>Keys are attribute names of that instance, values are the corresponding attribute values.</p>
<p>It allows a simple, seamless yet efficient access to all data members, including inherited ones.</p>
<p></p>
</div>
</div>
<div class="section" id="issues-planned-enhancements">
<h1><a class="toc-backref" href="#id161">Issues &amp; Planned Enhancements</a></h1>
<ul class="simple">
<li>integrate automatic persistent storage of instance states, for example in Mnesia databases</li>
<li>integrate specific constructs for code reflection</li>
<li>check that a class specified in <tt class="docutils literal">execute*As</tt> is indeed a (direct or not) mother class of this one, at least in debug mode</li>
<li>check that the declared attributes are legit (existing, not reserved, etc.) and their access as well (ex: regarding constness)</li>
<li>support qualifier-based declarations of methods and attributes (<tt class="docutils literal">public</tt>, <tt class="docutils literal">protected</tt>, <tt class="docutils literal">private</tt>, <tt class="docutils literal">final</tt>, <tt class="docutils literal">const</tt>, <tt class="docutils literal">pure</tt>, etc.)</li>
<li>generate automatically a graphical class diagram out of the sources of a set of projects (ex: using <a class="reference external" href="http://plantuml.com/">PlantUML</a>)</li>
</ul>
<ul class="simple">
<li>ensure that all instances of a given class <em>reference</em> the same table dedicated to the method look-ups, and do not have each their own private <em>copy</em> of it (mere referencing is expected to result from single-assignment); storing a per-class direct method mapping could also be done with prebuilt modules: <tt class="docutils literal">class_Cat</tt> would rely on an automatically generated <tt class="docutils literal">class_Cat_mt</tt> (for &quot;method table&quot;) module, which would just be used in order to convert a method name in the name of the module that should be called in the context of that class, inheritance-wise; or, preferably, this information could be added directly to <tt class="docutils literal">class_Cat</tt>; note that this should be the case now that the use of <tt class="docutils literal">persistent_term</tt> has been integrated</li>
</ul>
<p></p>
</div>
<div class="section" id="licence">
<span id="free-software"></span><h1><a class="toc-backref" href="#id162">Licence</a></h1>
<p>Ceylan-WOOPER is licensed by its author (Olivier Boudeville) under a disjunctive tri-license, giving you the choice of one of the three following sets of free software/open source licensing terms:</p>
<ul class="simple">
<li>the <a class="reference external" href="http://www.mozilla.org/MPL/MPL-1.1.html">Mozilla Public License</a> (MPL), version 1.1 or later (very close to the former <a class="reference external" href="http://www.erlang.org/EPLICENSE">Erlang Public License</a>, except aspects regarding Ericsson and/or the Swedish law)</li>
<li>the <a class="reference external" href="http://www.gnu.org/licenses/gpl-3.0.html">GNU General Public License</a> (GPL), version 3.0 or later</li>
<li>the <a class="reference external" href="http://www.gnu.org/licenses/lgpl.html">GNU Lesser General Public License</a> (LGPL), version 3.0 or later</li>
</ul>
<p>This allows the use of the WOOPER code in as wide a variety of software projects as possible, while still maintaining copyleft on this code.</p>
<p>Being triple-licensed means that someone (the licensee) who modifies and/or distributes it can choose which of the available sets of licence terms he is operating under.</p>
<p>We hope that enhancements will be back-contributed (ex: thanks to merge requests), so that everyone will be able to benefit from them.</p>
<p></p>
</div>
<div class="section" id="sources-inspirations-alternate-solutions">
<h1><a class="toc-backref" href="#id163">Sources, Inspirations &amp; Alternate Solutions</a></h1>
<ul class="simple">
<li><strong>Concurrent Programming in Erlang</strong>, Joe Armstrong, Robert Virding, Claes Wikström et Mike Williams. Chapter 18, page 299: Object-oriented Programming. This book describes a simple way of implementing multiple inheritance, without virtual table, at the expense of a (probably slow) systematic method look-up (at each method call). No specific state management is supported</li>
<li>Chris Rathman's <a class="reference external" href="http://www.angelfire.com/tx4/cus/shapes/erlang.html">approach</a> to life cycle management and polymorphism ; inheritance not supported</li>
<li><a class="reference external" href="http://www.erlang-factory.com/upload/presentations/162/ECT.pdf">ECT</a>, an Object-Oriented Extension to Erlang, very promising yet apparently not maintained anymore</li>
<li>As Burkhard Neppert suggested, an alternative way of implementing OOP here could be to use Erlang behaviours. This is the way OTP handles generic functionalities that can be specialised (e.g. <tt class="docutils literal">gen_server</tt>). One approach could be to map each object-oriented base class to an Erlang <strong>behaviour</strong>, and to make them cascade</li>
</ul>
<ul class="simple">
<li>As mentioned by Niclas Eklund, despite relying on quite different operating modes, WOOPER and Orber, an Erlang implementation of a <strong>CORBA ORB</strong> (<em>Object Request Broker</em>) offer similar OOP features, as CORBA IDL implies an object-oriented approach (with on OMG IDL to Erlang Mapping)</li>
</ul>
<p>WOOPER and Orber are rather different beasts, though: WOOPER is quite lightweight (less than 25 000 lines of code, including blank lines, numerous comments, tests and examples), does not involve a specific (IDL) compiler generating several stub/skeleton Erlang files, nor depends on OTP or on Mnesia (but depends on Myriad), whereas Orber offers a full, standard, CORBA implementation, including IDL language mapping, CosNaming, IIOP, Interface Repository, etc.</p>
<p>Since Orber respects the OMG standard, integrating a new language (C/C++, Java, Smalltalk, Ada, Lisp, Python etc.) should be rather easy. On the other hand, if a full-blown CORBA-compliant middleware is not needed, if simplicity and ease of understanding is a key point, then WOOPER could be preferred. If unsure, give a try to both!</p>
<p>See also another IDL-based approach (otherwise not connected to CORBA), the <a class="reference external" href="http://www.erlang.org/doc/apps/ic/ch_erl_genserv.html#5">Generic Server Back-end</a> (wrapper around <tt class="docutils literal">gen_server</tt>; warning: probably a dead link now).</p>
<p>The WOOPER name is also a tribute to the vastly underrated <a class="reference external" href="http://en.wikipedia.org/wiki/WarGames">Wargames</a> movie (remember the <a class="reference external" href="http://en.wikipedia.org/wiki/WOPR">WOPR</a>, the NORAD central computer?) that the author enjoyed a lot. It is as well a second-order tribute to the <em>Double Whopper King Size</em>, which is a great hamburger indeed <a class="footnote-reference" href="#id67" id="id66">[25]</a>.</p>
<table class="docutils footnote" frame="void" id="id67" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id66">[25]</a></td><td>Provided of course one is still fine with eating other animals (this is another topic).</td></tr>
</tbody>
</table>
<p></p>
</div>
<div class="section" id="support">
<h1><a class="toc-backref" href="#id164">Support</a></h1>
<p>Bugs, questions, remarks, patches, requests for enhancements, etc. are to be reported to the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER">project interface</a> (typically <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/issues">issues</a>) or directly at the email address mentioned at the beginning of this longer document.</p>
</div>
<div class="section" id="please-react">
<h1><a class="toc-backref" href="#id165">Please React!</a></h1>
<p>If you have information more detailed or more recent than those presented in this document, if you noticed errors, neglects or points insufficiently discussed, drop us a line! (for that, follow the <a class="reference internal" href="#support">Support</a> guidelines).</p>
</div>
<div class="section" id="ending-word">
<h1><a class="toc-backref" href="#id166">Ending Word</a></h1>
<p>Have fun with Ceylan-WOOPER!</p>
<p><span class="raw-html"><center><img src="wooper-title.png" id="responsive-image-small"></img></center></span>
</p>
<p><span class="raw-html"><a name="wooper_bottom"></a></span></p>
</div>
</div>
</body>
</html>
