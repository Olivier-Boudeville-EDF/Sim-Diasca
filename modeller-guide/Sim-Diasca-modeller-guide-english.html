<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.13.1: http://docutils.sourceforge.net/" />
<title>Sim-Diasca Modeller Guide</title>
<meta content="Sim-Diasca, massive, simulation, multi-agent, modelling" name="keywords" />
<link rel="stylesheet" href="pygments-default.css" type="text/css" />
<link rel="stylesheet" href="sim-diasca.css" type="text/css" />
<link href="sim-diasca-icon.png" rel="icon">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
<div class="document" id="sim-diasca-modeller-guide">
<h1 class="title">Sim-Diasca Modeller Guide</h1>

<p><span class="raw-html"><a name="sim_diasca_top"></a></span></p>
<p><span class="raw-html"><center><table><tr colspan="2"><center><img src="sim-diasca.png" style="width:500px"></center></tr><tr><td><center><img src="logo-EDF-english.png" style="width:150px"></center></td><td><center><img src="lgpl-v3-logo-bordered.png" style="width:140px"></center></td></tr></table></span></p>
<p></p>
<p><span class="raw-html"><div class="banner"><p><em>Sim-Diasca Modeller Guide</em> <a href="https://olivier-boudeville-edf.github.io/Sim-Diasca/">browse latest</a> <a href="Sim-Diasca-modeller-guide-english.pdf">get PDF</a> <a href="#sim_diasca_top">go to top</a> <a href="#sim_diasca_toc">go to toc</a> <a href="#sim_diasca_bottom">go to bottom</a> <a href="https://github.com/Olivier-Boudeville-EDF/Sim-Diasca">go to project</a> <a href="mailto:olivier(dot)boudeville(at)edf(dot)fr?subject=[Sim-Diasca]%20Remark%20about%20the%20modeller%20guide">email us</a></p></div></span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Organisation:</th><td class="field-body"><p class="first">Copyright (C) 2015-2022 EDF R&amp;D</p>
</td>
</tr>
<tr class="field"><th class="field-name">Contact:</th><td class="field-body"><p class="first">olivier (dot) boudeville (at) edf (dot) fr</p>
</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body"><p class="first">Olivier Boudeville</p>
</td>
</tr>
<tr class="field"><th class="field-name">Creation Date:</th><td class="field-body"><p class="first">March 2015</p>
</td>
</tr>
<tr class="field"><th class="field-name">Lastly updated:</th><td class="field-body"><p class="first">Monday, October 17, 2022</p>
</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body"><p class="first">2.4.4</p>
</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body"><p class="first">Stable</p>
</td>
</tr>
<tr class="field"><th class="field-name">Website:</th><td class="field-body"><p class="first"><a class="reference external" href="http://sim-diasca.com">http://sim-diasca.com</a></p>
</td>
</tr>
<tr class="field"><th class="field-name">Dedication:</th><td class="field-body"><p class="first">For people wanting to implement a simulation with the <cite>Sim-Diasca</cite> engine.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Abstract:</th><td class="field-body"><p class="first">We present here the main steps to go through whenever having to create a new simulation with Sim-Diasca, from the definition of the simulation case to the one of the models, the scenarios and any extra simulation service involved.</p>
<p class="last">The modelling and the implementation are described on a step-by-step basis, allowing to introduce incidentally the basic features offered by the engine.</p>
</td>
</tr>
</tbody>
</table>
<p><span class="raw-html"></center></span></p>
<p></p>
<p><span class="raw-html"><a name="sim_diasca_toc"></a></span></p>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first"><strong>Table of Contents</strong></p>
<ul class="simple">
<li><a class="reference internal" href="#overview-context" id="id67">Overview &amp; Context</a><ul>
<li><a class="reference internal" href="#objective" id="id68">Objective</a></li>
<li><a class="reference internal" href="#introducing-the-engine-thanks-to-a-step-by-step-example" id="id69">Introducing the Engine Thanks to a Step-by-Step Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#defining-the-simulation-case" id="id70">Defining the Simulation Case</a><ul>
<li><a class="reference internal" href="#where-shall-a-simulation-case-be-defined" id="id71">Where Shall a Simulation Case be Defined?</a></li>
<li><a class="reference internal" href="#the-three-main-settings-records" id="id72">The Three Main Settings Records</a><ul>
<li><a class="reference internal" href="#simulation-settings" id="id73">Simulation Settings</a></li>
<li><a class="reference internal" href="#deployment-settings" id="id74">Deployment Settings</a></li>
<li><a class="reference internal" href="#load-balancing-settings" id="id75">Load Balancing Settings</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#defining-the-models" id="id76">Defining the Models</a><ul>
<li><a class="reference internal" href="#general-outline" id="id77">General Outline</a></li>
<li><a class="reference internal" href="#construction-parameters" id="id78">Construction Parameters</a><ul>
<li><a class="reference internal" href="#construction-parameters-for-a-soda-vending-machine" id="id79">Construction Parameters for a Soda Vending Machine</a></li>
<li><a class="reference internal" href="#construction-parameters-for-a-thirsty-customer" id="id80">Construction Parameters for a Thirsty Customer</a></li>
<li><a class="reference internal" href="#from-construction-parameters-to-constructors" id="id81">From Construction Parameters To Constructors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-files" id="id82">Implementation Files</a><ul>
<li><a class="reference internal" href="#just-a-bit-of-computer-science-to-better-understand-the-whole" id="id83">Just A Bit of Computer Science To Better Understand The Whole</a></li>
<li><a class="reference internal" href="#in-practice-for-our-soda-example-case" id="id84">In Practice For Our Soda-Example Case</a></li>
</ul>
</li>
<li><a class="reference internal" href="#initial-state-of-the-simulation" id="id85">Initial State of the Simulation</a><ul>
<li><a class="reference internal" href="#creating-initial-instances-programmatically" id="id86">Creating Initial Instances Programmatically</a></li>
<li><a class="reference internal" href="#creating-initial-instances-from-a-data-stream" id="id87">Creating Initial Instances From a Data Stream</a></li>
<li><a class="reference internal" href="#what-about-scenarios" id="id88">What About Scenarios?</a></li>
<li><a class="reference internal" href="#instanciation-example" id="id89">Instanciation Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#wrapping-up-the-simulation-case" id="id90">Wrapping-Up the Simulation Case</a><ul>
<li><a class="reference internal" href="#initial-time-and-date" id="id91">Initial Time and Date</a></li>
<li><a class="reference internal" href="#termination-criteria" id="id92">Termination Criteria</a></li>
<li><a class="reference internal" href="#starting-the-simulation" id="id93">Starting the Simulation</a></li>
<li><a class="reference internal" href="#other-elements-to-include-in-a-simulation-case" id="id94">Other Elements To Include in a Simulation Case</a></li>
</ul>
</li>
<li><a class="reference internal" href="#model-specification" id="id95">Model Specification</a><ul>
<li><a class="reference internal" href="#behaviour" id="id96">Behaviour</a></li>
<li><a class="reference internal" href="#state" id="id97">State</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#defining-other-simulation-elements" id="id98">Defining Other Simulation Elements</a><ul>
<li><a class="reference internal" href="#command-files" id="id99">Command Files</a></li>
<li><a class="reference internal" href="#scenarios" id="id100">Scenarios</a></li>
<li><a class="reference internal" href="#special-probes" id="id101">Special Probes</a></li>
<li><a class="reference internal" href="#extra-services" id="id102">Extra Services</a></li>
</ul>
</li>
<li><a class="reference internal" href="#conclusion" id="id103">Conclusion</a></li>
</ul>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Before reading this document, we strongly advise to have at least had a first look at:</p>
<ol class="last arabic simple">
<li>the slides of the general-purpose presentation of Sim-Diasca</li>
<li>the <em>Sim-Diasca Technical Manual</em>, notably its simulation ontology (in chapter 3) and its overall modelling considerations (in chapter 6)</li>
</ol>
</div>
<p></p>
<div class="section" id="overview-context">
<h1><a class="toc-backref" href="#id67">Overview &amp; Context</a></h1>
<div class="section" id="objective">
<h2><a class="toc-backref" href="#id68">Objective</a></h2>
<p>Let's suppose we have a simulation to implement. This would be here a simulation in the field of <a class="reference external" href="https://en.wikipedia.org/wiki/Complex_systems">Complex Systems</a>: the system of interest would be described in a disaggregated way, i.e. as <strong>autonomous agents whose interactions recreate the overall behaviour and dynamics of that system</strong> <a class="footnote-reference" href="#id2" id="id1">[1]</a>.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>One can note that not all simulations are naturally described according to such a &quot;complex system&quot; scheme. For example some data-flow computations are typically best described as spreadsheets. However, if it is deemed relevant enough, a simulation engine for complex systems, even if it is certainly not the most relevant tool for that, could be entrust in order to evaluate these spreadsheet-like computations.</td></tr>
</tbody>
</table>
<p>These interactions would be <strong>event-based</strong>, rather than taking place continuously. For example, they could correspond to an incinerator notifying an operator of a burner failure, to a tramway opening its doors or to a person dialling the phone number of a friend.</p>
<p>Indeed the underlying time is <strong>discrete</strong> here, and operations last for a duration materialised by punctual state transitions, i.e. events that bear a timestamp in simulation time. If there were quantities that would be continuously changing (like the temperature of a room, depending on the time of the day), their variation would have to be discretised over time first <a class="footnote-reference" href="#id4" id="id3">[2]</a>.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>We can see here that models that would be driven mostly by differential equations (over continuous time) are not the primary targets of such simulation engines. Even if a numerical solver could be used underneath and if, in some cases, time could then be safely quantified, correctly mixing discrete-time and continuous-time models in the general case requires a very specific and advanced kind of engine, an <em>hybrid</em> one; only very few engines of this type exist (and, to the best of our knowledge, none is parallel - hence these engines may experience scalability issues). So it seems difficult to rely both on an hybrid mode of operation and on a scalable one.</td></tr>
</tbody>
</table>
<p>So let's see how easy it is to use the <a class="reference external" href="http://www.sim-diasca.com">Sim-Diasca</a> engine in order to perform such simulations of complex systems, relying for that on a simplified yet representative simulation test case.</p>
</div>
<div class="section" id="introducing-the-engine-thanks-to-a-step-by-step-example">
<h2><a class="toc-backref" href="#id69">Introducing the Engine Thanks to a Step-by-Step Example</a></h2>
<p>We will guide you here through the whole process of <strong>creating a brand new simulation of your own</strong>, here involving, for the sake of this example, customers trying to obtain soda cans from vending machines in order to relieve their thirst.</p>
<p>Let's name that mock case the <tt class="docutils literal"><span class="pre">Soda-Example</span></tt> simulation case. We will introduce also at its level some stochastic elements to showcase how they should be managed.</p>
<p>We took on purpose a very simple example coming from the everyday life rather than any domain-specific one (ex: in terms of telecom, or urban planning, or electricity), so that the reader can get familiar here only with the topics directly related to the simulation field, without having them intermingled with additional specific domains.</p>
<p>So, what does creating a simulation always entail?</p>
<ul class="simple">
<li>defining the <strong>simulation case</strong>, which is the overall description of the simulation that will rule its actual execution</li>
<li>defining the &quot;abstractions&quot; of interest in this context, i.e.:<ul>
<li>the <strong>models</strong> involved, which collectively provide a simplified representation of the target system that is to be simulated</li>
<li>the <strong>scenarios</strong> (if any) to account for the context of the target system</li>
</ul>
</li>
<li>defining the <strong>results</strong> expected from the simulation, i.e. what are the metrics that shall be collected thanks to probes, and how they should be produced</li>
</ul>
<p>Let's begin with the overall coordinator, i.e. the simulation case, before discussing more complex subjects with, notably, the models.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>This modeller guide concentrates on the <tt class="docutils literal"><span class="pre">Soda-Example</span></tt> test, which we found very useful to demonstrate various aspects of the simulation of complex systems and compare engines.</p>
<p>This case has been fully implemented, and is part of the standard Sim-Diasca distribution, shared as an archived named <tt class="docutils literal"><span class="pre">Sim-Diasca-x.y.z.tar.bz2</span></tt>.</p>
<p>On UNIX (typically GNU/Linux), one should extract it thanks to: <tt class="docutils literal">tar xvjf <span class="pre">Sim-Diasca-x.y.z.tar.bz2</span></tt>. All relative paths mentioned in that document are relative to the root of this extracted archive, i.e. <tt class="docutils literal"><span class="pre">Sim-Diasca-x.y.z</span></tt>.</p>
<p>One can thus refer to the full sources of the <tt class="docutils literal"><span class="pre">Soda-Example</span></tt> test, which are located in <tt class="docutils literal"><span class="pre">mock-simulators/soda-test</span></tt>.</p>
<p>Most of the files of interest lie in its <tt class="docutils literal">src</tt> subdirectory, so, unless specified otherwise, any file that is specific to Soda-Example will be found there. Files that relate to the engine itself are located in the <tt class="docutils literal"><span class="pre">sim-diasca</span></tt> tree of the same archive.</p>
<p class="last">Through this guide, various files will be mentioned - we strongly advise the reader to open them as they are mentioned , since it helps considerably figuring out the general layout, and understanding that there is no magic involved.</p>
</div>
<p></p>
</div>
</div>
<div class="section" id="defining-the-simulation-case">
<h1><a class="toc-backref" href="#id70">Defining the Simulation Case</a></h1>
<p>The purpose of the simulation case is to <strong>define all the settings of a virtual experiment</strong> that will be run.</p>
<p>This includes defining, for that targeted simulation:</p>
<ul class="simple">
<li>technical settings, like the properties to be enforced for this simulation (ex: reproducibility), the time-step to be used or the list of the eligible computing hosts</li>
<li>domain-specific settings, like the description of the initial state of the simulation (i.e. the model instances that exist when the simulation starts) and its various termination criteria</li>
<li>experiment settings, like the specification of the results that are expected from the simulation, i.e. what are the probes that shall be enabled, whether these results should displayed to the user, etc.</li>
</ul>
<p>Multiple experiments may apply to a given simulation (ex: the <tt class="docutils literal"><span class="pre">Soda-Example</span></tt> one), hence <strong>multiple simulation cases are generally devised</strong>. For example:</p>
<ul class="simple">
<li>there could be as many minimalist cases as there would be different models defined (ex: one case would perform a unit test of the soda vending machine, and each type of thirsty customer would have its own test case as well)</li>
<li>other simulation cases could serve to test the interactions between such a machine and a given type of customer</li>
<li>finally overall integrated cases could exist to provide the actual targeted simulation(s), with their final settings, scale, bells and whistles</li>
</ul>
<div class="section" id="where-shall-a-simulation-case-be-defined">
<h2><a class="toc-backref" href="#id71">Where Shall a Simulation Case be Defined?</a></h2>
<p>All the information relative to a simulation case are to be specified into a single file, named according to that simulation case.</p>
<p>If we were to define a test that would focus on the loading of initial instances for our <tt class="docutils literal"><span class="pre">Soda-Example</span></tt>, then we could name the corresponding simulation case <tt class="docutils literal">soda_loading_test</tt> and implement it in a text file named <tt class="docutils literal">soda_loading_test.erl</tt>.</p>
<p>The <tt class="docutils literal">.erl</tt> file extension corresponds to <a class="reference external" href="http://erlang.org">Erlang</a> source files, knowing that Sim-Diasca uses this programming language for its implementation (one may refer to <a class="reference internal" href="#just-a-bit-of-computer-science-to-better-understand-the-whole">Just A Bit of Computer Science To Better Understand The Whole</a> for more information on that topic).</p>
<p>Now is the right time to have <tt class="docutils literal">soda_loading_test.erl</tt> <a class="footnote-reference" href="#id6" id="id5">[3]</a> opened in your favorite text editor (ex: Emacs, Eclipse, etc. - preferably with a support for the highlighting of the Erlang syntax).</p>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[3]</a></td><td>As mentioned earlier, this file is located in the <tt class="docutils literal"><span class="pre">Sim-diasca-x.y.z/mock-simulators/soda-test/src</span></tt> directory.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="the-three-main-settings-records">
<h2><a class="toc-backref" href="#id72">The Three Main Settings Records</a></h2>
<p>Most of the elements mentioned in a simulation case are to be specified in predefined <a class="reference external" href="http://erlang.org/doc/programming_examples/records.html">records</a>, which are Erlang data-structures (say, to describe a <tt class="docutils literal">person</tt>) containing named fields (for example to store information about that person, like his <tt class="docutils literal">name</tt>, <tt class="docutils literal">phone</tt>, <tt class="docutils literal">address</tt>, etc.).</p>
<p>Three records play a central role in simulation cases and will have to be specified in order to initialise the engine:</p>
<ul class="simple">
<li>the <tt class="docutils literal">simulation_settings</tt> record, gathering information about the simulation itself (name, tick duration, etc.)</li>
<li>the <tt class="docutils literal">deployment_settings</tt> record, gathering information about its context of deployment and execution, knowing that Sim-Diasca is a distributed engine (ex: computing hosts potentially involved, extra elements to deploy, extra services to activate)</li>
<li>the <tt class="docutils literal">load_balancing_settings</tt> record, gathering information about how the computing resources shall be allocated to the various parts of the simulation</li>
</ul>
<p>Sensible default values are defined for most of the fields of these records. In this modeller guide, we will mainly discuss the ones that should be overridden for this example <a class="footnote-reference" href="#id8" id="id7">[4]</a>.</p>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[4]</a></td><td>For a complete description of these three records, please refer to the <em>Sim-Diasca Technical Guide</em> or directly to their definition, respectively in the following header files in the <tt class="docutils literal"><span class="pre">sim-diasca</span></tt> tree: <tt class="docutils literal">class_TimeManager.hrl</tt>, <tt class="docutils literal">class_DeploymentManager.hrl</tt> and <tt class="docutils literal">class_LoadBalancer.hrl</tt> (the <tt class="docutils literal">.hrl</tt> extension denotes Erlang header files).</td></tr>
</tbody>
</table>
<div class="section" id="simulation-settings">
<h3><a class="toc-backref" href="#id73">Simulation Settings</a></h3>
<p>Let's discuss first the <strong>technical parameters</strong> that shall be specified in various fields of the <tt class="docutils literal">simulation_settings</tt> record that you can find in <tt class="docutils literal">soda_loading_test.erl</tt>.</p>
<p>For the sake of clarity, a simulation should preferably have a <strong>name</strong> of its own - to be defined in the <tt class="docutils literal">simulation_name</tt> field. An adequate naming is convenient to discriminate more easily among runs and result sets <a class="footnote-reference" href="#id10" id="id9">[5]</a>.</p>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[5]</a></td><td>Both of them benefit from mechanisms that prevent any two simulation runs to step on each other. Names are here only to help humans!</td></tr>
</tbody>
</table>
<p>Let's forfeit any creativity and name our case <em>&quot;Sim-Diasca Initial State Loading Test&quot;</em>.</p>
<p>We must also define the duration (in virtual time) of the fundamental time step of the simulation (or its evaluation frequency), i.e. its overall <strong>tick duration</strong>. This is probably the most important setting for synchronous simulations - to be defined in the <tt class="docutils literal">tick_duration</tt> field, as a floating-point number of seconds.</p>
<p>This corresponds to the finest granularity of time that the simulation will be able to discriminate. This may relate also to how reactive the simulated world must be.</p>
<p>The models involved in a simulation have a temporality of their own (a model is not even aware of the various simulation cases that may include it) and will rely only on high level, absolute durations (in virtual time of course), expressed for example as &quot;2 hours&quot; rather than as a number of ticks.</p>
<p>As a result, models are defined regardless of the actual frequency at which simulations incorporating them will be run, i.e. irrespective of the tick duration chosen by each simulation case. This offers much flexibility to the simulations, and removes one cause of interdependence between models.</p>
<p>Of course an infinite leeway cannot be granted: ultimately, at runtime, these models will have to convert the high level durations they embed (ex: 2 hours) into a (positive) integer number of ticks, and of course the overall tick duration of the case must be fine enough in order that this quantification does not introduce too much inaccuracy <a class="footnote-reference" href="#id12" id="id11">[6]</a>.</p>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[6]</a></td><td>To anticipate a bit, the <tt class="docutils literal">Actor</tt> class provides relevant primitives for that, including <tt class="docutils literal">convert_seconds_to_ticks/2</tt>; should, at execution time, the conversion lead to a relative error greater than the default threshold, the simulation will be stopped on error. <tt class="docutils literal">convert_seconds_to_ticks/3</tt> allows the modeller to specify his own threshold, on a per-conversion basis.</td></tr>
</tbody>
</table>
<p>So, why not defining in the simulation case a very small evaluation period (tick duration), to ensure that, for all models, their embedded high-level durations will be nicely mapped to ticks?</p>
<p>Well, this is certainly possible, yet generally it forces the engine to schedule more ticks, resulting in a decrease of the performances of the simulation. Yet Sim-Diasca offers a relatively advanced scheduling (notably able to determine ticks that have no impact and jumping over them), which may mitigate that problem.</p>
<p>Anyway a reasonable trade-off must be found, and in this test case we opt for a rather fine granularity, namely a simulation frequency of 100Hz, i.e. a tick duration of 0.01 second. Most simulations will elect far longer time-steps, some of them for example opting for a yearly basis. This depends much on the application domain.</p>
<p>Another information to specify in  the <tt class="docutils literal">simulation_settings</tt> record is the <strong>results</strong> we want to obtain from the simulation. Here we will go for the simplest solution, using the default value of the <tt class="docutils literal">result_specification</tt> field, which is to retain <em>all</em> outputs. Other settings allow to filter results by probe type, or based on a series of targeted and blacklisted patterns applied to the names of the potential results <a class="footnote-reference" href="#id14" id="id13">[7]</a>.</p>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[7]</a></td><td>Please refer to the section 11.2 of the <em>Sim-Diasca Technical Manual</em> for more information, or directly to the documentation of the <tt class="docutils literal">result_specification</tt> field in the <tt class="docutils literal">class_TimeManager.hrl</tt> header.</td></tr>
</tbody>
</table>
<p>So, finally, our simulation settings (that we store here in a variable that we name, for clarity, <tt class="docutils literal">SimulationSettings</tt> - in Erlang, variable names start with a capital letter) can then simply be defined as:</p>
<pre class="code erlang literal-block">
<span class="nv">SimulationSettings</span> <span class="o">=</span> <span class="nl">#simulation_settings</span><span class="p">{</span>
  <span class="n">simulation_name</span><span class="o">=</span><span class="s">&quot;Sim-Diasca Initial State Loading Test&quot;</span><span class="p">,</span>
  <span class="n">tick_duration</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">01</span>
<span class="p">}</span>
</pre>
<p>As mentioned, two other records aggregate the rest of the technical settings.</p>
</div>
<div class="section" id="deployment-settings">
<h3><a class="toc-backref" href="#id74">Deployment Settings</a></h3>
<p>The <tt class="docutils literal">deployment_settings</tt> record allows to set precisely the <strong>computing hosts</strong> involved in the execution of that simulation case.</p>
<p>Sim-Diasca can indeed run a simulation on the user host only (the computer on which it is run), yet it is a <em>distributed</em> engine - so a single simulation can be also run on a <em>set</em> of computers (potentially dozens of nodes of a high-performance computing cluster).</p>
<p>For our simulation case to be able to run indifferently either on a single host or on multiple ones, the <tt class="docutils literal">computing_hosts</tt> field will be set to request the engine to check first whether a text file, named here <tt class="docutils literal"><span class="pre">sim-diasca-host-candidates.txt</span></tt>, can be found. The purpose of this file is to list the host names of all the potential computers that may be involved in the simulation <a class="footnote-reference" href="#id16" id="id15">[8]</a>.</p>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[8]</a></td><td>Please refer to the section 19.2 of the <em>Sim-Diasca Technical Manual</em> for its actual syntax (hostnames but also per-host usernames can be specified), or look directly to <tt class="docutils literal"><span class="pre">sim-diasca-host-candidates-sample.txt</span></tt>, to be found in the <tt class="docutils literal"><span class="pre">sim-diasca/conf</span></tt> directory.</td></tr>
</tbody>
</table>
<p>If this host file is found, the engine will look-up and try to use as many of the host candidates listed there as possible (depending on their availability and on the checking of various prerequisites).</p>
<p>If this host file is not found, or if it does not list any usable host, the case will run only locally, on the user computer.</p>
<p>So the definition for this field of the <tt class="docutils literal">deployment_settings</tt> record boils down to:</p>
<pre class="code erlang literal-block">
<span class="n">computing_hosts</span> <span class="o">=</span> <span class="p">{</span><span class="n">use_host_file_otherwise_local</span><span class="p">,</span>
                     <span class="s">&quot;sim-diasca-host-candidates.txt&quot;</span><span class="p">}</span>
</pre>
<p>That same <tt class="docutils literal">deployment_settings</tt> record is also the place where we can define <strong>the simulation elements</strong> (code and data) beyond the mere engine <strong>that shall be deployed</strong> on the computing nodes. This includes typically the binary files corresponding to the implementation of the models and scenarios <a class="footnote-reference" href="#id18" id="id17">[9]</a>, possibly with any set of data files they might rely upon.</p>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[9]</a></td><td>In a similar way as Java, Erlang sources (<tt class="docutils literal">*.erl</tt> files), possibly with their headers (<tt class="docutils literal">*.hrl</tt>), are compiled into bytecodes (<tt class="docutils literal">*.beam</tt> files) that are to be executed by a virtual machine (the Erlang VM). So Sim-Diasca starts one virtual machine per computing host (that will federate all its CPUs and all their cores) and sends over the network a compressed archive containing notably the relevant BEAM files to each of these virtual machines.</td></tr>
</tbody>
</table>
<p>Our <tt class="docutils literal"><span class="pre">Soda-Example</span></tt> case involves only a few models (ex: model of the soda vending machine, or of a type of customer) - that will be defined in the same directory as this simulation case - and no specific data, thus setting the following field accordingly will be sufficient:</p>
<pre class="code erlang literal-block">
<span class="n">additional_elements_to_deploy</span> <span class="o">=</span> <span class="p">[</span> <span class="p">{</span> <span class="s">&quot;.&quot;</span><span class="p">,</span><span class="n">code</span><span class="p">}</span> <span class="p">]</span>
</pre>
<p>This means select all code (BEAM files) recursively found from the current directory (<tt class="docutils literal">&quot;.&quot;</tt>, i.e. <tt class="docutils literal"><span class="pre">mock-simulators/soda-test/src</span></tt> here) and add it to the deployment archive.</p>
<p>Still in the <tt class="docutils literal">deployment_settings</tt> record, other parameters can be set (ex: <tt class="docutils literal">node_availability_tolerance</tt>) and other services can be activated (ex: <tt class="docutils literal">enable_data_exchanger</tt>, <tt class="docutils literal">enable_performance_tracker</tt>), yet the <tt class="docutils literal"><span class="pre">Soda-Example</span></tt> case can do without them. So for this record, which we choose to store in a variable named <tt class="docutils literal">DeploymentSettings</tt>, we finally end up with the following definition:</p>
<pre class="code erlang literal-block">
<span class="nv">DeploymentSettings</span> <span class="o">=</span> <span class="nl">#deployment_settings</span><span class="p">{</span>
    <span class="n">computing_hosts</span> <span class="o">=</span> <span class="p">{</span><span class="n">use_host_file_otherwise_local</span><span class="p">,</span>
                   <span class="s">&quot;sim-diasca-host-candidates.txt&quot;</span><span class="p">},</span>
    <span class="n">additional_elements_to_deploy</span> <span class="o">=</span> <span class="p">[</span> <span class="p">{</span><span class="s">&quot;.&quot;</span><span class="p">,</span><span class="n">code</span><span class="p">}</span> <span class="p">]</span>
<span class="p">}</span>
</pre>
<p>Again: long to explain, very short to specify!</p>
</div>
<div class="section" id="load-balancing-settings">
<h3><a class="toc-backref" href="#id75">Load Balancing Settings</a></h3>
<p>As there is no specific measure to be taken regarding load balancing here, the corresponding record will be used with all its default values set (no field specifically overridden).</p>
<p>We name our variable consistently with the two previous ones, for clarity, so we have:</p>
<pre class="code erlang literal-block">
<span class="nv">LoadBalancingSettings</span> <span class="o">=</span> <span class="nl">#load_balancing_settings</span><span class="p">{}</span>
</pre>
<p>As a result we now have determined the three key records (regarding simulation, deployment and load balancing) that will allow to initialise the engine. That will be done simply thanks to:</p>
<pre class="code erlang literal-block">
<span class="nv">DeploymentManagerPid</span> <span class="o">=</span> <span class="nn">sim_diasca</span><span class="p">:</span><span class="nf">init</span><span class="p">(</span><span class="nv">SimulationSettings</span><span class="p">,</span>
           <span class="nv">DeploymentSettings</span><span class="p">,</span><span class="nv">LoadBalancingSettings</span><span class="p">)</span>
</pre>
<p>This shall be read as:</p>
<ul class="simple">
<li>we have a module named <tt class="docutils literal">sim_diasca</tt></li>
<li>which exports a function named <tt class="docutils literal">init</tt></li>
<li>that takes three parameters (our three records)</li>
<li>and returns a value, stored in a variable that we named <tt class="docutils literal">DeploymentManagerPid</tt></li>
</ul>
<p>We say that the <em>arity</em> (number of parameters) of this function is 3, and that its full name is <tt class="docutils literal">sim_diasca:init/3</tt>.</p>
<p>The returned value is a <tt class="docutils literal">PID</tt>, an Erlang shorthand for <em>process identifier</em>. Knowing the PID of a process allows to send messages to it; here we will then be able to send messages to the deployment manager of the engine, from the simulation case.</p>
<p>In Erlang, one can optionally specify the signature of a function, i.e. the types of its parameters and of its returned value.</p>
<p>Such a <em>type specification</em> clarifies the code and the developer's intent, and allows some <a class="reference external" href="http://erlang.org/doc/man/dialyzer.html">static type checking tools</a> to perform more in-depth verifications.</p>
<p>Here this would be a pretty self-explanatory specification <a class="footnote-reference" href="#id20" id="id19">[10]</a>:</p>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">spec</span> <span class="nn">sim_diasca</span><span class="p">:</span><span class="nf">init</span><span class="p">(</span><span class="n">simulation_settings</span><span class="p">(),</span><span class="n">deployment_settings</span><span class="p">(),</span>
              <span class="n">load_balancing_settings</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="n">pid</span><span class="p">().</span>
</pre>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[10]</a></td><td>One may refer to <a class="reference external" href="http://erlang.org/doc/reference_manual/typespec.html">Types and Function Specifications</a> for more information. <tt class="docutils literal"><span class="pre">-spec</span></tt> is to be used for functions, while <tt class="docutils literal"><span class="pre">-type</span></tt> is to be used for terms (i.e., values). For example, <tt class="docutils literal"><span class="pre">-type</span> age() :: <span class="pre">integer().</span></tt> tells that a variable of type <tt class="docutils literal">age</tt> is an integer.</td></tr>
</tbody>
</table>
<p>Let's continue now the simulation specification by its heart: the models.</p>
<p></p>
</div>
</div>
</div>
<div class="section" id="defining-the-models">
<h1><a class="toc-backref" href="#id76">Defining the Models</a></h1>
<div class="section" id="general-outline">
<h2><a class="toc-backref" href="#id77">General Outline</a></h2>
<p>Here we will focus on a <tt class="docutils literal"><span class="pre">Soda-Example</span></tt> simulation in which there would be:</p>
<ul class="simple">
<li>two kinds of thirsty customers, whose repletion duration <a class="footnote-reference" href="#id22" id="id21">[11]</a> obey different rules</li>
<li>a single sort of soda vending machine, selling a single sort of soda</li>
</ul>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id21">[11]</a></td><td>Defined as the duration after which their thirst reappears once having been extinguished (i.e. once having drunk a soda can).</td></tr>
</tbody>
</table>
<p>Hence we have here three different <strong>models</strong>. All other elements (the outside world, the floor, the room, the other persons, the electric supply, the cans themselves, etc.) are considered as irrelevant for this study, and thus are abstracted out (i.e. they will not be represented explicitly in the simulation, short of influencing it).</p>
<p>Of course, for a given model (which can be seen as a description of a type, i.e. an abstract blueprint), any number of <strong>actual instances</strong>  may exist, each with its own, individual state and fate. A shorthand for <em>model instance</em> that will be used from now is <em>actor</em>.</p>
<p>As always, several instances of these models (i.e. several simulation actors) must be able to interact gracefully with respect to the simulation expected properties in order to produce its expected outcome, i.e. the simulation <strong>results</strong> that were requested by the user.</p>
<p>For this simulation we consider that the results that we are interested in are the stock of cans that each vending machine holds over time.</p>
<p>We thus want to obtain from the simulation a time series for each machine stock (as a data file), and its corresponding plot (as an image). Both of them will be produced by probes (one probe per vending machine).</p>
<p>As there is no refill of the machines modelled, we would expect the stocks to steadily decrease over simulation time.</p>
<p>Let's ensure first that we will be able to create the model instances we need.</p>
</div>
<div class="section" id="construction-parameters">
<h2><a class="toc-backref" href="#id78">Construction Parameters</a></h2>
<p>Having a simulation requires to define, among other elements, its initial situation, i.e. what are the model instances that exist when the simulation is to begin.</p>
<p>To do so, we need to be able to define, for each model, how many instances must exist from the start <a class="footnote-reference" href="#id24" id="id23">[12]</a>, and in which state they are initially.</p>
<table class="docutils footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id23">[12]</a></td><td>Any simulation must have at least one initial actor. Of course, in the general case, actors may also be created (and deleted) in the course of the simulation.</td></tr>
</tbody>
</table>
<p>For that, a model has to define at least one <strong>constructor</strong>, which is a function (named <tt class="docutils literal">construct</tt>) that translates a set of construction parameters into an actual instance of this model, created from them <a class="footnote-reference" href="#id26" id="id25">[13]</a>.</p>
<table class="docutils footnote" frame="void" id="id26" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id25">[13]</a></td><td><p class="first">Constructors are essential to preserve <em>encapsulation</em>, i.e. to ensure that the inner implementation of a model remains private to this model.</p>
<p>Indeed, if, instead of relying on a constructor, the initial state of an actor could be directly set from outside, then the code creating instances of a model would have to know how the state of this model is structured. As a result, that code would depend on the implementation of this model, and a change in the model would propagate to the code using it.</p>
<p class="last">On the contrary, constructors allow for a better uncoupling: should the model implementation be updated (then probably impacting how its state is defined), it may require only a change in <em>how</em> its constructor is implemented (construction parameters being then translated differently) - while the interface of that constructor would not change, and then would not impact the code outside of this model.</p>
</td></tr>
</tbody>
</table>
<div class="section" id="construction-parameters-for-a-soda-vending-machine">
<h3><a class="toc-backref" href="#id79">Construction Parameters for a Soda Vending Machine</a></h3>
<p>We will suppose here that a given soda vending machine instance can be created from following construction parameters:</p>
<ul class="simple">
<li>its <strong>name</strong>, as a character string (ex: <tt class="docutils literal">&quot;My soda machine&quot;</tt>) <a class="footnote-reference" href="#id30" id="id27">[14]</a> - a type designated as <tt class="docutils literal">string()</tt></li>
<li>the <strong>number of soda cans it stores initially</strong>, as a positive integer (ex: 100), of type <tt class="docutils literal">can_count()</tt> <a class="footnote-reference" href="#id31" id="id28">[15]</a></li>
<li>the <strong>unitary cost of the soda cans</strong> that it sells, as a floating-point cost in euro (ex: 1.2 euro per can), of type <tt class="docutils literal">amount()</tt> <a class="footnote-reference" href="#id32" id="id29">[16]</a></li>
</ul>
<table class="docutils footnote" frame="void" id="id30" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id27">[14]</a></td><td>Naming instances is useful to help understanding the results and the simulation traces that they may produce.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id31" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id28">[15]</a></td><td>Defined in this case as <tt class="docutils literal"><span class="pre">-type</span> can_count() :: <span class="pre">basic_utils:count().</span></tt>, i.e. a positive integer.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id32" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id29">[16]</a></td><td>Defined in this case as <tt class="docutils literal"><span class="pre">-type</span> amount() :: <span class="pre">float().</span></tt>, i.e. a floating-point number.</td></tr>
</tbody>
</table>
<p>These three construction parameters will be enough to create any instance of vending machine. Note that we have no idea yet of how the state of a vending machine will be structured - that is the point of using construction parameters.</p>
</div>
<div class="section" id="construction-parameters-for-a-thirsty-customer">
<h3><a class="toc-backref" href="#id80">Construction Parameters for a Thirsty Customer</a></h3>
<p>As for customers, we mentioned that in our simulation there were two kinds of them; indeed we consider that there are:</p>
<ul class="simple">
<li>&quot;deterministic&quot; customers, which are thirsty again after a constant duration (ex: 15 minutes after having drunk)</li>
<li>&quot;stochastic&quot; customers, whose repletion duration is determined by a random law in order to illustrate their use (ex: the duration will be drawn from an exponential law of rate parameter <tt class="docutils literal">lambda=2.2</tt>)</li>
</ul>
<p>So a <strong>deterministic thirsty customer</strong> instance can be defined from following construction parameters:</p>
<ul class="simple">
<li>his <strong>name</strong>, as a character string (ex: <tt class="docutils literal">&quot;John&quot;</tt>) - a <tt class="docutils literal">string()</tt></li>
<li>the <strong>vending machine he knows</strong>, as an instance reference <a class="footnote-reference" href="#id35" id="id33">[17]</a> - a type designated as <tt class="docutils literal">class_Actor:actor_pid()</tt>, which is actually an alias for <tt class="docutils literal">pid()</tt>; we see here that we consider that such a customer knows exactly one vending machine - neither none, nor multiple ones (we would have defined in this case a list of PIDs)</li>
<li>his <strong>repletion duration</strong>, i.e. how soon, after having drunk a soda can, he will feel thirsty again (ex: exactly 2 minutes - he is deterministic), of type <tt class="docutils literal">duration()</tt> <a class="footnote-reference" href="#id36" id="id34">[18]</a></li>
<li>his <strong>budget</strong>, i.e. how much money he initially has in his pocket (ex: <tt class="docutils literal">35.0 euros</tt>) - of type <tt class="docutils literal">amount()</tt></li>
</ul>
<table class="docutils footnote" frame="void" id="id35" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id33">[17]</a></td><td>An instance must know another instance (&quot;have a reference onto it&quot;) in order to interact with it (&quot;send a message to it&quot;). Technically, a reference onto another model instance is named here an <tt class="docutils literal">Actor PID</tt>, or <tt class="docutils literal">PID</tt> (shorthand for <em>Process Identifier</em>, of type <tt class="docutils literal">pid()</tt>). Actually we have <tt class="docutils literal"><span class="pre">-type</span> class_Actor:actor_pid() :: pid()</tt>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id36" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id34">[18]</a></td><td>Defined in this case as <tt class="docutils literal"><span class="pre">-type</span> duration() :: <span class="pre">unit_utils:minutes().</span></tt></td></tr>
</tbody>
</table>
<p>So a deterministic thirsty customer will require these four parameters in order to be created.</p>
<p>Finally, a <strong>stochastic thirsty customer</strong> will be constructed quite similarly, except that its repletion duration will not be specified as a constant, but as a random law. For example his repletion duration in minutes could be drawn from a Gaussian law whose mean is 10, and variance is 2.</p>
<p>Its constructor shall thus reflect this: the repletion duration that had to be set for the deterministic customer is replaced, in the construction parameters of the stochastic one, by a random law, of type <tt class="docutils literal">class_RandomManager:random_law()</tt> <a class="footnote-reference" href="#id38" id="id37">[19]</a>.</p>
<table class="docutils footnote" frame="void" id="id38" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id37">[19]</a></td><td>Defined in <tt class="docutils literal">class_RandomManager.erl</tt>.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="from-construction-parameters-to-constructors">
<h3><a class="toc-backref" href="#id81">From Construction Parameters To Constructors</a></h3>
<p>Now that we have specified the construction parameters that will be used, we will have to define in later steps how the state of these models will be stored.</p>
<p>Then only we will be able to define their constructors, which are the functions that convert the former (the construction parameters) into the latter (the initial state of the corresponding models).</p>
<p>But, for that, the implementation must be better known: the structure of the state of the model will have to be determined first.</p>
<p></p>
</div>
</div>
<div class="section" id="implementation-files">
<h2><a class="toc-backref" href="#id82">Implementation Files</a></h2>
<div class="section" id="just-a-bit-of-computer-science-to-better-understand-the-whole">
<h3><a class="toc-backref" href="#id83">Just A Bit of Computer Science To Better Understand The Whole</a></h3>
<div class="section" id="id39">
<h4>Erlang</h4>
<p>Sim-Diasca is developed in the <a class="reference external" href="http://erlang.org">Erlang</a> programming language. This <a class="reference external" href="https://en.wikipedia.org/wiki/Functional_programming">functional</a> and <a class="reference external" href="https://en.wikipedia.org/wiki/Concurrency_%28computer_science%29">concurrent</a> language is a very good fit for problems that can be solved thanks to a (possibly large) number of autonomous logical processes running in a parallel and, possibly, distributed way (i.e. respectively able to take advantage of multiple core and processors, and of multiple networked computers).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Have no fear, though: using Sim-Diasca does not require any knowledge about parallelism, as it is fully hidden by the engine, and models are to be written in a simple, fully sequential setting.</p>
<p class="last">So the purpose of these more technical explanations is only to give to the modellers a better view of the mechanisms involved underneath, as dealing with black boxes may be uncomfortable.</p>
</div>
<p>In a few words, an Erlang program is made of several (Erlang) processes that run concurrently and that communicate between them solely through the sending of asynchronous (non-blocking) messages.</p>
</div>
<div class="section" id="wooper">
<h4>WOOPER</h4>
<p>Erlang thus provides an excellent <strong>multi-agent platform</strong>, on top of which we added a thin layer named <a class="reference external" href="http://ceylan.sourceforge.net/main/documentation/wooper/">WOOPER</a>, which provides the language with <strong>object-oriented capabilities</strong>: WOOPER allows to define <em>classes</em> that can inherit from others (ex: the <tt class="docutils literal">Cat</tt> class is a specialisation of the <tt class="docutils literal">Animal</tt> class), whose state is defined thanks to a set of attributes (ex: a cat may have an <tt class="docutils literal">age</tt> attribute, of type positive integer, and a <tt class="docutils literal">name</tt> attribute, of type string), and that can define methods (i.e. class-specific, parametrised signals that a class instance can receive and that will trigger operations based on its state ; ex: <tt class="docutils literal">getAge/1</tt>, <tt class="docutils literal">meow/1</tt>, <tt class="docutils literal">declareBirthday/2</tt>).</p>
</div>
<div class="section" id="id42">
<h4>Sim-Diasca</h4>
<p>Sim-Diasca has then been added on top of WOOPER, turning a concurrent, object-oriented multi-agent platform into a <strong>simulation engine</strong> for complex systems: the general simulation infrastructure has been defined (ex: simulation cases, models, scenarios, probes), and key services have been implemented (like scheduling, interaction support, instance life cycle, loading of the initial state, trace management, result management, deployment, load-balancing).</p>
<p>The engine takes care of the full technical plumbing needed (ex: proper reordering of the actor messages so that simulation properties are respected), hence Sim-Diasca users just have to comply with the engine's conventions and define their domain-specific simulation elements.</p>
<p>As a result, models can be defined based on a very small, simple subset of the Erlang language. Each model will be a child class <a class="footnote-reference" href="#id44" id="id43">[20]</a> of the <tt class="docutils literal">class_Actor</tt> abstract class. Typically each model will define the attributes that make up for its state, the actor methods it supports, and at least one constructor. Of course a given model can inherit from another, allowing for a flexible model hierarchy.</p>
<table class="docutils footnote" frame="void" id="id44" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id43">[20]</a></td><td>Be it a direct child class or not: indeed a model may inherit from other model(s) that will themselves inherit, ultimately, of <tt class="docutils literal">class_Actor</tt>.</td></tr>
</tbody>
</table>
<p>These models will then be able to take part to the simulations of interest.</p>
</div>
</div>
<div class="section" id="in-practice-for-our-soda-example-case">
<h3><a class="toc-backref" href="#id84">In Practice For Our Soda-Example Case</a></h3>
<p>As we have seen, three models will be needed. They will thus be implemented in three corresponding classes:</p>
<ul class="simple">
<li>the <tt class="docutils literal">SodaVendingMachine</tt> model will be implemented as <tt class="docutils literal">class_SodaVendingMachine</tt>, specified in the <tt class="docutils literal">class_SodaVendingMachine.erl</tt> file</li>
<li>the <tt class="docutils literal">DeterministicThirstyCustomer</tt> model will similarly be implemented in the <tt class="docutils literal">class_DeterministicThirstyCustomer.erl</tt> file</li>
<li>and of course the <tt class="docutils literal">StochasticThirstyCustomer</tt> model will be in the <tt class="docutils literal">class_StochasticThirstyCustomer.erl</tt> file</li>
</ul>
<p>(as mentioned, all these files are to be found in the <tt class="docutils literal"><span class="pre">mock-simulators/soda-test/src</span></tt> directory)</p>
<p>The <tt class="docutils literal">class_</tt> prefix is mandatory to specify that we are defining a WOOPER class (and not a basic Erlang module), and, as mentioned previously, the <tt class="docutils literal">.erl</tt> file extension corresponds to Erlang source files (i.e. that contains the Erlang code corresponding to the module of the same name).</p>
<p>We can see that each model will be defined separately from the others, and that it will be contained in a single, standalone source file.</p>
<p>For the sake of this simple test case, none of these models will inherit from others: all three will be direct child classes of the <tt class="docutils literal">class_Actor</tt> abstract class.</p>
<p>A slightly more complex alternative would have been to define an abstract <tt class="docutils literal">ThirstyCustomer</tt> model directly deriving from <tt class="docutils literal">Actor</tt>, from which <tt class="docutils literal">DeterministicThirstyCustomer</tt> and <tt class="docutils literal">StochasticThirstyCustomer</tt> would have then derived.</p>
<p>As we can see, there are often multiple ways of modelling the same target system. We chose the simplest here.</p>
<p></p>
</div>
</div>
<div class="section" id="initial-state-of-the-simulation">
<h2><a class="toc-backref" href="#id85">Initial State of the Simulation</a></h2>
<p>Of course an engine cannot guess what the initial content of the simulation will be (it will simply start from it, and make it evolve until reaching a termination criterion), so we have somehow to specify the initial simulation state. This information is to be specified in the simulation case.</p>
<p>Two methods are available for that: either we create initial instances thanks to code, or thanks to data.</p>
<div class="section" id="creating-initial-instances-programmatically">
<h3><a class="toc-backref" href="#id86">Creating Initial Instances Programmatically</a></h3>
<p>For this test case, we want following basic initial setting to be simulated:</p>
<ul class="simple">
<li>there will two soda vending machines (referenced as SVM1 and SVM2)</li>
<li>there will three thirsty customers: TC1 and TC2, who will be both using SVM1, and TC3, who will use SVM2; TC1 and TC3 shall be deterministic customers, while TC2 will be a stochastic one</li>
</ul>
<p>This corresponds to the following setting:</p>
<p><span class="raw-html"><center><img src="deterministic-test-instances.png" id="responsive-image-tiny"></img></center></span>
</p>
<p>This is a fairly simple simulation, where no actor is created or deleted in its course. So it will begin and end with exactly the same five model instances (but f course their respective state will change over the simulation).</p>
<p>These instances will be created programatically in this example: the simulation case will explicitly create them, by code, one by one.</p>
<p>Actually, even if the implementation of the models is not known yet, we can already determine the corresponding snippet that will be part of the simulation case in order to create the expected initial instances.</p>
<p>We must just know that:</p>
<ul class="simple">
<li>initial instances must be created by using the <tt class="docutils literal">class_Actor:create_initial_actor/2</tt> static method, whose first parameter is the name of the class of the instance to create (ex: <tt class="docutils literal">class_Incinerator</tt>), and whose second one is the (ordered) list of the construction parameters for that upcoming instance</li>
<li>in Erlang:<ul>
<li>comments start with the <tt class="docutils literal">%</tt> character</li>
<li>as mentioned, a variable name starts with a capital letter (ex: <tt class="docutils literal">MyVariable</tt>) but prefixing it by an underscore (ex: <tt class="docutils literal">_MyVariable</tt>) makes it a mute variable, i.e. a variable that will be ignored by the compiler - so specifying it just serves documentation purposes</li>
<li>a list is denoted by brackets, and may not be homogeneous (ex: <tt class="docutils literal"><span class="pre">MyList=[&quot;hello&quot;,42]</span></tt>)</li>
</ul>
</li>
</ul>
<p>These programmatic creations translate as:</p>
<pre class="code erlang literal-block">
<span class="c">% First machine starts with 100 cans, 2 euros each:
</span><span class="nv">SVM1</span> <span class="o">=</span> <span class="nn">class_Actor</span><span class="p">:</span><span class="nf">create_initial_actor</span><span class="p">(</span> <span class="n">class_SodaVendingMachine</span><span class="p">,</span>
    <span class="p">[</span> <span class="p">_</span><span class="nv">FirstMachineName</span><span class="o">=</span><span class="s">&quot;First soda machine&quot;</span><span class="p">,</span> <span class="p">_</span><span class="nv">FirstInitialCanCount</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
      <span class="p">_</span><span class="nv">FirstCanCost</span><span class="o">=</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="p">]</span> <span class="p">),</span>

<span class="c">% Second machine starts with 8 cans, 1.15 euro each:
</span><span class="nv">SVM2</span> <span class="o">=</span> <span class="nn">class_Actor</span><span class="p">:</span><span class="nf">create_initial_placed_actor</span><span class="p">(</span> <span class="n">class_SodaVendingMachine</span><span class="p">,</span>
    <span class="p">[</span> <span class="p">_</span><span class="nv">SecondMachineName</span><span class="o">=</span><span class="s">&quot;Second soda machine&quot;</span><span class="p">,</span> <span class="p">_</span><span class="nv">SecondInitialCanCount</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
      <span class="p">_</span><span class="nv">SecondCanCost</span><span class="o">=</span><span class="mi">1</span><span class="p">.</span><span class="mi">15</span> <span class="p">],</span> <span class="p">_</span><span class="nv">PlacementHint</span><span class="o">=</span><span class="n">gimme_some_shelter</span> <span class="p">),</span>

<span class="c">% First customer is deterministic, uses SVM1, is thirsty 2 minutes
% after having drunk, and has 35 euros in his pockets:
</span><span class="p">_</span><span class="nv">TC1</span> <span class="o">=</span> <span class="nn">class_Actor</span><span class="p">:</span><span class="nf">create_initial_actor</span><span class="p">(</span>
  <span class="n">class_DeterministicThirstyCustomer</span><span class="p">,</span>
  <span class="p">[</span> <span class="p">_</span><span class="nv">FirstCustomerName</span><span class="o">=</span><span class="s">&quot;John&quot;</span><span class="p">,</span> <span class="p">_</span><span class="nv">FirstKnownMachine</span><span class="o">=</span><span class="nv">SVM1</span><span class="p">,</span>
    <span class="p">_</span><span class="nv">FirstRepletionDuration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="p">_</span><span class="nv">FirstInitialBudget</span><span class="o">=</span><span class="mi">35</span><span class="p">.</span><span class="mi">0</span> <span class="p">]</span> <span class="p">),</span>

<span class="c">% Second customer uses SVM1 too, yet is stochastic: he will be thirsty
% again between 1 and 7 minutes after having drunk, and has 40 euros in
% his pockets initially:
</span><span class="p">_</span><span class="nv">TC2</span> <span class="o">=</span> <span class="nn">class_Actor</span><span class="p">:</span><span class="nf">create_initial_actor</span><span class="p">(</span> <span class="n">class_StochasticThirstyCustomer</span><span class="p">,</span>
  <span class="p">[</span> <span class="p">_</span><span class="nv">SecondCustomerName</span><span class="o">=</span><span class="s">&quot;Terry&quot;</span><span class="p">,</span> <span class="p">_</span><span class="nv">SecondKnownMachine</span><span class="o">=</span><span class="nv">SVM1</span><span class="p">,</span>
    <span class="p">_</span><span class="nv">SecondRepletionLaw</span><span class="o">=</span><span class="p">{</span> <span class="n">uniform</span><span class="p">,</span> <span class="mi">7</span> <span class="p">},</span> <span class="p">_</span><span class="nv">SecondInitialBudget</span><span class="o">=</span><span class="mi">40</span><span class="p">.</span><span class="mi">0</span> <span class="p">]</span> <span class="p">),</span>

<span class="c">% Third customer uses SVM2, is deterministic and thirsty 2 minutes
% after having drunk, and has 77 euros in his pockets:
</span><span class="p">_</span><span class="nv">TC3</span> <span class="o">=</span> <span class="nn">class_Actor</span><span class="p">:</span><span class="nf">create_initial_actor</span><span class="p">(</span>
  <span class="n">class_DeterministicThirstyCustomer</span><span class="p">,</span>
  <span class="p">[</span> <span class="p">_</span><span class="nv">ThirdCustomerName</span><span class="o">=</span><span class="s">&quot;Michael&quot;</span><span class="p">,</span> <span class="p">_</span><span class="nv">ThirdKnownMachine</span><span class="o">=</span><span class="nv">SVM2</span><span class="p">,</span>
    <span class="p">_</span><span class="nv">ThirdRepletionDuration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="p">_</span><span class="nv">ThirdInitialBudget</span><span class="o">=</span><span class="mi">77</span><span class="p">.</span><span class="mi">0</span> <span class="p">]</span> <span class="p">),</span>
</pre>
<p>Scrupulous readers noticed that the creation of <tt class="docutils literal">SVM2</tt> actually relies on a variation of <tt class="docutils literal">class_Actor:create_initial_actor/2</tt>.</p>
<p>This static method, named <tt class="docutils literal">class_Actor:create_initial_placed_actor/3</tt>, takes an extra parameter: a placement hint. The engine will ensure that all instances created with the same hint (here, the <tt class="docutils literal">gimme_some_shelter</tt> atom <a class="footnote-reference" href="#id46" id="id45">[21]</a>) will be co-allocated, i.e. created on the same computing node (whichever it is).</p>
<p>This allows to deliver locally the numerous messages they exchange, which is a lot more efficient than sending them through a network.</p>
<p>Thus a user knowing that by design a set of instances will be tightly coupled (for example, models of a modern human being and of his beloved smartphone) is able to have them co-allocated for best performances, irrespective of how the simulation case, depending on each simulation run, will be later dispatched on a set of networked computing nodes.</p>
<p>Here, at least another initial instance should be created with <tt class="docutils literal">gimme_some_shelter</tt> for this hint to be useful.</p>
<table class="docutils footnote" frame="void" id="id46" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id45">[21]</a></td><td>An <a class="reference external" href="http://erlang.org/doc/reference_manual/data_types.html#id64703">atom</a> is an Erlang datatype that allows to define a symbolic constant. Typically an atom begins with a lower-case letter (as opposed to variables). Ex: <tt class="docutils literal">hello</tt> and <tt class="docutils literal">class_Cat</tt> are atoms.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="creating-initial-instances-from-a-data-stream">
<h3><a class="toc-backref" href="#id87">Creating Initial Instances From a Data Stream</a></h3>
<p>Of course &quot;real&quot; simulations tend to be far more demanding than the previous case relying on five actors, and may involve literally millions of model instances.</p>
<p>It would be unlikely that such a large number of actors be created programmatically; instead these actors should preferably be instantiated from a data stream, typically a text file.</p>
<p>Sim-Diasca provides a simple, compact, flexible format to do so; as always, initial creations are to be triggered from the simulation case.</p>
<p>In a few words, remembering that the construction parameters of a soda-vending machine are <tt class="docutils literal">[MachineName,InitialCanCount,CanCost]</tt>, creating such a machine would just boil down to having, in said data file, a line like:</p>
<pre class="code erlang literal-block">
<span class="p">{</span> <span class="n">class_SodaVendingMachine</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;Machine #1 read from data&quot;</span><span class="p">,</span>
                              <span class="mi">45</span><span class="p">,</span><span class="mi">1</span><span class="p">.</span><span class="mi">5</span><span class="p">]</span> <span class="p">}.</span>
</pre>
<p>If wanting to be able, in another point of the data stream, to refer to an initial instance, then its creation shall be prefixed by the specification of a <em>user identifier</em> (<tt class="docutils literal">&quot;My second machine&quot;</tt> here), like in:</p>
<pre class="code erlang literal-block">
<span class="s">&quot;My second machine&quot;</span> <span class="o">&lt;-</span> <span class="p">{</span> <span class="n">class_SodaVendingMachine</span><span class="p">,</span>
                            <span class="p">[</span><span class="s">&quot;Machine #2&quot;</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">.</span><span class="mi">4</span><span class="p">]</span> <span class="p">}.</span>
</pre>
<p>Then other initial instances could refer to that instance (i.e. know it at construction time), like in:</p>
<pre class="code erlang literal-block">
<span class="p">{</span> <span class="n">class_DeterministicThirstyCustomer</span><span class="p">,</span> <span class="p">[</span> <span class="s">&quot;Cresus&quot;</span><span class="p">,</span>
  <span class="p">{</span><span class="n">user_id</span><span class="p">,</span><span class="s">&quot;My second machine&quot;</span><span class="p">},</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">16000</span><span class="p">.</span><span class="mi">0</span> <span class="p">]</span> <span class="p">}.</span>
</pre>
<p>Here, remembering that the construction parameters of a deterministic thirsty customer are <tt class="docutils literal">[CustomerName,KnownMachinePid,RepletionDuration,InitialBudget]</tt>, the customer named <tt class="docutils literal">Cresus</tt> would detain a reference (translated into a PID at construction time) onto the vending machine named <tt class="docutils literal">Machine #2</tt>.</p>
<p>As a result, the customer will be able to interact with the machine from the simulation start (since it will know the PID of this machine). Until it has done so (thus letting the machine knows about its own PID), the machine will not be aware of him (as here, by design, it has no means of knowing that customer).</p>
<p>In such an initialisation data stream, the order of the lines does not matter, cyclic references are supported (so we could define two actors mutually aware of the other), and comments (lines starting with <tt class="docutils literal">%</tt>) and blank lines are ignored.</p>
<p>One may refer to the <tt class="docutils literal"><span class="pre">soda-instances.init</span></tt> data file as a full example.</p>
<p>For a simulation case to read initial instances from such an initialisation file, the corresponding filename must be listed in the <tt class="docutils literal">initialisation_files</tt> field of the <tt class="docutils literal">simulation_settings</tt> record, like in:</p>
<pre class="code erlang literal-block">
<span class="p">[...]</span>
<span class="nv">SimulationSettings</span> <span class="o">=</span> <span class="nl">#simulation_settings</span><span class="p">{</span>
  <span class="p">[...]</span>
  <span class="n">initialisation_files</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;soda-instances.init&quot;</span><span class="p">]</span>
  <span class="p">[...]</span>
<span class="p">},</span>
<span class="p">[...]</span>
</pre>
<p>One may refer to the section 10.3 of the <em>Sim-Diasca Technical Manual</em> for more information about instance creation.</p>
</div>
<div class="section" id="what-about-scenarios">
<h3><a class="toc-backref" href="#id88">What About Scenarios?</a></h3>
<p>Instance creation has been discussed, and we saw how actors (model instances) shall be created.</p>
<p>As mentioned in our mini-ontology about simulation (see chapter 3 of the <em>Sim-Diasca Technical Manual</em>), the overall simulated world is the union of the target system and of its context.</p>
<p>While the target system as a whole (ex: a city) is described based on the various models involved (ex: buildings, roads, people), in a simulation this target system might have to be evaluated on par with a <strong>context</strong> that may interact with it (ex: the country surrounding that city, the weather system over its districts, the mayor and his team).</p>
<p>How shall this context be described, initialised and evaluated then? The good news is that if, semantically, the target system and its context are different, technically they have to be managed the same, notably to preserve simulation properties.</p>
<p>Knowing that the context is made of <strong>scenarios</strong> exactly like the target system is made of models, creating the context (which, in the general case, can be disaggregated, can have a state, can interact with its parts and with the target system) is to be done exactly as shown previously with the models.</p>
<p>So multiple scenarios may apply (ex: regarding weather, pollution, population) and multiple instances of them can coexist concurrently (ex: one weather cell per spatial subdivision of the city).</p>
<p>For example, like we defined <tt class="docutils literal">class_SodaVendingMachine</tt> we could define <tt class="docutils literal">class_CanCostScenario</tt>, an horrible scenario that would reproduce a creeping inflation and would make the price of soda cans steadily increase over time.</p>
<p>An instance of such scenario would be created from two construction parameters, the (supposedly constant) monthly cost increase (ex: 7%, hence <tt class="docutils literal">0.07</tt>) and the list of the soda vending machines that would be affected by this inflation.</p>
<p>Then, taking a programmatic creation as an example, we could have:</p>
<pre class="code erlang literal-block">
<span class="p">_</span><span class="nv">SC</span> <span class="o">=</span> <span class="nn">class_Actor</span><span class="p">:</span><span class="nf">create_initial_actor</span><span class="p">(</span> <span class="n">class_CanCostScenario</span><span class="p">,</span>
    <span class="p">[</span> <span class="p">_</span><span class="nv">MonthlyRate</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">07</span><span class="p">,</span> <span class="p">_</span><span class="nv">VendingMachines</span><span class="o">=</span><span class="p">[</span><span class="nv">SVM1</span><span class="p">,</span><span class="nv">SVM37</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span>
</pre>
<p>We can thus see that nothing more than models is to be learned in order to manage scenarios, since they are technically the same beast. As hinted by the static method used here, which is defined in the context of the <tt class="docutils literal">Actor</tt> class, the engine does not even make a difference between models and scenarios.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Implementing such a <tt class="docutils literal">CanCostScenario</tt> scenario is left as an exercise for the reader.</p>
<p>This would include going through the same steps as for the models that we will implement here (defining state, behaviour, etc.), notably defining the interactions between a cost scenario and the vending machines that it drives.</p>
<p class="last">For example, the specification could dictate that each month the scenario would notify each machine it knows that its can cost increased, here, of 7%, compared to the previous month.</p>
</div>
</div>
<div class="section" id="instanciation-example">
<h3><a class="toc-backref" href="#id89">Instanciation Example</a></h3>
<p>Of course the two approaches (programmatic/data-based) for instance creation can be mixed. One may refer to our simulation case of interest here (<tt class="docutils literal">soda_loading_test.erl</tt>) that creates 5 initial actors thanks to code, and 9 others thanks to the <tt class="docutils literal"><span class="pre">soda-instances.init</span></tt> data file it refers to (in its <tt class="docutils literal">initialisation_files</tt> field).</p>
<p>So we started the work on the models by establishing their construction parameters, in order that the initial state of the simulation could be defined, in the simulation case.</p>
<p>As now this case is almost complete, let's discuss the last few bits necessary to the implementation of a case, before continuing the work on the models.</p>
</div>
</div>
<div class="section" id="wrapping-up-the-simulation-case">
<h2><a class="toc-backref" href="#id90">Wrapping-Up the Simulation Case</a></h2>
<p>Now the engine is correctly initialised (thanks to the three aforementioned settings) and the initial state is defined. What remains to be specified then?</p>
<div class="section" id="initial-time-and-date">
<h3><a class="toc-backref" href="#id91">Initial Time and Date</a></h3>
<p>By default, a simulation starts on the first of January of year 2000, at 00:00:00. The <tt class="docutils literal"><span class="pre">Soda-Example</span></tt> relies on that default, but some cases will want to override that.</p>
<p>The initial simulation timestamp can be changed by communicating a new date and time to the root time manager <a class="footnote-reference" href="#id48" id="id47">[22]</a> (from the simulation case and, obviously, before the simulation is started).</p>
<p>First step is to retrieve a reference (a PID) onto this root time manager. It can be obtained thanks to the PID of the deployment manager, which is the entry point of the simulation that was returned by the call to <tt class="docutils literal">sim_diasca:init/3</tt> that we already mentioned:</p>
<pre class="code erlang literal-block">
<span class="p">[...]</span>
<span class="nv">DeploymentManagerPid</span> <span class="o">=</span> <span class="nn">sim_diasca</span><span class="p">:</span><span class="nf">init</span><span class="p">(</span><span class="nv">SimulationSettings</span><span class="p">,</span>
            <span class="nv">DeploymentSettings</span><span class="p">,</span><span class="nv">LoadBalancingSettings</span><span class="p">),</span>
<span class="p">[...]</span>
<span class="nv">DeploymentManagerPid</span> <span class="o">!</span> <span class="p">{</span><span class="n">getRootTimeManager</span><span class="p">,[],</span><span class="n">self</span><span class="p">()},</span>
</pre>
<table class="docutils footnote" frame="void" id="id48" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id47">[22]</a></td><td>The root manager is the one in charge of the overall scheduling of the simulation: in a purely local setting (a single node), there is only one time manager, while in distributed mode there is one local time manager per computing host, all of which synchronising themselves with the root one.
In a more general view, a scheduling tree of time managers, potentially of arbitrary depth and shape, may exist.</td></tr>
</tbody>
</table>
<p>Explaining this last line is a good occasion to introduce more information about how Erlang is to be used.</p>
<p>Erlang processes communicate between them solely thanks to the sending of messages. This sending is asynchronous: a process <tt class="docutils literal">A</tt> having to send a message <tt class="docutils literal">M</tt> (whatever it is) to a process <tt class="docutils literal">B</tt> (designated by its PID, stored in the <tt class="docutils literal">BPid</tt> variable) will simply have to specify: <tt class="docutils literal">BPid ! M</tt>.</p>
<p>As mentioned, all Erlang processes live concurrently, i.e. they are all executed in parallel. Unless a process is looping over its code or blocked in a <tt class="docutils literal">receive</tt> clause (waiting for a message to be received), it will simply terminate.</p>
<p>This message (<tt class="docutils literal">M</tt>) can be any Erlang term, for example the content of any Erlang variable. Here, in our simulation case, the message that we saw is a <a class="reference external" href="https://en.wikipedia.org/wiki/Tuple">tuple</a> (i.e. a fixed-length series of terms) of three elements <a class="footnote-reference" href="#id50" id="id49">[23]</a> (respectively here: the <tt class="docutils literal">getRootTimeManager</tt> atom, the empty list <tt class="docutils literal">[]</tt> and the result of a call to the <tt class="docutils literal">self/0</tt> function). This last function returns the PID of the current process, namely here the one executing currently the simulation case.</p>
<table class="docutils footnote" frame="void" id="id50" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id49">[23]</a></td><td>A tuple of three elements (<tt class="docutils literal">{X,Y,Z}</tt>) is named a <em>triplet</em>. A tuple of two elements (<tt class="docutils literal">{X,Y}</tt>) is named a <em>pair</em>.</td></tr>
</tbody>
</table>
<p>A message is sent in a &quot;fire and forget&quot; manner: the sending process, <tt class="docutils literal">A</tt>, will transfer it to the Erlang runtime and directly continue with its next instructions, without waiting for example that <tt class="docutils literal">B</tt> receives it <a class="footnote-reference" href="#id52" id="id51">[24]</a>.</p>
<table class="docutils footnote" frame="void" id="id52" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id51">[24]</a></td><td>Once actually received (either locally or transparently through the network) this message will be stored in the mailbox of <tt class="docutils literal">B</tt>, which will be free to read it whenever it deems it appropriate. Note that only the message itself (<tt class="docutils literal">M</tt>) is delivered; as a result, by default <tt class="docutils literal">B</tt> has no means of determining what process sent it. If <tt class="docutils literal">B</tt> needs this information, then <tt class="docutils literal">A</tt> may send for example the term <tt class="docutils literal">{M,APid}</tt> instead (and of course <tt class="docutils literal">B</tt> shall expect to receive such a pair).</td></tr>
</tbody>
</table>
<p>When the simulation case sends the <tt class="docutils literal"><span class="pre">{getRootTimeManager,[],self()}</span></tt> message to the deployment manager, this Erlang message will be interpreted according to the WOOPER conventions: the <tt class="docutils literal">getRootTimeManager</tt> request method (i.e. a method returning a result, as opposed to oneway methods that do not return anything) of the deployment manager will be executed (here with no specific parameter, since the specified list is empty) and its result (here, the PID of the root time manager) will be returned to the sender (here, the simulation case, which specified its own PID for that, as last element of the triplet).</p>
<p>As a result, the PID of the (root) time manager will be returned by the deployment manager and stored in the <tt class="docutils literal">RootTimeManagerPid</tt> variable thanks to:</p>
<pre class="literal-block">
RootTimeManagerPid = test_receive()
</pre>
<p>So now the simulation case knows the PID of the root time manager, and is able to interact with it.</p>
<p>This allows us to finally specify the initial simulation timestamp discussed in this section, simply thanks to:</p>
<pre class="code erlang literal-block">
<span class="c">% Let's start on 2020, October 21st at 7h, 12 minutes
% and 10 seconds:
</span><span class="nv">StartYear</span> <span class="o">=</span> <span class="mi">2020</span><span class="p">,</span>

<span class="nv">StartDate</span> <span class="o">=</span> <span class="p">{</span><span class="nv">StartYear</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">21</span><span class="p">},</span>
<span class="nv">StartTime</span> <span class="o">=</span> <span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">10</span><span class="p">},</span>

<span class="nv">RootTimeManagerPid</span> <span class="o">!</span> <span class="p">{</span><span class="n">setInitialSimulationDate</span><span class="p">,</span>
                         <span class="p">[</span><span class="nv">StartDate</span><span class="p">,</span><span class="nv">StartTime</span><span class="p">]}</span>
</pre>
<p>So here we called the <tt class="docutils literal">setInitialSimulationDate</tt> oneway method (we do not expect any result when setting a date) of the root time manager to have its initial simulation timestamp set.</p>
</div>
<div class="section" id="termination-criteria">
<h3><a class="toc-backref" href="#id92">Termination Criteria</a></h3>
<p>The engine must of course have also some way of determining when the evaluation of the simulation shall be stopped.</p>
<p>Multiple criteria can be defined, the first that applies will be the one to actually end the simulation.</p>
<p>Typically the models and scenarios may decide of the termination (ex: &quot;stop when we reach this total cost or this level of pollution&quot;, or &quot;stop when its combination of events happens&quot;).</p>
<p>The simulation case can also define such a criterion, typically to mark an upper bound to the duration of the simulation.</p>
<p>Supposing we defined the initial time and date as described in the previous section, we can now define also its maximum duration, i.e. conversely define the final simulation time and date. This could be done thanks:</p>
<pre class="code erlang literal-block">
<span class="c">% We will end exactly 5 years later:
</span><span class="nv">SimulationDurationInYears</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>

<span class="nv">EndDate</span> <span class="o">=</span> <span class="p">{</span><span class="nv">StartYear</span><span class="o">+</span><span class="nv">SimulationDurationInYears</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">21</span><span class="p">},</span>
<span class="nv">EndTime</span> <span class="o">=</span> <span class="nv">StartTime</span><span class="p">,</span>

<span class="nv">RootTimeManagerPid</span> <span class="o">!</span> <span class="p">{</span><span class="n">setFinalSimulationDate</span><span class="p">,</span>
                           <span class="p">[</span><span class="nv">EndDate</span><span class="p">,</span><span class="nv">EndTime</span><span class="p">]}</span>
</pre>
<p>So here the simulation will end no later (as other termination criteria may be triggered first) than the 21st of October of year 2005, at 7h, 12 minutes and 10 seconds.</p>
</div>
<div class="section" id="starting-the-simulation">
<h3><a class="toc-backref" href="#id93">Starting the Simulation</a></h3>
<p>The simulation can be started simply by requesting the root time manager to do so:</p>
<pre class="code erlang literal-block">
<span class="nv">RootTimeManagerPid</span> <span class="o">!</span> <span class="n">start</span>
</pre>
<p>This message will therefore trigger the <tt class="docutils literal">start/1</tt> oneway method of the root time manager.</p>
<p>By the way, one may wonder why this call (i.e. the message sending) visibly does not involve any parameter (ex: we have <tt class="docutils literal">BPid ! myMethod</tt>, not <tt class="docutils literal">BPid ! <span class="pre">{myMethod,[&quot;hello&quot;,42]}</span></tt>) yet triggers <tt class="docutils literal">start/1</tt> (whereas we could expect it would trigger <tt class="docutils literal">start/0</tt>).</p>
<p>The reason is that the Erlang process corresponding to a WOOPER instance keeps internally the state of this instance in a term (of type <tt class="docutils literal">wooper:state()</tt> <a class="footnote-reference" href="#id54" id="id53">[25]</a>), and that this state is added as first argument when calling a method.</p>
<table class="docutils footnote" frame="void" id="id54" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id53">[25]</a></td><td>A <tt class="docutils literal">wooper:state()</tt> variable is actually an associative table whose keys are the names of the attributes of the instances, and whose values are the corresponding values (ex: like a dictionary in Python).
For example, if a cat instance is defined by his name and fur color, a cat state could comprise two name/value attribute pairs, such as <tt class="docutils literal"><span class="pre">{name,&quot;Felix&quot;}</span></tt> and <tt class="docutils literal">{fur_color,black}</tt>.</td></tr>
</tbody>
</table>
<p>So, typically, here the message sending would trigger <tt class="docutils literal">class_TimeManager:start/1</tt> that way:</p>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">spec</span> <span class="n">start</span><span class="p">(</span><span class="nn">wooper</span><span class="p">:</span><span class="nf">state</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="n">oneway_return</span><span class="p">().</span>
<span class="nf">start</span><span class="p">(</span><span class="nv">State</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="c">% Actual implementation of that method.
</span>  <span class="p">[...]</span>
</pre>
<p>We can see first the type specification for this Erlang function (such a specification is optional, yet we recommend writing it down, in order to rely on clearer code that moreover can be more thoroughly type-checked).</p>
<p>The function is named <tt class="docutils literal">start</tt>, takes one parameter (the state that WOOPER keeps and adds automatically) and returns as a oneway (meaning that it only returns an updated state, kept by WOOPER, and no specific result).</p>
<p>The <tt class="docutils literal"><span class="pre">Soda-Example</span></tt> case uses a variation of this <tt class="docutils literal">start</tt> oneway, defined as <tt class="docutils literal">class_TimeManager:startFor/3</tt> and that can be called with:</p>
<pre class="code erlang literal-block">
<span class="c">% In (virtual) seconds:
</span><span class="nv">SimulationDuration</span> <span class="o">=</span> <span class="mi">150</span><span class="p">,</span>
<span class="nv">RootTimeManagerPid</span> <span class="o">!</span> <span class="p">{</span><span class="n">startFor</span><span class="p">,[</span><span class="nv">SimulationDuration</span><span class="p">,</span><span class="n">self</span><span class="p">()]}</span>
</pre>
<p>The corresponding definition is:</p>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">spec</span> <span class="n">startFor</span><span class="p">(</span><span class="nn">wooper</span><span class="p">:</span><span class="nf">state</span><span class="p">(),</span><span class="nn">unit_utils</span><span class="p">:</span><span class="nf">any_seconds</span><span class="p">(),</span><span class="n">pid</span><span class="p">())</span>
    <span class="o">-&gt;</span> <span class="n">oneway_return</span><span class="p">().</span>
<span class="nf">startFor</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="nv">Duration</span><span class="p">,</span><span class="nv">SimulationListenerPID</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="c">% Actual implementation of that method.
</span>  <span class="p">[...]</span>
</pre>
<p>Here, beside the usual state, the oneway specifies a duration (the maximum one for the simulation) and a PID (here, of the simulation case).</p>
<p>The corresponding process will then be notified if/when the simulation successfully ends, so the case uses afterwards:</p>
<pre class="code erlang literal-block">
<span class="k">receive</span>

     <span class="n">simulation_stopped</span> <span class="o">-&gt;</span>
         <span class="o">?</span><span class="n">test_info</span><span class="p">(</span><span class="s">&quot;Simulation stopped spontaneously, &quot;</span>
                    <span class="s">&quot;specified stop tick must have been reached.&quot;</span><span class="p">)</span>

 <span class="k">end</span>
</pre>
<p>Indeed, when the simulation stops, the root time manager notifies all simulation listeners of it by sending them a <tt class="docutils literal">simulation_stopped</tt> message.</p>
<p>The simulation case is not a WOOPER instance (ex: its module name, <tt class="docutils literal">soda_loading_test</tt>, is not prefixed with <tt class="docutils literal">class_</tt>), hence Erlang messages are not intercepted by WOOPER and managed as method calls. Therefore the case can performs a standard Erlang receive to block and wait for such a message to arrive and, here, send a trace message and continue with its execution.</p>
</div>
<div class="section" id="other-elements-to-include-in-a-simulation-case">
<h3><a class="toc-backref" href="#id94">Other Elements To Include in a Simulation Case</a></h3>
<div class="section" id="initialisation-shutdown">
<h4>Initialisation &amp; Shutdown</h4>
<p>We saw that the engine is to be initialised thanks to the <tt class="docutils literal">sim_diasca:init/3</tt> and the corresponding three record settings.</p>
<p>Reciprocally, it shall be terminated at the end of the case thanks to a call to <tt class="docutils literal">sim_diasca:shutdown/0</tt>.</p>
<p>The simulation case must be defined in the <tt class="docutils literal">run/0</tt> function, in which any Erlang code can be executed.</p>
<p>As the support of traces must be enabled (e.g. for the models, knowing that the simulation case generally emits traces as well), the <tt class="docutils literal">run/0</tt> function shall start with the <tt class="docutils literal"><span class="pre">?test_start</span></tt> macro <a class="footnote-reference" href="#id56" id="id55">[26]</a> and end with the <tt class="docutils literal"><span class="pre">?test_stop</span></tt> macro.</p>
<table class="docutils footnote" frame="void" id="id56" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id55">[26]</a></td><td>A macro is a simple syntax shorthand, managed by the preprocessor,  (taking care of the first stage of the compilation process). A call to a macro begings with <tt class="docutils literal">?</tt>.</td></tr>
</tbody>
</table>
<p></p>
</div>
</div>
</div>
<div class="section" id="model-specification">
<h2><a class="toc-backref" href="#id95">Model Specification</a></h2>
<p>Now, we will have to fill appropriately the three implementation files corresponding to our three models of interest, based on their corresponding specification.</p>
<p>What must be specifically defined for a given model?</p>
<ul class="simple">
<li>how its <strong>state</strong> is defined, i.e. what is its inner structure</li>
<li>its <strong>behaviour</strong>, i.e. how it is to act and interact</li>
<li>its <strong>constructors</strong>, i.e. how it shall be created</li>
<li>its <strong>probe usage</strong>, i.e. how it should produce results</li>
</ul>
<p>State and behaviour are closely interdependent: the behaviour uses the state to decide what the instance is to do next (ex: if a cat is hungry, it may decide to meow), while the state is reciprocally necessary to implement the behaviour (ex: if a cat can remember where its food usually is, it may first get there to see whether there are some).</p>
<p>As a result they must be defined mostly together.</p>
<div class="section" id="behaviour">
<h3><a class="toc-backref" href="#id96">Behaviour</a></h3>
<div class="section" id="specifying">
<h4>Specifying</h4>
<p>Implicitly we can anticipate that no can will be sold:</p>
<ul class="simple">
<li>from a vending machine having none left</li>
<li>or to a customer that does not know that machine (as he is not even aware of its existence)</li>
<li>or to a customer who would not have enough money to buy a can from that machine</li>
</ul>
<p>No can should be sold to a non-thirsty customer, as at the first place it should not have tried to purchase one.</p>
<p>We can fairly easily imagine the underlying &quot;appicative protocol&quot; ruling the exchanges between a customer and a vending machine, i.e. the series of interactions that can take place between these two.</p>
<p>One of the many ways to formalize a bit a high-level description of the behaviour of each model is to use <a class="reference external" href="http://en.wikipedia.org/wiki/Finite_state_machine">Finite State Machines</a> (FSM) that interact.</p>
<p>The following graphical conventions are used here:</p>
<p><span class="raw-html"><center><img src="FSM-legend.png" id="responsive-image-intermediate"></img></center></span>
</p>
<p>Not specifying an event condition on a state transition means here that the state change is time-based, i.e. it will occur automatically once a specific duration (in simulation time) will be elapsed.</p>
<p>The two models are interacting, thus the two FSMs will interact as well, based on message exchanges:</p>
<p><span class="raw-html"><center><img src="soda-ordering-interacting-FSM-committed.png" id="responsive-image-medium"></img></center></span>
</p>
<p>No inter-customer exchange is shown here: as an exercise, we could imagine that an impoverished customer may try to borrow money from another he knows.</p>
<p>So, from each of these FSMs, we can derive the behaviour of the corresponding model, from its initial logical state to all others. Transitions are clearly related to internal changes (ex: the thirst of a customer builds over time - a.k.a. spontaneous behaviour) and external changes (denoted as the receiving of an actor message, like when a customer is notified of the price of a can of the vending machine.</p>
</div>
<div class="section" id="spontaneous-behaviour">
<h4>Spontaneous Behaviour</h4>
<p>The <strong>spontaneous behaviour</strong> describes how instances of a model behave, should their environment be fully passive. This behaviour is implemented in the <tt class="docutils literal">actSpontaneous/1</tt> <a class="footnote-reference" href="#id58" id="id57">[27]</a> actor method, which takes the instance state as input and returns an updated one.</p>
<table class="docutils footnote" frame="void" id="id58" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id57">[27]</a></td><td>As mentioned, the <tt class="docutils literal">/1</tt> means an arity of one, i.e. that this method takes only only parameter. More precisely, its type specification is <tt class="docutils literal"><span class="pre">-spec</span> actSpontaneous( wooper:state() ) <span class="pre">-&gt;</span> <span class="pre">wooper:state().</span></tt>: the method is given a state, and shall return another one, possibly the same, possibly updated.</td></tr>
</tbody>
</table>
<p>For a customer like these ones, the spontaneous behaviour is rather simple: if he does not know yet the cost of a can, it requests it, otherwise it manages its thirst, i.e. it tries to order a can if the conditions are met.</p>
<p>The spontaneous behaviour of a soda vending machine is even simpler, as it is empty: modelled as they are, these machines are purely passive, nothing will happen unless their environment acts.</p>
<p>Other spontaneous behaviours might be considerably more complex: the normal, default mode of operation of, say, an incinerator could be very rich (with burners being driven, wastes being moved from a tank to another, etc.), not to mention the intents that could drive an human being.</p>
</div>
<div class="section" id="triggered-behaviour">
<h4>Triggered Behaviour</h4>
<p>Regardless of its spontaneous behaviour, a model instance can also develop a triggered behaviour, i.e. one that is specifically activated by other model instances, i.e. by the receiving of a corresponding actor message.</p>
<p>More precisely, any model (ex: a cat one) can declare any number of signals (named actor oneways) that it may understand.</p>
<p>For example, a cat may be stroked, brushed, yelled at, fed, etc. Each signal (ex: <tt class="docutils literal">onBeingStroked</tt>) will lead to an actor oneway to be defined, to determine what the cat would do in this occasion. A cat being stroked can meow, purr, age twice as fast, explode, etc. depending on how we model it.</p>
<p>The definition of the function implementing an actor oneway includes at least two parameters: the first one specifies the state at which the instance receiving this message is, while the last parameter is a reference (a PID) onto the model instance which sent this signal. Between these two, any number of extra parameters can be listed (possibly none), so that that the signal can be fully described.</p>
<p>For a soda vending machine, a client inserting some coins corresponds to the sending of the <tt class="docutils literal">orderSoda</tt> actor message, whose type specification is:</p>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">spec</span> <span class="n">orderSoda</span><span class="p">(</span><span class="nn">wooper</span><span class="p">:</span><span class="nf">state</span><span class="p">(),</span><span class="n">amount</span><span class="p">(),</span><span class="n">pid</span><span class="p">())</span> <span class="o">-&gt;</span>
                  <span class="nn">class_Actor</span><span class="p">:</span><span class="nf">actor_oneway_return</span><span class="p">().</span>
</pre>
<p>We can see here that there is a single extra parameter, the exact amount of money the customer inserted. This will allow the machine to determine if:</p>
<ul class="simple">
<li>there is at least one can still in store (by reading the current can count in input state)</li>
<li>the customer inserted enough money (by comparing the recorded can cost with the amount of money supplied, respectively in the actor input state and in the received actor message)</li>
</ul>
<p>Based on that, the machine can determine whether a can must be sold. Then its returned state shall (corresponding to the oneway return) reflect the outcome, with one less can in store yet its amount of collected money being increased of the cost of a can.</p>
<p>Once having updated the state of its instance, this <tt class="docutils literal">orderSoda/3</tt> actor oneway shall also communicate back to the sender of the signal (here, a customer), so that it can know whether the transaction succeeded; here there are three possible outcomes:</p>
<ul class="simple">
<li>the transaction succeeded, the customer lost a bit of money (the cost of a can) yet gained a can - thus sooner being less thirsty</li>
<li>the transaction failed and the customer remains as thristy as he was:<ul>
<li>either because there was no can left in the machine</li>
<li>or because the customer did not insert enough money</li>
</ul>
</li>
</ul>
<p>How can the vending machine notify the customer of these outcomes? Simply by sending him back an actor message (among, respectively, <tt class="docutils literal">getCan/2</tt>, <tt class="docutils literal">onNoCanAvailable/2</tt>, or <tt class="docutils literal">onNotEnoughMoney/2</tt>), using the PID listed as last parameter of the incoming actor oneway for that.</p>
<p>The union of all actor oneways declared by a model (the &quot;signals&quot; that can be triggered on it) constitutes the triggered behaviour of this model.</p>
</div>
<div class="section" id="what-s-a-behaviour-anyway">
<h4>What's a Behaviour Anyway?</h4>
<p>Typically any behaviour (be it spontaneous or triggered) boils down to any number of these actions:</p>
<ul class="simple">
<li>updating the instance state</li>
<li>declaring that it should be spontaneously scheduled again in a specified future</li>
<li>sending an actor message to other model instances (i.e. engaging an interaction)</li>
<li>feeding a probe with result data</li>
</ul>
<p>That's it!</p>
<p>Let's explain a bit further each of these terms.</p>
<p>Updating the state means having that <tt class="docutils literal">actSpontaneous/1</tt> or the triggered actor oneway (ex: <tt class="docutils literal">getCan/2</tt>) change the value of any attribute set in the state.</p>
<p>So a deterministic thirsty customer having succeeded in buying a can should have some way of keeping track of:</p>
<ul class="simple">
<li>the money he still has</li>
<li>his level of thirst, i.e. in how much time he will be thirsty again</li>
</ul>
<p>This may be done respectively with:</p>
<ul class="simple">
<li>a <tt class="docutils literal">current_money</tt> attribute, of type <tt class="docutils literal">amount()</tt>, a floating-point number of euros</li>
<li>a <tt class="docutils literal">next_thirsty_tick</tt>, of type <tt class="docutils literal">class_TimeManager:tick_offset()</tt> that would be the next tick offset at which it will be thirsty again (more on these timing considerations later)</li>
</ul>
<p>Or course other attributes will be useful to maintain a proper state of this deterministic customer:</p>
<ul class="simple">
<li>a reference onto the vending machine he knows (so that it can send actor messages to it): a <tt class="docutils literal">known_machine_pid</tt> attribute, of type <tt class="docutils literal">pid()</tt></li>
<li>the cost of a can (that the customer requested prior to any ordering attempt): an attribute named <tt class="docutils literal">can_cost</tt>, of type <tt class="docutils literal">amount()</tt> (for a given machine, the cost of a can being constant through the whole simulation, it is better to ask it once for all and to remember it, and then order repeatedly cans on that basis)</li>
<li>the duration between the moment a can is drunk and the customer is thirsty again (<tt class="docutils literal">repletion_duration</tt>, of type <tt class="docutils literal">class_TimeManager:tick_offset()</tt>); for such a deterministic customer, it will be a constant</li>
<li>whether a soda is being ordered (<tt class="docutils literal">transaction_in_progress</tt>, of type <tt class="docutils literal">boolean()</tt>) tells whether a transaction with a machine is in progress; it is necessary for the customer to remember that it started a buying attempt, otherwise, as the soda vending machine may take an arbitrarily long time to answer, it may order again and again a can before receiving its first feedback (i.e. actor message from the machine)</li>
</ul>
<p>As mentioned, these deterministic customers are modelled so that they will be thirsty again once a fixed duration (in simulation time) elapsed since they drank their last soda can.</p>
<p>Implementing this behaviour is just a matter of:</p>
<ul class="simple">
<li>determining the repletion duration, in minutes, for the current deterministic customer; this is easy, as this is here a constant, specified amidst the construction parameters of these customers:</li>
</ul>
<pre class="code erlang literal-block">
<span class="nf">construct</span><span class="p">(</span><span class="nv">State</span><span class="p">,[...],</span><span class="nv">RepletionDuration</span><span class="p">,[...]</span> <span class="p">)</span> <span class="o">-&gt;</span>
  <span class="p">[...]</span>
</pre>
<ul class="simple">
<li>computing the number of ticks corresponding to this duration, by calling the <tt class="docutils literal">class_Actor:convert_seconds_to_ticks/2</tt> <a class="footnote-reference" href="#id60" id="id59">[28]</a> function; in practice, as this fixed, high-level duration is known from the start, it can be converted once for all in a number of ticks directly from the constructor of the customer model (this cannot be statically, as the corresponding number of ticks depends on the simulation frequency separately set by the simulation case):</li>
</ul>
<pre class="code erlang literal-block">
<span class="nv">TickRepletionDuration</span> <span class="o">=</span> <span class="nn">class_Actor</span><span class="p">:</span><span class="nf">convert_seconds_to_ticks</span><span class="p">(</span>
             <span class="mi">60</span><span class="o">*</span><span class="nv">RepletionDuration</span><span class="p">,</span> <span class="nv">ActorState</span> <span class="p">),</span>
<span class="p">[...]</span>
<span class="nf">setAttributes</span><span class="p">(</span> <span class="nv">ActorState</span><span class="p">,</span> <span class="p">[</span>
    <span class="p">[...]</span>
    <span class="p">{</span><span class="n">repletion_duration</span><span class="p">,</span><span class="nv">TickRepletionDuration</span><span class="p">},</span>
    <span class="p">[...]</span>
                            <span class="p">]</span> <span class="p">).</span>
</pre>
<table class="docutils footnote" frame="void" id="id60" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id59">[28]</a></td><td>The <tt class="docutils literal">/2</tt> designates an arity of 2, i.e. that this function takes two parameters, here the duration, in seconds, and the state of the instance. It would then return the duration expressed in simulation ticks.</td></tr>
</tbody>
</table>
<p>Then the <tt class="docutils literal">repletion_duration</tt> attribute contains the number of ticks during which a deterministic customer will not be thirsty once he drank a can.</p>
<p>Currently, in the implementation of the thirsty customers, each instance is scheduled at each tick (as <tt class="docutils literal">executeOneway(State,scheduleNextSpontaneousTick)</tt> is used), and the purpose of the repletion duration is only to establish whether, at some of these ticks, a soda can may be ordered.</p>
<p>Another implementation could have been to have thirsty customers be scheduled for a spontaneous behaviour <em>only</em> when they become thirsty again.</p>
<p>This could be done that way:</p>
<pre class="code erlang literal-block">
<span class="nf">actSpontaneous</span><span class="p">(</span><span class="nv">State</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="nv">CurrentTick</span> <span class="o">=</span> <span class="nn">class_Actor</span><span class="p">:</span><span class="nf">get_current_tick</span><span class="p">(</span><span class="nv">State</span><span class="p">),</span>
  <span class="nv">NextSpontaneousTick</span> <span class="o">=</span> <span class="nv">CurrentTick</span> <span class="o">+</span> <span class="o">?</span><span class="n">getAttr</span><span class="p">(</span><span class="n">repletion_duration</span><span class="p">),</span>
  <span class="nv">ScheduledState</span> <span class="o">=</span> <span class="n">executeOneway</span><span class="p">(</span><span class="nv">State</span><span class="p">,</span><span class="n">addSpontaneousTick</span><span class="p">,</span>
                                 <span class="nv">NextSpontaneousTick</span><span class="p">),</span>
  <span class="p">[...]</span>
</pre>
<p>More real-life, complex examples can also be found in the <tt class="docutils literal"><span class="pre">City-Example</span></tt> case <a class="footnote-reference" href="#id62" id="id61">[29]</a>, for various models (<tt class="docutils literal">Incinerator</tt>, <tt class="docutils literal">IndustrialWasteSource</tt>, <tt class="docutils literal">ResidentialWasteSource</tt>, <tt class="docutils literal">Road</tt>, <tt class="docutils literal">WasteTruck</tt> and <tt class="docutils literal">WeatherCell</tt>). They all use the alternate, direct form <tt class="docutils literal">class_Actor:add_spontaneous_tick/2</tt> to perform their scheduling.</p>
<table class="docutils footnote" frame="void" id="id62" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id61">[29]</a></td><td>Located in <tt class="docutils literal"><span class="pre">mock-simulators/city-example/src</span></tt>.</td></tr>
</tbody>
</table>
<p>These examples show how, in general (for spontaneous scheduling as well as for interactions) model-level durations can be expressed in their most general form (ex: as mere seconds) yet can be easily converted in actual simulation ticks, in order to implement any kind of scheduling.</p>
<p>A special case is the request to schedule the next tick (<tt class="docutils literal">scheduleNextSpontaneousTick/1</tt>), which may convey in some cases the notion of &quot;immediate next step&quot;, rather than a duration as such.</p>
<p>However in this case the use of (diasca-based) interactions would generally be more appropriate, as they allow for arbitrarily complex exchange patterns to be performed - through multiple logical moments yet in the same tick (hence with no progress <em>at all</em> of the simulation clock).</p>
</div>
<div class="section" id="interaction">
<h4>Interaction</h4>
<p>Unless mentioned otherwise, we consider that an interaction is to obey a specific timing.</p>
<p>For example, we can consider that communications (ex: a customer speaking to another) are instantaneous, perceptions (ex: a customer looking at a machine to read the cost of one of its cans, supposedly displayed on the machine) as well, but that other actions (ex: a machine processing a can order) last for some model-specific duration (ex: 800 ms of virtual time may elapse before a valid purchase results in a can being delivered to the corresponding customer).</p>
<p>The previous section showed how such timings should be expressed and used.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>As a rule of thumb: in a model, one should avoid expressing durations directly in terms of ticks; models shall be defined irrespective of any simulation frequency, as they may be involved in various simulations with various temporalities (as dictated by simulation cases).</p>
<p class="last">One should thus use higher-level durations (ex: expressed in seconds, or hours, etc.) and convert them in ticks only at runtime (possibly from constructors). All kinds of timings (for scheduling and interactions alike) can then be devised, knowing that, internally to models, ticks (as tick offsets) are the time units of choice for all processings.</p>
</div>
</div>
</div>
<div class="section" id="state">
<h3><a class="toc-backref" href="#id97">State</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A discussion about constructors will be added here.</p>
</div>
</div>
</div>
</div>
<div class="section" id="defining-other-simulation-elements">
<h1><a class="toc-backref" href="#id98">Defining Other Simulation Elements</a></h1>
<p>Among the simulation elements that may be also defined in the context of a simulation, there are:</p>
<ul class="simple">
<li>command files</li>
<li>scenarios</li>
<li>special probes</li>
<li>extra services</li>
</ul>
<p>Let's discuss of these elements in turn.</p>
<div class="section" id="command-files">
<h2><a class="toc-backref" href="#id99">Command Files</a></h2>
<p>They allow to store the most common commands that are issued by the user in the context of this case. Typically, rather than typing the full command to executed said simulation, the user relies on a makefile (that we prefer to name <tt class="docutils literal">GNUmakefile</tt>) that associated to a make target (ex: <tt class="docutils literal">batch</tt>) the actual command to be run (ex: <tt class="docutils literal">make city_benchmarking_run <span class="pre">CMD_LINE_OPT=&quot;--batch&quot;</span></tt>).</p>
<p>As a result, the user may simply type from the command-line:</p>
<pre class="literal-block">
$ make batch
</pre>
<p>and have his simulation be run.</p>
</div>
<div class="section" id="scenarios">
<h2><a class="toc-backref" href="#id100">Scenarios</a></h2>
<p>Scenarios, as discussed in the Sim-Diasca ontology <a class="footnote-reference" href="#id64" id="id63">[30]</a>, describe not the target city itself (this is the role of models) but its context (for example the weather system that may affect that city).</p>
<p>If, semantically, scenarios are very different from models, technically they are the same beasts: like a model, a scenario in the general case is constructed, has a state, may interact with others (be them scenarios or models), can produce results (thanks to probes), etc.</p>
<p>So, as an unexpected added bonus, you are already fully able to write your own scenarios!</p>
<table class="docutils footnote" frame="void" id="id64" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id63">[30]</a></td><td>Please refer to the <em>Sim-Diasca Technical Manual</em>, section 3: &quot;Lets Start With A Short Ontology&quot; for more information.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="special-probes">
<h2><a class="toc-backref" href="#id101">Special Probes</a></h2>
<p>Some projects may need to rely on specific data formats to express the simulation results.</p>
<p>For example, whereas Sim-Diasca generates natively time-series in a format that <a class="reference external" href="http://www.gnuplot.info/">gnuplot</a> can understand (see the <tt class="docutils literal">class_Probe</tt> module) or that a Mnesia database can handle (see the <tt class="docutils literal">class_DataLogger</tt> module), some projects may rely on a platform handling time series stored in a different format instead, like <a class="reference external" href="https://www.hdfgroup.org/HDF5/">HDF5</a> or <a class="reference external" href="http://www.unidata.ucar.edu/software/netcdf/">netcdf-4</a>.</p>
<p>One solution is, if appropriate, to post-process the native Sim-Diasca result format in order to translate it to the format of choice. For the cases where it would not be feasible or straightforward, the best option is to write a custom probe, possibly relying on a binding to a library handling the target format.</p>
<p>An example of that is the <tt class="docutils literal">class_CURTISProbe</tt> <a class="footnote-reference" href="#id66" id="id65">[31]</a>, which implements its own convention in terms of result storage and relies on a <a class="reference external" href="https://github.com/Olivier-Boudeville-EDF/erlhdf5">specific binding</a> (allowing here to make use in this case of the well-known, standard HDF5 library).</p>
<table class="docutils footnote" frame="void" id="id66" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id65">[31]</a></td><td>The CURTIS probe is a part of the <tt class="docutils literal"><span class="pre">sustainable-cities</span></tt> case, which is <em>not</em> provided with the free software version of Sim-Diasca (case for internal use only).</td></tr>
</tbody>
</table>
</div>
<div class="section" id="extra-services">
<h2><a class="toc-backref" href="#id102">Extra Services</a></h2>
<p>Sim-Diasca provides generic services, yet more advanced simulations may require dedicated features.</p>
<p>For example, spatialised simulations have many geographic operations to perform, or simulation of a telecom system may have many domain-specific metrics like bandwidth and latency to compute.</p>
<p>These specific notions are not known of generic, lean and mean engines such as Sim-Diasca. Two main approaches allow to alleviate this issue:</p>
<ul class="simple">
<li>a bit like for the custom probes, already-existing, third party software elements can be reused to provide lacking services; for a spatialised simulation it would typically involve integrating a <a class="reference external" href="https://en.wikipedia.org/wiki/Geographic_information_system">GIS</a> (<em>Geographic information system</em>), possibly accessed to thanks to REST calls made from the models</li>
<li>specialised layers can be defined between Sim-Diasca and the targeted models; for example, for the CLEVER project, a telecom layer was built on top of Sim-Diasca, providing base classes for all the related business-specific models (ex: the layer was comprising notions of communicating device, network interfaces, packet router, etc.); then the domain-specific models could be defined more easily by re-using that adaptation layer, and could then directly manipulate bandwith, latency, routing elements, etc.</li>
</ul>
</div>
</div>
<div class="section" id="conclusion">
<h1><a class="toc-backref" href="#id103">Conclusion</a></h1>
<p>By going through this modelling guide, we recreated elements of an example of a simulation that actually exists, and can be found in the free software version of Sim-Diasca. The full code of this example case is indeed located in <tt class="docutils literal"><span class="pre">mock-simulators/soda-test/src</span></tt>.</p>
<p>More advanced users are advised to have a look also to the <em>City-Example</em> case, located in <tt class="docutils literal"><span class="pre">mock-simulators/city-example/src</span></tt>, for a considerably more complex and demanding example case.</p>
<p>We hope that writing simulations will be easier thanks to the examples provided with the Sim-Diasca code base and thanks to this guide oriented towards modellers.</p>
<p>As always, any (constructive!) feedback is welcome (for that use the email address at the top of this document). Should some point remain unclear, please feel free to contact us, as we try to provide support on a best-effort basis.</p>
<p><span class="raw-html"><center><img src="sim-diasca.png" id="responsive-image-small"></img></center></span>
</p>
<p><span class="raw-html"><a name="sim_diasca_bottom"></a></span></p>
</div>
</div>
</body>
</html>
