<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.16: http://docutils.sourceforge.net/" />
<title>Sim-Diasca Installation Guide</title>
<meta content="Sim-Diasca, massive, simulation, multi-agent, installation" name="keywords" />
<link rel="stylesheet" href="pygments-default.css" type="text/css" />
<link rel="stylesheet" href="sim-diasca.css" type="text/css" />
<link href="sim-diasca-icon.png" rel="icon">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
<div class="document" id="sim-diasca-installation-guide">
<h1 class="title">Sim-Diasca Installation Guide</h1>
<h2 class="subtitle" id="public-version">Public Version</h2>

<p><span class="raw-html"><a name="sim_diasca_top"></a></span></p>
<p><span class="raw-html"><div class="banner"><p><em>Sim-Diasca public documentation</em> <a href="https://olivier-boudeville-edf.github.io/Sim-Diasca">browse latest</a> <a href="Sim-Diasca-public-installation-guide-english.pdf">get PDF</a> <a href="#sim_diasca_top">go to top</a> <a href="#sim_diasca_bottom">go to bottom</a> <a href="https://github.com/Olivier-Boudeville-EDF/Sim-Diasca">public project</a><a href="mailto:olivier(dot)boudeville(at)edf(dot)fr?subject=[Sim-Diasca]%20Remark">email us</a></p></div></span></p>
<p><span class="raw-html"><center><table><tr colspan="2"><center><img src="sim-diasca.png" style="width:500px"></center></tr><tr><td><center><img src="logo-EDF-english.png" style="width:150px"></center></td><td><center><img src="lgpl-v3-logo-bordered.png" style="width:140px"></center></td></tr></table></span></p>
<p></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Organisation:</th><td class="field-body">Copyright (C) 2008-2023 EDF R&amp;D</td>
</tr>
<tr class="field"><th class="field-name">Contact:</th><td class="field-body">olivier (dot) boudeville (at) edf (dot) fr</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Olivier Boudeville</td>
</tr>
<tr class="field"><th class="field-name">Creation date:</th><td class="field-body">Monday, February 8, 2010</td>
</tr>
<tr class="field"><th class="field-name">Lastly updated:</th><td class="field-body">Thursday, September 28, 2023</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">2.4.6</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Stable</td>
</tr>
<tr class="field"><th class="field-name">Website:</th><td class="field-body"><a class="reference external" href="http://sim-diasca.com">http://sim-diasca.com</a></td>
</tr>
<tr class="field"><th class="field-name">Dedication:</th><td class="field-body">For users installing the <cite>Sim-Diasca</cite> simulation engine.</td>
</tr>
<tr class="field"><th class="field-name">Abstract:</th><td class="field-body">This document will guide the reader through step-by-step instructions in order to install the <cite>Sim-Diasca</cite> simulation engine from its sources, which is the recommended procedure.</td>
</tr>
</tbody>
</table>
<p><span class="raw-html"></center></span></p>
<p></p>
<p><span class="raw-html"><a name="sim_diasca_toc"></a></span></p>
<div class="contents topic" id="table-of-contents">
<p class="topic-title"><strong>Table of Contents</strong></p>
<ul class="simple">
<li><a class="reference internal" href="#objective-context" id="id46">Objective &amp; Context</a></li>
<li><a class="reference internal" href="#basic-system-wide-network-settings" id="id47">Basic System-wide Network Settings</a><ul>
<li><a class="reference internal" href="#recommended-rules" id="id48">Recommended Rules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#software-prerequisites" id="id49">Software Prerequisites</a><ul>
<li><a class="reference internal" href="#software-needed" id="id50">Software Needed</a></li>
<li><a class="reference internal" href="#preparing-the-sim-diasca-sources" id="id51">Preparing the Sim-Diasca sources</a></li>
</ul>
</li>
<li><a class="reference internal" href="#installing-erlang" id="id52">Installing Erlang</a></li>
<li><a class="reference internal" href="#installing-logmx" id="id53">Installing LogMX</a><ul>
<li><a class="reference internal" href="#getting-logmx" id="id54">Getting LogMX</a></li>
<li><a class="reference internal" href="#setting-up-logmx" id="id55">Setting Up LogMX</a></li>
</ul>
</li>
<li><a class="reference internal" href="#enabling-the-python-binding-if-needed-installing-erlport" id="id56">Enabling the Python binding if needed: installing <tt class="docutils literal">ErlPort</tt></a><ul>
<li><a class="reference internal" href="#python-configuration" id="id57">Python Configuration</a></li>
<li><a class="reference internal" href="#erlport-installation" id="id58">ErlPort Installation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#checking-which-tools-sim-diasca-will-use" id="id59">Checking Which Tools Sim-Diasca Will Use</a></li>
<li><a class="reference internal" href="#building-sim-diasca" id="id60">Building Sim-Diasca</a></li>
<li><a class="reference internal" href="#enabling-the-distributed-mode-of-operation" id="id61">Enabling The Distributed Mode Of Operation</a><ul>
<li><a class="reference internal" href="#basic-network-configuration" id="id62">Basic Network Configuration</a></li>
<li><a class="reference internal" href="#password-less-authentication" id="id63">Password-less Authentication</a></li>
<li><a class="reference internal" href="#managing-the-simulator-codebase" id="id64">Managing the Simulator Codebase</a></li>
<li><a class="reference internal" href="#miscellaneous" id="id65">Miscellaneous</a></li>
<li><a class="reference internal" href="#cleaning-up" id="id66">Cleaning Up</a></li>
</ul>
</li>
<li><a class="reference internal" href="#testing-sim-diasca" id="id67">Testing Sim-Diasca</a></li>
<li><a class="reference internal" href="#installing-sim-diasca" id="id68">Installing Sim-Diasca</a></li>
<li><a class="reference internal" href="#credits" id="id69">Credits</a></li>
<li><a class="reference internal" href="#please-react" id="id70">Please React!</a></li>
<li><a class="reference internal" href="#support" id="id71">Support</a></li>
<li><a class="reference internal" href="#ending-word" id="id72">Ending Word</a></li>
</ul>
</div>
<p></p>
<div class="section" id="objective-context">
<h1><a class="toc-backref" href="#id46">Objective &amp; Context</a></h1>
<p>The goal here is to set up a fully functional Sim-Diasca installation, and to be able to test it and to develop with it, for example so that the implementation of new simulation cases and models can be directly experimented.</p>
<p>In the context of this public version, the installation will be performed:</p>
<ul class="simple">
<li>either from an archive (ex: <tt class="docutils literal"><span class="pre">Sim-Diasca-x.y.z.tar.bz2</span></tt>), supposedly already transmitted (typically after a request made through the contact form available at <a class="reference external" href="http://www.sim-diasca.com">the official Sim-Diasca website</a> (pointing, at the time of this writing, to <a class="reference external" href="https://www.edf.fr/en/the-edf-group/world-s-largest-power-company/activities/research-and-development/scientific-communities/simulation-softwares?logiciel=10832">this actual page</a>)</li>
<li>or  from its <a class="reference external" href="https://github.com/Olivier-Boudeville-EDF/Sim-Diasca">official public repository</a></li>
</ul>
<p>The operating system is supposed here to be GNU/Linux <a class="footnote-reference" href="#id2" id="id1">[3]</a> (32 or, most probably, 64 bits):</p>
<p><span class="raw-html"><center><img src="xkcd-cautionary.png" id="responsive-image-medium"></img></center></span>
</p>
<p>(see the <a class="reference internal" href="#credits">credits</a> section about the comic strips)</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[3]</a></td><td>This is the platform we use routinely, although other UNIX systems and possibly Windows platforms <em>could</em> be targeted. Sim-Diasca is also quite close to be able to run on Mac OS X, when a few perks will be ironed out (ex: <tt class="docutils literal">/proc/cpuinfo</tt> replacement). Patches welcome!</td></tr>
</tbody>
</table>
<p>Root access is not necessary, but recommended so that any lacking prerequisite can be installed directly and with little effort:</p>
<p><span class="raw-html"><center><img src="xkcd-sandwich.png" id="responsive-image-small"></img></center></span>
</p>
<p>Some space on disk will be needed. 300 megabytes should be enough for the full Sim-Diasca install by itself, but, depending on your use, generated data (ex: frames for simulation videos, plots of simulation results) could need <em>a lot</em> more additional space.</p>
<p>Finally, in all cases, i.e. even in the context of simulations to be run on a single machine (rather than in a distributed mode), the network configuration (on all hosts involved) must be adequate (notably so that any switch to a distributed mode of operation is as painless as possible).</p>
</div>
<div class="section" id="basic-system-wide-network-settings">
<h1><a class="toc-backref" href="#id47">Basic System-wide Network Settings</a></h1>
<div class="section" id="recommended-rules">
<h2><a class="toc-backref" href="#id48">Recommended Rules</a></h2>
<p>We observed in a few cases less-than-optimal network configurations (see also issues #3 and #4 in the <em>Most Common Issues</em> section of the <em>Sim-Diasca Technical Manual</em>); in short, if wanting to stay on the safer, UNIX-legit side (at least so that the Erlang VM can resolve consistently the local hostname), then ensure that (supposing this local hostname is meant to be <tt class="docutils literal">hurricane</tt>):</p>
<ul class="simple">
<li>in <tt class="docutils literal">/etc/hosts</tt>, for each name referring to the local host (hence in the <tt class="docutils literal">127/8</tt> network, usually <tt class="docutils literal">127.0.0.1</tt>):<ul>
<li>if using a specific domain (let's suppose it is <tt class="docutils literal">foobar.org</tt>), first the FQDN (<em>Fully-Qualified Domain Name</em>) shall be specified (as the official name), then only the hostname (hence as an alias)</li>
<li>all names based on the <tt class="docutils literal">localhost</tt> hostname shall come last, i.e. after all actual names that would be specified for the same local IP address</li>
</ul>
</li>
<li>in <tt class="docutils literal">/etc/resolv.conf</tt>, if a domain is specified there (which seems the most suitable), then it <em>must</em> be the right one (i.e. <tt class="docutils literal">foobar.org</tt> here)</li>
</ul>
<p>More information:</p>
<ul class="simple">
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Hosts_(file)">The Wikipedia entry</a> for the <tt class="docutils literal">/etc/hosts</tt> file</li>
<li><a class="reference external" href="https://linux-audit.com/is-your-etc-hosts-file-healthy/">Is your /etc/hosts file healthy?</a></li>
</ul>
<p>Two typical examples of (IPv4) legit network configurations follow.</p>
<div class="section" id="example-of-a-network-configuration-without-a-domain">
<h3>Example of a network configuration without a domain</h3>
<p>We suppose here that no specified domain name applies.</p>
<p>Regarding <tt class="docutils literal">/etc/resolv.conf</tt>:</p>
<pre class="code bash literal-block">
domain localdomain
nameserver xx.xx.xx.xx
<span class="o">[</span>...<span class="o">]</span>
</pre>
<p>Regarding <tt class="docutils literal">/etc/hosts</tt>:</p>
<pre class="code bash literal-block">
<span class="m">127</span>.0.0.1 localhost.localdomain localhost
::1       localhost
<span class="m">127</span>.0.1.1 hurricane.localdomain hurricane
<span class="o">[</span>...<span class="o">]</span>
</pre>
</div>
<div class="section" id="example-of-a-network-configuration-with-a-domain">
<h3>Example of a network configuration with a domain</h3>
<p>Here a specific domain is to be specified.</p>
<p>Regarding <tt class="docutils literal">/etc/resolv.conf</tt>:</p>
<pre class="code bash literal-block">
domain foobar.org
nameserver xx.xx.xx.xx
<span class="o">[</span>...<span class="o">]</span>
</pre>
<p>Regarding <tt class="docutils literal">/etc/hosts</tt>:</p>
<pre class="code bash literal-block">
<span class="m">127</span>.0.0.1 localhost.localdomain localhost
<span class="m">127</span>.0.1.1 hurricane.foobar.org hurricane
<span class="o">[</span>...<span class="o">]</span>
</pre>
</div>
<div class="section" id="testing-the-current-network-configuration">
<h3>Testing the current network configuration</h3>
<p>To anticipate a bit (one may come back to this point later), one may try to check whether the current network settings have a fair chance of being correct.</p>
<p>Supposing the FQDN of the localhost is <tt class="docutils literal">hurricane.foobar.org</tt> and that Erlang is already available, one may run:</p>
<pre class="code bash literal-block">
$ erl -name my_test
</pre>
<p>It shall result in a prompt like:</p>
<pre class="code erlang literal-block">
<span class="nv">Erlang</span><span class="o">/</span><span class="nv">OTP</span> <span class="mi">23</span> <span class="p">[</span><span class="n">erts</span><span class="o">-</span><span class="mi">11</span><span class="p">.</span><span class="mi">1</span><span class="p">.</span><span class="mi">4</span><span class="p">]</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="p">[</span><span class="mi">64</span><span class="o">-</span><span class="n">bit</span><span class="p">]</span> <span class="p">[</span><span class="nn">smp</span><span class="p">:</span><span class="mi">8</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="p">[...]</span>

<span class="nv">Eshell</span> <span class="nv">V11</span><span class="p">.</span><span class="mi">1</span><span class="p">.</span><span class="mi">4</span>  <span class="p">(</span><span class="n">abort</span> <span class="n">with</span> <span class="err">^</span><span class="nv">G</span><span class="p">)</span>
<span class="p">(</span><span class="n">my_test</span><span class="p">&#64;</span><span class="n">hurricane</span><span class="p">.</span><span class="n">foobar</span><span class="p">.</span><span class="n">org</span><span class="p">)</span><span class="mi">1</span><span class="o">&gt;</span>
</pre>
<p>The key being that the Erlang node name is <tt class="docutils literal">my_test&#64;hurricane.foobar.org</tt> indeed; for example, neither <tt class="docutils literal">my_test&#64;hurricane</tt> nor <tt class="docutils literal">my_test&#64;hurricane.acme.com</tt>.</p>
</div>
</div>
</div>
<div class="section" id="software-prerequisites">
<h1><a class="toc-backref" href="#id49">Software Prerequisites</a></h1>
<p>This installation procedure is quite detailed and takes into account different cases. Applying it should not be too difficult or time-consuming, and anyway it just needs to be done once; upgrading the Sim-Diasca version will then be transparent afterwards.</p>
<p>Some best-effort support is generally available by email (see contact address at the top of this document), should an issue be encountered.</p>
<p>We preferred to list below the widest possible range of tools here. This includes:</p>
<ul class="simple">
<li>the <strong>UNIX basics</strong> (ex: <tt class="docutils literal">grep</tt>, <tt class="docutils literal">awk</tt>, <tt class="docutils literal">sed</tt>, etc.); your distribution is expected to provide them out of the box</li>
<li>the software of which <strong>the simulation engine itself</strong> is composed (ex: the <tt class="docutils literal">Erlang</tt> runtime, the various intermediate layers)</li>
<li>the <strong>third-party tools</strong> that most simulators may trigger for their own purpose (ex: <tt class="docutils literal">LogMX</tt> to monitor and browse simulation traces, <tt class="docutils literal">gnuplot</tt> to render plots - one should ensure that its PNG support is enabled, possibly thanks to <tt class="docutils literal">libgd</tt> - or <tt class="docutils literal">graphviz</tt> to render graphs)</li>
<li>the <strong>other tools</strong> that, depending on the use cases, may be relied upon in order to post-process or make use of the simulation results (ex: <tt class="docutils literal">mplayer</tt>, to display generated videos)</li>
<li>finally, the <strong>toolchain</strong> that can be used to <em>build</em> the simulation engine and its dependencies (ex: to recreate the Sim-Diasca trace parser based on <tt class="docutils literal">LogMX</tt>)</li>
</ul>
<div class="section" id="software-needed">
<h2><a class="toc-backref" href="#id50">Software Needed</a></h2>
<p>Software prerequisites for a given <strong>host</strong> (computer) depend on the role of this host.</p>
<p>One must indeed distinguish here between two kinds of <strong>nodes</strong> (in the sense of Erlang) involved in a Sim-Diasca simulation:</p>
<ul class="simple">
<li>the (single) <strong>user node</strong>, from which the simulation is launched and run, and to which results are retrieved and potentially displayed; there must be exactly one user node per simulation</li>
<li>the (potentially numerous) <strong>computing nodes</strong>, which are in charge of the evaluation of all model instances and provide the resources needed by a parallel and distributed simulation; there must be at least one computing node per simulation (which is by default created on the same host as the user node)</li>
</ul>
<p>These nodes are mapped to actual networked hosts (workstations, computers involved in a cluster, etc.). The current approach is to have exactly one computing node on each computing host (thus federating all local processors and cores thanks to Erlang), and have a user node that may or (rarely) may not be on the same host as one of the computing nodes.</p>
<p>So, typically, should just one computer be used, Sim-Diasca will then spawn (and run on) two (Erlang, local) nodes (the user node and one computing node).</p>
<p>Should a simulation be distributed over three hosts, by default the user host will run a user node and a computing node, whereas the two other hosts will each run one computing node.</p>
<div class="section" id="tool-list-for-the-computing-nodes">
<h3>Tool List For the Computing Nodes</h3>
<p>An host that is to run only a computing node needs only to have a recent-enough Erlang environment installed (according to the conventions detailed below).</p>
<p>If additional distributed services are enabled (typically probes, whose result generation is by default itself parallel and distributed), then of course their prerequisites shall be available also on the computing nodes (ex: <tt class="docutils literal">gnuplot</tt> being then needed on them also).</p>
<p>As these needs form a subset of the needs of a user node, please refer to the next section.</p>
</div>
<div class="section" id="tool-list-for-the-user-node">
<h3>Tool List For the User Node</h3>
<p>On the targeted host the specific tools listed below and tagged <tt class="docutils literal">Mandatory</tt> <em>must</em> be available: if not readily available, the corresponding packages <a class="footnote-reference" href="#id4" id="id3">[4]</a> ought to be installed.</p>
<p>Some hints about each tool are specified below the table. Afterwards, all installation procedures that are not trivial are described.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[4]</a></td><td>The package names are the ones used by Debian-based distributions, including Ubuntu. Other distributions might use (often slightly) different names.</td></tr>
</tbody>
</table>
<p><span class="raw-html"><center></span></p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="21%" />
<col width="17%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Tool Name</th>
<th class="head">Corresponding
Debian Packages</th>
<th class="head">Tool Necessity</th>
<th class="head">Purpose</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Erlang</td>
<td><tt class="docutils literal">erlang</tt> (but not
to be installed
that way)</td>
<td>Mandatory</td>
<td>To generate and run Sim-Diasca. Installing
Erlang from sources is strongly recommended
(see below our script to automate that).</td>
</tr>
<tr><td>Myriad</td>
<td>(none)</td>
<td>Mandatory</td>
<td>Needed by Sim-Diasca. Myriad sources are
already included in the Sim-Diasca ones, so
nothing special is to be done for Myriad.</td>
</tr>
<tr><td>WOOPER</td>
<td>(none)</td>
<td>Mandatory</td>
<td>Needed by Sim-Diasca. WOOPER sources are
already included in the Sim-Diasca ones, so
nothing special is to be done for WOOPER.</td>
</tr>
<tr><td>Traces</td>
<td>(none)</td>
<td>Mandatory</td>
<td>Needed by Sim-Diasca. Traces sources are
already included in the Sim-Diasca ones, so
nothing special is to be done for Traces.</td>
</tr>
<tr><td>LogMX</td>
<td>(none)</td>
<td>Recommended</td>
<td>To monitor the simulation traces (this is the
default trace supervision tool).</td>
</tr>
<tr><td>Gnuplot</td>
<td><tt class="docutils literal">gnuplot</tt>,
<tt class="docutils literal"><span class="pre">gnuplot-nox</span></tt>
and
<tt class="docutils literal"><span class="pre">gnuplot-x11</span></tt></td>
<td>Mandatory</td>
<td>To generate plots of numerical data.</td>
</tr>
<tr><td>Dot</td>
<td><tt class="docutils literal">graphviz</tt></td>
<td>Strongly
recommended</td>
<td>To generate graph renderings.</td>
</tr>
<tr><td>GNU make</td>
<td><tt class="docutils literal">make</tt></td>
<td>Mandatory</td>
<td>To build and use Sim-Diasca.</td>
</tr>
<tr><td>ErlPort</td>
<td>N/A</td>
<td>Optional
(dataflow only)</td>
<td>Necessary if enabling the Python dataflow
binding.</td>
</tr>
<tr><td>Python 3</td>
<td>N/A</td>
<td>Optional
(dataflow only)</td>
<td>Necessary if enabling the Python dataflow
binding (obviously).</td>
</tr>
<tr><td>Java 8</td>
<td>N/A</td>
<td>Later
(dataflow only)</td>
<td>Necessary if enabling any (future) Java
dataflow binding (obviously).</td>
</tr>
<tr><td>Mplayer /
Mencode</td>
<td><tt class="docutils literal">mplayer</tt></td>
<td>Optional</td>
<td>To encode and display generated videos.</td>
</tr>
<tr><td>Geeqie (was
Gqview)</td>
<td><tt class="docutils literal">geeqie</tt> (formerly
<tt class="docutils literal">gqview</tt>)</td>
<td>Mandatory</td>
<td>To browse plots of time series and inspect
generated frames.</td>
</tr>
<tr><td>Eye of Gnome</td>
<td><tt class="docutils literal">eog</tt></td>
<td>Optional</td>
<td>To display generated images.</td>
</tr>
<tr><td>Emacs</td>
<td><tt class="docutils literal">emacs</tt></td>
<td>Optional</td>
<td>To edit Sim-Diasca sources, preferably using
the Erlang mode for that.</td>
</tr>
<tr><td>Nedit</td>
<td><tt class="docutils literal">nedit</tt></td>
<td>Very optional</td>
<td>To edit Sim-Diasca sources with a dedicated
WOOPER-aware syntax highlighting</td>
</tr>
<tr><td>GIT</td>
<td><tt class="docutils literal">git</tt></td>
<td>Optional</td>
<td>To be able to read and modify Sim-Diasca
sources, depending on access options.</td>
</tr>
<tr><td>GCC</td>
<td><tt class="docutils literal">gcc</tt></td>
<td>Recommended</td>
<td>Needed if building Erlang from sources (the
general case).</td>
</tr>
<tr><td>Ant</td>
<td><tt class="docutils literal">ant</tt></td>
<td>Optional</td>
<td>To build the Sim-Diasca Java Trace Parser
for LogMX (if ever needed - probably not).</td>
</tr>
<tr><td>Java (Oracle
version or
OpenJDK)</td>
<td><tt class="docutils literal"><span class="pre">sun-java6-jdk</span></tt>
or
<tt class="docutils literal"><span class="pre">openjdk-7-jre</span></tt></td>
<td>Optional</td>
<td>To be able to compile and run a
Sim-Diasca-enabled LogMX parser.</td>
</tr>
<tr><td>Docutils</td>
<td><tt class="docutils literal"><span class="pre">python-docutils</span></tt></td>
<td>Optional</td>
<td>To generate documentation files from RST
(reStructuredText mark-up).</td>
</tr>
<tr><td>LaTeX and all</td>
<td><tt class="docutils literal">texlive</tt></td>
<td>Optional</td>
<td>To generate PDF documentation.</td>
</tr>
<tr><td>Evince</td>
<td><tt class="docutils literal">evince</tt></td>
<td>Optional</td>
<td>To display (possibly generated) PDF files.</td>
</tr>
</tbody>
</table>
<p><span class="raw-html"></center></span></p>
</div>
<div class="section" id="package-walk-through">
<h3>Package Walk-Through</h3>
<p>Erlang and Sim-Diasca (including its <a class="reference external" href="https://olivier-boudeville.github.io/Ceylan-Myriad/">Myriad</a>, <a class="reference external" href="https://olivier-boudeville.github.io/Ceylan-WOOPER">WOOPER</a> and <a class="reference external" href="https://olivier-boudeville.github.io/Ceylan-Traces">Traces</a> layers) are of course needed and their installation is detailed in the next sections.</p>
<p>The use of a custom-built <tt class="docutils literal">Erlang</tt> environment is <em>strongly</em> recommended, to be able to rely on an adequately-configured and up-to-date version <a class="footnote-reference" href="#id7" id="id5">[5]</a>. Thus no need to install any distribution-specific prebuilt Erlang package <a class="footnote-reference" href="#id8" id="id6">[6]</a>, however the <tt class="docutils literal">GCC</tt> compiler (or any similar C compiler) must be available so that the build of Erlang can be performed.</p>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>In the past, some distributions shipped stripped-down versions of Erlang that happened to be incorrectly built (ex: lacking some components). Nowadays some include versions of Erlang that are way too ancient to be conveniently used. The last stable version of Erlang is always the best bet, and the Sim-Diasca developments tend to stick to it (possibly using bleeding edge additions, thus often <em>requiring</em> recent-enough versions of Erlang).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td>It is even safer not to have any <em>system-level</em> installation of Erlang, so that no version mismatch can ever happen, despite potential mistakes made in the user shell settings (note that a runtime checking of all the actual Erlang versions in use by each distributed host is performed). Thus one may only install first the dependencies of Erlang, i.e. the ones listed by the <a class="reference external" href="https://wiki.archlinux.org/index.php/Pacman/Rosetta#Querying_package_dependencies">&quot;show dependencies&quot; action</a> for your distribution of choice.</td></tr>
</tbody>
</table>
<p>In the context of the evaluation of dataflow, some simulation actors, typically dataflow processing units, may be implemented in <a class="reference external" href="https://www.python.org/">Python</a> (precisely: Python3``), in which case the Python binding shall be enabled; for that, <a class="reference external" href="http://erlport.org/">ErlPort</a> is needed, as well a recent enough version of Python.</p>
<p>The same binding effort has been initiated, yet not completed, for Java (no extra dependency would be needed then, except of course Java itself, in its <tt class="docutils literal">8.0</tt> version of newer).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please note that such bindings are meant to apply <em>only in a dataflow context</em> (i.e. for the specific API borne by the processing unit): these are not general-purpose, actor-level bindings. Even if developing such generic bindings would certainly be feasible, no sufficient need arose yet to trigger their development. Contributions welcome!</p>
</div>
<p>An image viewer, a PDF viewer and a video player are generally useful to browse Sim-Diasca outputs. Defaults are, respectively: <em>Geeqie</em> (<tt class="docutils literal">geeqie</tt>, previously known as <tt class="docutils literal">gqview</tt>), <em>Evince</em> (<tt class="docutils literal">evince</tt>), and <em>Mplayer</em> (<tt class="docutils literal">mplayer</tt>), but they can be replaced very easily, in Sim-Diasca code, by any counterparts that would be preferred <a class="footnote-reference" href="#id10" id="id9">[7]</a>.</p>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[7]</a></td><td>For that refer to the <em>default tool section</em> in <tt class="docutils literal">myriad/src/utils/executable_utils.erl</tt>.</td></tr>
</tbody>
</table>
<p>Depending on the version of the <tt class="docutils literal">Java Runtime Environment</tt> (JRE) which is available on the user host, the prebuilt Sim-Diasca trace parser may be directly used (this is generally the case), otherwise it will have to be rebuilt from its sources. In this latter (unlikely) case only, <tt class="docutils literal">Ant</tt> and a <tt class="docutils literal">Java SDK</tt> will be needed.</p>
<p><tt class="docutils literal">Docutils</tt>, <tt class="docutils literal">LaTeX</tt> and all are only useful if wanting to be able to generate the documentation of Sim-Diasca, or PDF-based trace reports.</p>
<p>GIT is needed only if using a repository (either EDF-internal or public) in order to retrieve the Sim-Diasca sources; otherwise of course sources could come from a released archive instead.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If some actual development <em>on</em> Sim-Diasca, or <em>with</em> Sim-Diasca, was to be performed (beyond mere testing), then relying on a GIT clone rather than on a source archive should be preferred, so that Sim-Diasca can be updated accordingly (and in both directions) with little effort.</p>
</div>
<p>The choice in terms of text editor is a matter of taste, any should be suitable (including <tt class="docutils literal">Emacs</tt> or IDEs like <a class="reference external" href="https://erlide.org">Erlide</a>, based on <a class="reference external" href="http://www.eclipse.org/">Eclipse</a>).</p>
<p>Finally, users of Debian-based distributions (Jeesie, Wheezy) could just start with the following command to install the main prerequisite packages:</p>
<pre class="code bash literal-block">
<span class="c1"># Depending on version, libwxgtk3.0-dev could/should be replaced
# with libwxgtk-webview3.0-gtk3-dev:
#
</span>$ sudo apt-get install bzip2 coreutils build-essential g++       <span class="se">\
</span>  libncurses5-dev openssl libssl-dev libwxgtk3.0-dev             <span class="se">\
</span>  libgl1-mesa-dev libglu1-mesa-dev libpng3                       <span class="se">\
</span>  python-docutils eog evince gcc gnuplot gnuplot-x11             <span class="se">\
</span>  geeqie graphviz uuid-runtime make mplayer ant                  <span class="se">\
</span>  openjdk-8-jdk texlive python3
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On an headless server (with no GUI, like for some cluster hosts), <tt class="docutils literal"><span class="pre">gnuplot-x11</span></tt> may be replaced with <tt class="docutils literal"><span class="pre">gnuplot-nox</span></tt>.</p>
</div>
</div>
</div>
<div class="section" id="preparing-the-sim-diasca-sources">
<h2><a class="toc-backref" href="#id51">Preparing the Sim-Diasca sources</a></h2>
<p>The sources of Sim-Diasca can be obtained either from a GIT repository (recommended approach) or from an archive file. Both cases are detailed below.</p>
<div class="section" id="installation-from-the-sim-diasca-public-git-repository">
<h3>Installation From the Sim-Diasca Public GIT Repository</h3>
<p>Unless you have access to the EDF-internal Sim-Diasca GIT repository (which should then be preferred, as it contains more content, and is by design more recent), you can clone the public GIT repository (which should be fine as well <a class="footnote-reference" href="#id12" id="id11">[8]</a>), at the following location: <a class="reference external" href="https://github.com/Olivier-Boudeville-EDF/Sim-Diasca">https://github.com/Olivier-Boudeville-EDF/Sim-Diasca</a>.</p>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[8]</a></td><td>Please tell us (typically thanks to the e-mail address at the top of this document) if ever the current public version seems to date back a bit too much, as we do not always update the public version once an internal one has been released.</td></tr>
</tbody>
</table>
<p>It can thus be obtained, typically from a GNU/Linux host, thanks to:</p>
<pre class="code bash literal-block">
$ git clone https://github.com/Olivier-Boudeville-EDF/Sim-Diasca
</pre>
<p>Then a right branch or tag shall be selected, knowing that versions bear annotated tags now labelled as: <tt class="docutils literal"><span class="pre">sim-diasca-x.y.z-version</span></tt>.</p>
<p>The <tt class="docutils literal">master</tt> branch is the main one, and contains the latest public version of Sim-Diasca that has been released, so most people will happily stick to this <tt class="docutils literal">master</tt> branch.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The public repository is not the actual one that is used to develop Sim-Diasca, yet pull requests or any interaction may be based on it; if appropriate, we will take care of any integration that would be useful, and such improvements are to benefit to the community as a whole, in the next public versions to be released afterwards.</p>
</div>
</div>
<div class="section" id="installation-from-a-sim-diasca-archive">
<h3>Installation From a Sim-Diasca Archive</h3>
<p>You should have been given a Sim-Diasca archive, probably corresponding to a stable version (ex: <tt class="docutils literal"><span class="pre">Sim-Diasca-a.b.c.tar.xz</span></tt>, like in <tt class="docutils literal"><span class="pre">Sim-Diasca-2.2.11.tar.xz</span></tt>) or a release candidate version, in the form of <tt class="docutils literal"><span class="pre">Sim-Diasca-a.b.c-rcd.tar.xz</span></tt> (like in <tt class="docutils literal"><span class="pre">Sim-Diasca-2.2.11-rc3.tar.xz</span></tt>). In 2015 we stopped using <a class="reference external" href="http://semver.org/">Semantic Versioning</a> to switch back to the plain old versioning scheme.</p>
<p>In a directory on which you have read/write access and enough space left, extract that Sim-Diasca archive, using a proper <tt class="docutils literal">tar</tt> incantation:</p>
<p><span class="raw-html"><center><img src="xkcd-tar.png" id="responsive-image-intermediate"></img></center></span>
</p>
<p>For example:</p>
<pre class="code bash literal-block">
$ tar xvf Sim-Diasca-a.b.c.tar.xz
</pre>
<p>This should create a root directory named <tt class="docutils literal"><span class="pre">Sim-Diasca-a.b.c</span></tt> which contains all the relevant sources, including various top-level directories (<tt class="docutils literal">myriad</tt>, <tt class="docutils literal">wooper</tt>, <tt class="docutils literal">traces</tt>, <tt class="docutils literal"><span class="pre">sim-diasca</span></tt>, etc.).</p>
<p>From now on, non-absolute paths (ex: <tt class="docutils literal"><span class="pre">mock-simulators/soda-test/...</span></tt>) must be understood as being relative to this root directory.</p>
</div>
</div>
</div>
<div class="section" id="installing-erlang">
<h1><a class="toc-backref" href="#id52">Installing Erlang</a></h1>
<p>Sim-Diasca is essentially written in <a class="reference external" href="http://erlang.org">Erlang</a>, thus as soon as it will have to run on a given host, it will require a proper Erlang environment to be available on this host beforehand.</p>
<p>This means that <strong>all the computing hosts that may be used in the context of a distributed simulation must have access to such an Erlang environment</strong>, with compatible versions. There are various ways of ensuring it, including the cases where:</p>
<ul class="simple">
<li>an appropriate Erlang environment is already built-in on the host operating system</li>
<li>the hosts have access to some shared infrastructure (ex: a distributed filesystem, like NFS) - it is generally the case with HPC clusters</li>
<li>a dedicated installation is performed on each of them</li>
</ul>
<p>Although older versions of Erlang were supported (initially starting from <tt class="docutils literal"><span class="pre">R12B-5</span></tt>, released on November 5, 2008), API and typing changes require now using Erlang versions that are considerably more recent. One may preferably rely on the latest stable version available, as it is both more robust and efficient, and this is the one that is used by the developers of the engine. This version was usually in the form <tt class="docutils literal">RxBy</tt>, like <tt class="docutils literal">R16B</tt>, and now is named typically as <tt class="docutils literal">OTP 23.2</tt> at the time of this writing. As the engine relies on some features introduced in <tt class="docutils literal">OTP 23.0</tt>, this version, or more recent, shall be used.</p>
<p><strong>Erlang will then be preferably built from sources, rather than be installed thanks to the package manager of the distribution at hand</strong>, in order to benefit from an unmodified cutting-edge stable version that additionally will be built with the finely-tuned configuration deemed the most appropriate in a Sim-Diasca context <a class="footnote-reference" href="#id14" id="id13">[9]</a>.</p>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[9]</a></td><td>We already saw very popular distributions attempting to split the Erlang environment into subpackages and ending up with a very non-functional software.</td></tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The libncurses development files (ex: the <tt class="docutils literal"><span class="pre">libncurses5-dev</span></tt> package, for Debian-based distributions) are needed to build Erlang.</p>
<p>Similarly, the OpenSSL development files (i.e. the <tt class="docutils literal">openssl</tt> and <tt class="docutils literal"><span class="pre">libssl-dev</span></tt> packages, for Debian-based distributions) are needed for the <tt class="docutils literal">crypto</tt> Erlang module to be available, as we prefer to rely on better-quality random generation (in the future we may use <em>Tiny Mersenne Twister</em> - <tt class="docutils literal">TinyMT</tt>, or a library dedicated to stochastic management).</p>
<p>Finally, newer Erlang graphical services rely on WxWidgets, whose packages (notably <tt class="docutils literal"><span class="pre">libwxgtk2.8-dev</span></tt> and their own prerequisites, <tt class="docutils literal"><span class="pre">libgl1-mesa-dev</span></tt>, <tt class="docutils literal"><span class="pre">libglu1-mesa-dev</span></tt>, <tt class="docutils literal">libpng3</tt> and <tt class="docutils literal">g++</tt>) are preferably to be installed (needed for the <tt class="docutils literal">wx</tt> and <tt class="docutils literal">observer</tt> modules for example).</p>
<p>Therefore all these packages should be installed beforehand. Build tools, notably gcc and GNU make, should be available as well.</p>
<p>So, to obtain a proper Erlang installation, users of Debian-based distributions may run the following command (in one line):</p>
<pre class="code bash last literal-block">
$ sudo apt-get install g++ make libncurses5-dev openssl <span class="se">\
</span>  libssl-dev libwxgtk3.0-dev libgl1-mesa-dev            <span class="se">\
</span>  libglu1-mesa-dev libpng3
</pre>
</div>
<p>For such an installation from sources, in the <tt class="docutils literal">myriad/conf</tt> directory of the Sim-Diasca codebase a script named <tt class="docutils literal"><span class="pre">install-erlang.sh</span></tt> is provided <a class="footnote-reference" href="#id16" id="id15">[10]</a>.</p>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[10]</a></td><td>Also available at <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Myriad/blob/master/conf/install-erlang.sh">install-erlang.sh</a>.</td></tr>
</tbody>
</table>
<p>If you have a direct connection to the Internet, it can automatically download the Erlang sources, and then build and install them appropriately; otherwise, typically if being behind a proxy, one may download first by oneself the relevant archives (namely <tt class="docutils literal">OTP x.y Source File</tt> and <tt class="docutils literal">OTP x.y HTML Documentation File</tt>) from <a class="reference external" href="https://www.erlang.org/downloads">here</a>.</p>
<p>You can then either run the installation script &quot;as is&quot; (with or without a prefix being specified as parameter) or, if preferred, modify its settings appropriately beforehand, or just get inspiration from it instead and then install Erlang directly from the shell.</p>
<p><tt class="docutils literal"><span class="pre">install-erlang.sh</span> <span class="pre">--help</span></tt> will provide more usage information, notably on whether it should be run as root or not, installed in a prefixed directory or in the system tree, with a selection of options (ex: to prevent any attempt of downloading said archives), etc.</p>
<p>From a well-chosen, separate directory (ex: <tt class="docutils literal">~/Software/Erlang</tt>, to avoid mixing the sources of Erlang with the ones of Sim-Diasca), one could run <a class="footnote-reference" href="#id18" id="id17">[11]</a> for example:</p>
<pre class="code bash literal-block">
<span class="nv">$DIR</span>/myriad/conf/install-erlang.sh
</pre>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[11]</a></td><td>Just ensure that any pre-dowloaded archives are available from that directory.</td></tr>
</tbody>
</table>
<p>or, if a specific installation prefix is to be used:</p>
<pre class="code bash literal-block">
<span class="nv">$DIR</span>/myriad/conf/install-erlang.sh /opt/my-tools-repository
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">One should not execute this script directly from its containing directory (<tt class="docutils literal">myriad/conf</tt>); instead the script shall be run <strong>from outside any build tree related to Sim-Diasca</strong> - a safe, recommended choice being <tt class="docutils literal">~/Software/Erlang</tt> <a class="footnote-reference" href="#id20" id="id19">[12]</a>.</p>
</div>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[12]</a></td><td><p class="first">Otherwise, as the Erlang source archive is extracted in the current directory of the install script, the full build tree of Erlang (typically named <tt class="docutils literal">otp_src_x.y</tt>) would end up in <tt class="docutils literal">myriad/conf</tt>.</p>
<p>Then, at deployment time, when Sim-Diasca scans recursively the build trees of its prerequisite layers (namely, from bottom-up: <a class="reference external" href="http://myriad.esperide.org/">Myriad</a>, <a class="reference external" href="http://wooper.esperide.org/">WOOPER</a> and <a class="reference external" href="http://traces.esperide.org/">Traces</a>; note that for convenience they are already integrated into the distributed Sim-Diasca codebase) in order to gather their BEAM files in its simulation package, it would select unnecessarily all the ones of Erlang itself as well (whereas they are expected to already be installed in each node) - leading for example to drastically longer deployment durations, very large simulation archives typically ending up with deployment time-outs.</p>
<p class="last">A mechanism has been added in order to detect such cases.</p>
</td></tr>
</tbody>
</table>
<p>In all cases, you should end up with an installed version of the latest stable source of Erlang.</p>
<p>Sim-Diasca developers could prefer installing automatically this version, along with its associated documentation, in an <strong>ad hoc software repository</strong> (ex: <tt class="docutils literal">~/Software/Erlang/</tt>), where successive versions of the tools would be installed over time (it is quite convenient to switch versions).</p>
<p>The simplest and recommended approach is to run the installation script directly from such any software repository of choice (<em>not</em> located within the Sim-Diasca codebase), and to add the <tt class="docutils literal"><span class="pre">--doc-install</span></tt> option in order to obtain the documentation as well, like in:</p>
<pre class="code bash literal-block">
$ mkdir -p ~/Software/Erlang
$ <span class="nb">cd</span> ~/Software/Erlang
$ <span class="nv">$DIR</span>/myriad/conf/install-erlang.sh --doc-install
</pre>
<p>Let's call <tt class="docutils literal">V</tt> the Erlang version number selected by the script (ex: <tt class="docutils literal">V=23.2</tt>).</p>
<p>The actual installation directory will then be:</p>
<ul class="simple">
<li>if no prefix was specified (recommended case):<ul>
<li>if the install script is run as root (<em>not</em> recommended), Erlang will be directly installed in <tt class="docutils literal">/usr/local</tt></li>
<li>otherwise (recommended): in <tt class="docutils literal"><span class="pre">~/Software/Erlang/Erlang-$V</span></tt></li>
</ul>
</li>
<li>if a prefix PREFIX was specified, installation will be done in <tt class="docutils literal"><span class="pre">PREFIX/Erlang/Erlang-$V</span></tt></li>
</ul>
<p>To allow for any later recompilation (ex: should some options be changed), if no prefix was specified and if the installation script is not run as root, the <strong>Erlang build tree</strong> (<tt class="docutils literal">otp_src_x.y</tt>) is <em>not</em> removed after the installation. Should the current directory (whence the user ran the installation script) be located within the build tree of any part of Sim-Diasca, the corresponding <tt class="docutils literal">otp_src_x.y</tt> directory <em>must</em> be removed by the user, so that the Erlang BEAM files cannot be mixed up with the ones of that layer. In other cases, one may or may not prefer removing the OTP build tree or even the Erlang archives (typically <tt class="docutils literal">otp_*_x.y.tar.gz</tt>).</p>
<p>If intending to make any actual development in the future (ex: writing a specialized simulator, adding models or operating on the Sim-Diasca code itself), one should add the <tt class="docutils literal"><span class="pre">--generate-plt</span></tt> option to the <tt class="docutils literal"><span class="pre">install-erlang.sh</span></tt> command-line. It will pre-process Erlang files to generate a <em>PLT file</em> that will be later reused by the <a class="reference external" href="http://www.it.uu.se/research/group/hipe/dialyzer">Dialyzer</a> tool for code analysis. Please refer to the <em>Using Type Specifications With Sim-Diasca</em> section of the <em>Sim-Diasca Developer Guide</em> for further information.</p>
<p>Running the installation script should create, in the target installation directory, two corresponding sub-directories, <tt class="docutils literal"><span class="pre">Erlang-$V</span></tt> and <tt class="docutils literal"><span class="pre">Erlang-$V-documentation</span></tt>, containing respectively the Erlang runtime and its corresponding documentation, if it was selected.</p>
<p>Additionally, in this installation directory two symbolic links (<tt class="docutils literal"><span class="pre">Erlang-current-install</span></tt> and <tt class="docutils literal"><span class="pre">Erlang-current-documentation</span></tt>) will also be automatically created or updated, to point to these newly installed directories, so that one can register in one's settings files (ex: <tt class="docutils literal"><span class="pre">~/.bashrc</span></tt>) appropriate paths referring to these <strong>links</strong>: further Erlang updates will then not require the user to update his settings, while prior installed versions will remain available through the use of their full path.</p>
<p>So one may end up with a directory layout like:</p>
<pre class="code bash literal-block">
$ tree -L <span class="m">1</span> -d ~/Software/Erlang/
/home/dalton/Software/Erlang/
<span class="p">|</span>-- Erlang-R14B
<span class="p">|</span>-- Erlang-R14B-documentation
<span class="p">|</span>-- Erlang-R16B
<span class="p">|</span>-- Erlang-R16B-documentation
<span class="p">|</span>-- Erlang-23.2
<span class="p">|</span>-- Erlang-23.2-documentation
<span class="p">|</span>-- Erlang-current-documentation -&gt; Erlang-23.2-documentation
<span class="sb">`</span>-- Erlang-current-install -&gt; Erlang-23.2
</pre>
<p>In the general case (i.e. unless run as root with no prefix specified), the new Erlang environment will be installed in a prefix, thus probably it will not be readily available from the shell. As a consequence one should ensure that the Erlang compiler (<tt class="docutils literal">erlc</tt>) and the corresponding interpreter (<tt class="docutils literal">erl</tt>) <a class="footnote-reference" href="#id25" id="id24">[13]</a> can be found directly from the <tt class="docutils literal">PATH</tt> (both are in the same directory).</p>
<table class="docutils footnote" frame="void" id="id25" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id24">[13]</a></td><td>The Erlang compiler transforms Erlang code (in <tt class="docutils literal">*.erl</tt>/<tt class="docutils literal">*.hrl</tt> files) into BEAM bytecodes (<tt class="docutils literal">*.beam</tt>) suitable for the <em>Erlang Virtual Machine</em>. They can then be executed by the Erlang interpreter.</td></tr>
</tbody>
</table>
<p>For example, directly from a <tt class="docutils literal">bash</tt> shell:</p>
<pre class="code bash literal-block">
$ <span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span>~/Software/Erlang/Erlang-current-install/bin:<span class="nv">$PATH</span>
$ <span class="nb">cd</span> ~
$ <span class="nb">type</span> erl
erl is /home/dalton/Software/Erlang/Erlang-current-install/bin/erl
</pre>
<p>Setting also the relevant path, one time for all (rather than on a single short-lived terminal) in the shell configuration of the user (ex: <tt class="docutils literal"><span class="pre">~/.bashrc</span></tt>) is mandatory for further uses as well; as a consequence, please add the relevant export in the configuration file of your shell of choice.</p>
<p>Finally, two simple tests allow to ensure that Erlang can run flawlessly in this new environment. The first one allows to check that we are using the expected version and that it can indeed be run (you have to enter CTRL-C twice to close the Erlang shell afterwards):</p>
<pre class="code bash literal-block">
$ <span class="nb">cd</span>
$ <span class="nb">type</span> erl
erl is /home/dalton/Software/Erlang/Erlang-current-install/bin/erl
$ erl
Erlang/OTP <span class="m">23</span> <span class="o">[</span>erts-11.1.4<span class="o">]</span> <span class="o">[</span>source<span class="o">]</span> <span class="o">[</span><span class="m">64</span>-bit<span class="o">]</span> <span class="o">[</span>smp:8:8<span class="o">]</span> <span class="o">[</span>ds:8:8:10<span class="o">]</span> <span class="o">[</span>async-threads:10<span class="o">]</span> <span class="o">[</span>hipe<span class="o">]</span> <span class="o">[</span>kernel-poll:false<span class="o">]</span>

Eshell v11.1.4  <span class="o">(</span>abort with ^G<span class="o">)</span>
</pre>
<p>Second test allows to check that your network configuration allows to run a <em>networked</em> Erlang virtual machine with long names (enter again CTRL-C twice to exit):</p>
<pre class="code bash literal-block">
$ erl -name this_is_a_test
Erlang/OTP <span class="m">23</span> <span class="o">[</span>erts-11.1.4<span class="o">]</span> <span class="o">[</span>source<span class="o">]</span> <span class="o">[</span><span class="m">64</span>-bit<span class="o">]</span> <span class="o">[</span>smp:8:8<span class="o">]</span> <span class="o">[</span>ds:8:8:10<span class="o">]</span> <span class="o">[</span>async-threads:10<span class="o">]</span> <span class="o">[</span>hipe<span class="o">]</span> <span class="o">[</span>kernel-poll:false<span class="o">]</span>

Eshell V11.1.4  <span class="o">(</span>abort with ^G<span class="o">)</span>
<span class="o">(</span>this_is_a_test&#64;foo.bar.org <span class="o">)</span><span class="m">1</span>&gt;
</pre>
<p>Refer to the <a class="reference internal" href="#name-resolving">Name Resolving</a> section should this test fail.</p>
</div>
<div class="section" id="installing-logmx">
<h1><a class="toc-backref" href="#id53">Installing LogMX</a></h1>
<p>LogMX is the default tool used here to monitor the distributed simulation traces (refer to the <a class="reference external" href="http://traces.esperide.org/">Ceylan-Traces website</a> for more information on that layer).</p>
<p>Using this proprietary tool is fully optional: adding the command-line option <tt class="docutils literal"><span class="pre">CMD_LINE_OPT=&quot;--batch&quot;</span></tt> will disable its automatic launching by the engine. As, however, we believe that being able to easily inspect the simulation traces is essential in order to make the best use of the engine, we recommend to install this tool.</p>
<p>Although its purpose is only to allow to supervise the Sim-Diasca traces, its installation requires quite a lot of explanations, especially to deal with the case where the Sim-Diasca parser for LogMX has to be rebuilt from its sources (this is generally not needed, though).</p>
<p>A prerequisite to running LogMX is to have the <tt class="docutils literal">Java SE Runtime Environment</tt> installed on the user host, preferably the (free software) OpenJDK version.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">LogMX can accommodate older versions of Java. However, if planning to use the Sim-Diasca Java Binding, then Java version <tt class="docutils literal">8.0</tt> or newer must be used.</p>
</div>
<p>For example, Java 7 could suffice for LogMX:</p>
<pre class="code bash literal-block">
$ java -version
java version <span class="s2">&quot;1.7.0_111&quot;</span>
OpenJDK Runtime Environment <span class="o">(</span>IcedTea <span class="m">2</span>.6.7<span class="o">)</span> <span class="o">(</span>Arch Linux build <span class="m">7</span>.u111_2.6.7-1-x86_64<span class="o">)</span>
OpenJDK <span class="m">64</span>-Bit Server VM <span class="o">(</span>build <span class="m">24</span>.111-b01, mixed mode<span class="o">)</span>
</pre>
<p>Otherwise the <tt class="docutils literal">Sun</tt> (Oracle) version could be used, like in:</p>
<pre class="code bash literal-block">
$ java -version
java version <span class="s2">&quot;1.6.0_10&quot;</span>
Java<span class="o">(</span>TM<span class="o">)</span> SE Runtime Environment <span class="o">(</span>build <span class="m">1</span>.6.0_10-b33<span class="o">)</span>
Java HotSpot<span class="o">(</span>TM<span class="o">)</span> Client VM <span class="o">(</span>build <span class="m">11</span>.0-b15, mixed mode, sharing<span class="o">)</span>
</pre>
<p>If not available, either the package manager of the distribution <a class="footnote-reference" href="#id27" id="id26">[14]</a> or this <a class="reference external" href="http://java.sun.com/javase/downloads/index.jsp">link</a> for the Sun version should be used.</p>
<table class="docutils footnote" frame="void" id="id27" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id26">[14]</a></td><td>Example: for Debian-based distributions, <tt class="docutils literal"><span class="pre">apt-get</span> install <span class="pre">openjdk-8-jdk</span></tt> or <tt class="docutils literal"><span class="pre">apt-get</span> install <span class="pre">sun-java8-jdk</span></tt> can be used; or, for Arch Linux, <tt class="docutils literal">pacman <span class="pre">-S</span> <span class="pre">jdk8-openjdk</span></tt> may be used.</td></tr>
</tbody>
</table>
<p>Note that if only the <tt class="docutils literal">Java SE Runtime Environment</tt> (i.e. the JRE) is installed (instead of the <tt class="docutils literal">Java SE Development Kit</tt>, i.e. the JDK), then Java code can be executed indeed, but not generated.</p>
<p>However both cases should work, since using a recent JRE should spare the rebuilding of the Sim-Diasca parser (and hence the use of the JDK).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">With some distributions (ex: Ubuntu), the default JRE is headless (which means that the JRE does not provide the dependencies used for the graphical components). Fixing this issue is as easy as installing the missing dependencies (<tt class="docutils literal"><span class="pre">apt-get</span> install <span class="pre">openjdk-8-jre</span></tt>).</p>
</div>
<div class="section" id="getting-logmx">
<h2><a class="toc-backref" href="#id54">Getting LogMX</a></h2>
<p>LogMX is a proprietary software, thus it cannot be found in package repositories.
If not supplied by your organisation, it should be directly downloaded from <a class="reference external" href="http://www.logmx.com/p_download.php">that location</a>, in its latest version, either the free <tt class="docutils literal">Evaluation</tt> version or the <tt class="docutils literal">Professional</tt> one (both of which can be used by Sim-Diasca).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you plan to make a commercial use of LogMX, then according to its licence you must purchase its quite inexpensive professional version. In this case all paths in the form of <tt class="docutils literal">LogMX_vx.y.z</tt> should be translated into paths in the form of <tt class="docutils literal">LogMX_vx.y.z_pro</tt>.</p>
</div>
<p>LogMX archive should be extracted, preferably in the same install directory as other tools.</p>
<p>For example:</p>
<pre class="code bash literal-block">
$ mkdir -p ~/Software/LogMX
$ <span class="nb">cd</span> ~/Software/LogMX
$ cp ~/LogMX_vx.y.z.zip .
$ unzip LogMX_vx.y.z.zip
</pre>
<p>It must then be appropriately configured and linked to a proper Sim-Diasca parser, as shown below.</p>
</div>
<div class="section" id="setting-up-logmx">
<h2><a class="toc-backref" href="#id55">Setting Up LogMX</a></h2>
<div class="section" id="configuration-files">
<h3>Configuration Files</h3>
<p>Sim-Diasca provides, in the <tt class="docutils literal">traces/conf/logmx</tt> directory, the following configuration files:</p>
<ul class="simple">
<li><tt class="docutils literal">logmx.properties</tt></li>
<li><tt class="docutils literal">managers.properties</tt></li>
<li><tt class="docutils literal">parsers.properties</tt></li>
</ul>
<p>They should be copied in the LogMX <tt class="docutils literal">config</tt> directory. These files should overwrite the default LogMX ones. For example:</p>
<pre class="code bash literal-block">
$ <span class="k">for</span> f in logmx.properties managers.properties parsers.properties<span class="p">;</span> <span class="k">do</span> <span class="se">\
</span>/bin/cp traces/conf/logmx/<span class="nv">$f</span> ~/Software/LogMX/LogMX_vx.y.z/config <span class="p">;</span>    <span class="se">\
</span><span class="k">done</span>
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you purchased the LogMX professional version, copy the <tt class="docutils literal">license.properties</tt> file that you obtained in the LogMX <tt class="docutils literal">config</tt> directory instead of the supplied one (and of course keep the other properties-related files).</p>
</div>
<p>The LogMX script must then be set to executable:</p>
<pre class="code bash literal-block">
$ chmod +x ~/Software/LogMX/LogMX_vx.y.z/logmx.sh
</pre>
<p>Identically to <tt class="docutils literal">Erlang</tt>, the LogMX script must be found from the path. For example, with a <tt class="docutils literal">bash</tt> shell:</p>
<pre class="code bash literal-block">
$ <span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span>~/Software/LogMX/LogMX_vx.y.z:<span class="nv">$PATH</span>
$ <span class="nb">cd</span> ~
$ <span class="nb">type</span> logmx.sh
logmx.sh is /home/dalton/Software/LogMX/LogMX_vx.y.z/logmx.sh
</pre>
<p>Setting also the relevant path in the shell configuration (ex: <tt class="docutils literal"><span class="pre">~/.bashrc</span></tt>) is recommended for further uses.</p>
<p>A best practise for that is to install all custom software in a base directory (ex: <tt class="docutils literal">~/Software/</tt>), with a sub-directory for each tool (ex: <tt class="docutils literal">~/Software/LogMX/</tt>). Then all successive versions of that tool could be installed here (ex: <tt class="docutils literal">~/Software/LogMX/LogMX_v7.3.0/</tt>).</p>
<p>Finally, a symbolic link pointing to the latest current version could be defined when installing a new version of that tool (ex: <tt class="docutils literal">cd ~/Software/LogMX/; ln <span class="pre">-sf</span> LogMX_v7.3.0 <span class="pre">LogMX-current-install</span></tt>).</p>
<p>That way, one just has to specify in one's shell configuration:</p>
<pre class="code bash literal-block">
<span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span>~/Software/LogMX/LogMX-current-install:<span class="nv">$PATH</span>
</pre>
<p>This is thus done once for all, it will not have to be updated when upgrading LogMX.</p>
<p>LogMX should then be run &quot;as is&quot;, to ensure that it has a chance to run later, when the Sim-Diasca parser will be plugged-in:</p>
<pre class="code bash literal-block">
$ logmx.sh
</pre>
<p>After up to a few seconds, a LogMX window should successfully pop up. Then close that window.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>On some LogMX versions, running this <tt class="docutils literal">logmx.sh</tt> script will output a line on the console complaining about a <tt class="docutils literal">startup.conf</tt> file being not found, or printing <tt class="docutils literal">[: 86: 1: unexpected operator</tt> and <tt class="docutils literal">[: 86: 0: unexpected operator</tt>.</p>
<p class="last">A simple solution is to edit <tt class="docutils literal">logmx.sh</tt> and replace the <tt class="docutils literal"><span class="pre">STARTUP_CONF_FILE=&quot;startup.conf&quot;</span></tt> line (around line 35) by <tt class="docutils literal"><span class="pre">STARTUP_CONF_FILE=/dev/null</span></tt>.</p>
</div>
</div>
<div class="section" id="setting-up-the-sim-diasca-trace-parser">
<h3>Setting Up the Sim-Diasca Trace Parser</h3>
<p>Due to Java, this is probably the trickiest (optional, yet recommended) part of a Sim-Diasca install.</p>
<div class="section" id="using-the-prebuilt-sim-diasca-parser">
<h4>Using The Prebuilt Sim-Diasca Parser</h4>
<p>In the <tt class="docutils literal">traces/conf/logmx</tt> directory, there is a prebuilt Java class, <tt class="docutils literal">CeylanTraceParser.class</tt>, a generic parser we developed for Sim-Diasca and other tools.</p>
<p>If the Java environment installed on the host is recent enough (which is very likely), then that class file will be directly usable, without further need of recompiling it.</p>
<p>Best option is to try to use it directly, and to rebuild the parser only if this fails.</p>
<p>That file should just be copied to the right location:</p>
<pre class="code bash literal-block">
$ <span class="nv">CLASS_DIR</span><span class="o">=</span>~/Software/LogMX/LogMX_vx.y.z/parsers/classes/ceylan/parser
$ mkdir -p <span class="nv">$CLASS_DIR</span>
$ cp traces/conf/logmx/CeylanTraceParser.class <span class="nv">$CLASS_DIR</span>
</pre>
</div>
<div class="section" id="checking-that-the-sim-diasca-parser-works-properly">
<h4>Checking That The Sim-Diasca Parser Works Properly</h4>
<p>To do so, just test, from the root of the sources, whether LogMX and the Sim-Diasca parser are correctly integrated, with a sample of Sim-Diasca traces:</p>
<pre class="code bash literal-block">
$ logmx.sh traces/conf/logmx/TraceSample.txt
</pre>
<p>You can skip next section if you see something like:</p>
<p><span class="raw-html"><center><img src="logmx-interface.png" id="responsive-image-large"></img></center></span>
</p>
<p>Otherwise, an error like <tt class="docutils literal">Error while instantiating parser</tt> must have been reported: your Java environment is most probably not appropriate (too old?), and, <strong>if</strong> you are not able to upgrade the Java interpreter that you are using, then unfortunately the parser will have to be rebuilt with all the Java bells and whistles, as explained in the next section (usually this issue does not occur, and one can thus jump directly to the <a class="reference internal" href="#checking-which-tools-sim-diasca-will-use">Checking Which Tools Sim-Diasca Will Use</a> section).</p>
</div>
<div class="section" id="building-the-sim-diasca-trace-parser">
<h4>Building The Sim-Diasca Trace Parser</h4>
<p>The <tt class="docutils literal">Java SE Development Kit</tt> (i.e. the JDK) and <tt class="docutils literal">Ant</tt> are needed here.</p>
<p>They can be installed either thanks to the distribution, for example:</p>
<pre class="code bash literal-block">
$ sudo apt-get install openjdk-8-jdk ant
   - or -
$ sudo apt-get install sun-java8-jdk ant
</pre>
<p>or they can be retrieved from their respective official sites (<a class="reference external" href="http://java.sun.com/javase/downloads/index.jsp">1</a>, <a class="reference external" href="http://ant.apache.org">2</a>), if not directly built and installed from sources (for Ant).</p>
<p>Then the Sim-Diasca parser source file should be placed at the right location in the LogMX tree, and built:</p>
<pre class="code bash literal-block">
$ <span class="nv">PARSER_SRC_DIR</span><span class="o">=</span>~/Software/LogMX/LogMX_vx.y.z/parsers/src/ceylan/parser
$ mkdir -p <span class="nv">$PARSER_SRC_DIR</span>
$ cp traces/conf/logmx/CeylanTraceParser.java <span class="nv">$PARSER_SRC_DIR</span>
$ <span class="nb">cd</span> ~/Software/LogMX/LogMX_vx.y.z/parsers
$ ant
Buildfile: build.xml
clean:
mkoutdir:
 <span class="o">[</span>mkdir<span class="o">]</span> Created dir: ~/Software/LogMX/LogMX_vx.y.z/parsers/classes
build-dev:
 <span class="o">[</span>javac<span class="o">]</span> Compiling <span class="m">1</span> <span class="nb">source</span> file to ~/Software/LogMX/LogMX_vx.y.z/parsers/classes
BUILD SUCCESSFUL
Total time: <span class="m">2</span> seconds
</pre>
<p>This should imply that <tt class="docutils literal">CeylanTraceParser.class</tt> has been successfully built.</p>
<p>Test the result like explained before, in <a class="reference internal" href="#checking-that-the-sim-diasca-parser-works-properly">Checking That The Sim-Diasca Parser Works Properly</a>.</p>
</div>
</div>
</div>
</div>
<div class="section" id="enabling-the-python-binding-if-needed-installing-erlport">
<h1><a class="toc-backref" href="#id56">Enabling the Python binding if needed: installing <tt class="docutils literal">ErlPort</tt></a></h1>
<p>In the context of the evaluation of a dataflow, some simulation actors may be implemented in <a class="reference external" href="https://www.python.org/">Python</a>, in which case the (fully-optional) Python dataflow binding shall be enabled (see the <tt class="docutils literal">USE_PYTHON_BINDING</tt> variable in <tt class="docutils literal">myriad/GNUmakevars.inc</tt> for that). One should skip this section if not planning to use Python-based (dataflow) actors.</p>
<div class="section" id="python-configuration">
<h2><a class="toc-backref" href="#id57">Python Configuration</a></h2>
<p>Python 3 (<tt class="docutils literal">3.5.2</tt> or newer) is required here, and - as for the other runtime dependencies - must thus be available on the target system (i.e. on the user host and also on all additional computing hosts - if any).</p>
<p>Often, on a given host (typically a computing one), multiple generations of Python coexist (Python 2 or 3), as well as multiple versions thereof (ex: 3.5.2, 3.6.3, etc.).</p>
<p>We leave the choice of the actual Python version to be used by the engine up to the developer, who can select it by creating a symbolic link named <tt class="docutils literal"><span class="pre">python-for-sim-diasca</span></tt> that should point to the Python version of interest, and be found from the default user PATH.</p>
<p>For example one may create such a symbolic link in a <tt class="docutils literal">~/Software/bin</tt> that would be declared in the <tt class="docutils literal">PATH</tt> environment variable, like in:</p>
<pre class="code bash literal-block">
$ mkdir -p ~/Software/bin
$ <span class="nb">cd</span> ~/Software/bin

$ ln -s ~/Software/Python/Python-3.6.3-current-install/bin/python3.6
          python-for-sim-diasca
  or
$ ln -s /usr/bin/python3 python-for-sim-diasca
</pre>
<p>Then <tt class="docutils literal"><span class="pre">~/.bashrc</span></tt> would be updated with:</p>
<pre class="code bash literal-block">
<span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span>~/Software/bin:<span class="si">${</span><span class="nv">PATH</span><span class="si">}</span>
</pre>
</div>
<div class="section" id="erlport-installation">
<h2><a class="toc-backref" href="#id58">ErlPort Installation</a></h2>
<p>As this binding relies on <a class="reference external" href="http://erlport.org/">ErlPort</a>, this dependency must be installed beforehand. We currently rely on the original codebase (not on one of the forks thereof).</p>
<p>Our guidelines recommend that it is located in the <tt class="docutils literal">~/Software/ErlPort</tt> directory, and that an <tt class="docutils literal"><span class="pre">ErlPort-current-install</span></tt> symbolic link points to it.</p>
<p>Knowing that the actual installation directory <em>must</em> be named <tt class="docutils literal">erlport</tt> <a class="footnote-reference" href="#id33" id="id32">[15]</a>, one should target a tree structure such as:</p>
<pre class="code bash literal-block">
$ tree -L <span class="m">1</span> ~/Software/ErlPort
/home/batman/Software/ErlPort
<span class="p">|</span>-- erlport
<span class="sb">`</span>-- ErlPort-current-install -&gt; erlport/
</pre>
<table class="docutils footnote" frame="void" id="id33" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id32">[15]</a></td><td>Otherwise the interpreter initialization on the computing nodes would fail (with the <tt class="docutils literal"><span class="pre">{not_found,&quot;erlport/priv&quot;}</span></tt> error).</td></tr>
</tbody>
</table>
<p>To do so, one can issue the following commands:</p>
<pre class="code bash literal-block">
$ <span class="nv">ERL_PORT_BASE</span><span class="o">=</span>~/Software/ErlPort
$ mkdir -p <span class="si">${</span><span class="nv">ERL_PORT_BASE</span><span class="si">}</span>
$ <span class="nb">cd</span> <span class="si">${</span><span class="nv">ERL_PORT_BASE</span><span class="si">}</span>
<span class="c1"># Circumvent any proxy here.
</span>$ git clone https://github.com/hdima/erlport.git
$ ln -s erlport ErlPort-current-install
$ <span class="nb">cd</span> erlport
<span class="c1"># The SHA1 we currently rely on:
</span>$ git checkout 246b77
</pre>
<p>Another option is to download the <a class="reference external" href="http://erlport.org/downloads/">latest source version</a> of ErlPort directly, as it is usually appropriate.</p>
<p>Then, depending on your version of Python 3.x, typically if it is in the 3.5-3.7 range, it may need a minor code change, located, from the <tt class="docutils literal">erlport</tt> directory, in <tt class="docutils literal">priv/python3/erlport/erlang.py</tt> <a class="footnote-reference" href="#id35" id="id34">[16]</a>.</p>
<table class="docutils footnote" frame="void" id="id35" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id34">[16]</a></td><td>We have our own version of this file that <em>should</em> manage most, if not all, Python 3.x versions, to be found in the <tt class="docutils literal"><span class="pre">sim-diasca/src/core/services/bindings/python/</span></tt> (just replace,in <tt class="docutils literal">erlport/priv/python3/erlport</tt>, the original <tt class="docutils literal">erlang.py</tt> with this one then).</td></tr>
</tbody>
</table>
<p>Indeed the line near the top reading as:</p>
<pre class="code python literal-block">
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">getargspec</span>
</pre>
<p>may have, for these very specific versions of Python, to be replaced with:</p>
<pre class="code python literal-block">
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">getfullargspec</span>
</pre>
<p>With the current versions of Erlang, another simple change is needed (in order to properly support stacktraces), in <tt class="docutils literal">src/erlport.erl</tt>, according to following diff:</p>
<pre class="code diff literal-block">
<span class="gd">-        Type:Reason -&gt;
-            Trace = erlang:get_stacktrace(),
-            {error, {erlang, Type, Reason, Trace}}
</span><span class="gi">+        Type:Reason:StackTrace -&gt;
+             {error, {erlang, Type, Reason, StackTrace}}</span>
</pre>
<p>Then, still from the <tt class="docutils literal">erlport</tt> root directory, one may run: <tt class="docutils literal">make</tt> to enable the Python support.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>We supposed above that ErlPort was to be installed in <tt class="docutils literal">~/Software/ErlPort/erlport</tt>.</p>
<p>Should another convention be preferred, then the <tt class="docutils literal">ERLPORT_BASE_DIR</tt> environment variable shall be defined in order to point to the actual directory to use.</p>
<p class="last">So, as an example, one may add in one's <tt class="docutils literal"><span class="pre">~/.bashrc</span></tt> the following line: <tt class="docutils literal">export <span class="pre">ERLPORT_BASE_DIR=/opt/ErlPort/erlport</span></tt>.</p>
</div>
<p>To test the proper Python support, one should refer to the <tt class="docutils literal"><span class="pre">Sim-Diasca</span> Dataflow HOWTO</tt> document.</p>
</div>
</div>
<div class="section" id="checking-which-tools-sim-diasca-will-use">
<h1><a class="toc-backref" href="#id59">Checking Which Tools Sim-Diasca Will Use</a></h1>
<p>It is mandatory to have Sim-Diasca know where the tools it needs can be found. To check which main tools would be used, run from the <tt class="docutils literal"><span class="pre">sim-diasca</span></tt> directory:</p>
<pre class="code bash literal-block">
$ make info-tools
<span class="nv">ERLANG_INTERPRETER</span> <span class="o">=</span> ~/Software/Erlang/Erlang-current-install/bin/erl
<span class="nv">ERLANG_COMPILER</span> <span class="o">=</span> ~/Software/Erlang/Erlang-current-install/bin/erlc
<span class="nv">LOGMX</span> <span class="o">=</span> ~/Software/LogMX/LogMX-current-install/logmx.sh
</pre>
<p>Some tools will be only used by this <tt class="docutils literal">make</tt> system, whereas others, the majority of them (ex: the Erlang interpreter and compiler) will be used by the simulator as well.</p>
<p>Therefore the path to the former ones could be set directly in the makefiles only. However it is generally more convenient that the latter ones are found directly from the shell environment, so that both the Make system <em>and</em> the simulator will find them with the same correct versions.</p>
<p>If a <tt class="docutils literal">make</tt>-only tool is lacking, edit the <tt class="docutils literal">GNUmakevars.inc</tt> file of the relevant package (ex: the one of <tt class="docutils literal">myriad</tt>, <tt class="docutils literal">wooper</tt>, <tt class="docutils literal">traces</tt>, <tt class="docutils literal"><span class="pre">sim-diasca</span></tt>, etc.) accordingly.</p>
<p>If another tool is lacking, then the shell environment should be updated. This involves updating - most preferably, once for all - the PATH environment variable.</p>
<p>This can be done by adding <tt class="docutils literal"><span class="pre">PATH=/a/path/to/a/lacking/tool:$PATH</span></tt> to the shell init file (ex: <tt class="docutils literal"><span class="pre">~/.bashrc</span></tt>) and sourcing it again (<tt class="docutils literal">. <span class="pre">~/.bashrc</span></tt>).</p>
<p>Re-run <tt class="docutils literal">make <span class="pre">info-tools</span></tt> and apply changes until the <tt class="docutils literal">make</tt> system selects the exact tool versions you want.</p>
<p></p>
</div>
<div class="section" id="building-sim-diasca">
<h1><a class="toc-backref" href="#id60">Building Sim-Diasca</a></h1>
<p>The good news is that Sim-Diasca is written in Erlang, thus it requires to be compiled:</p>
<p><span class="raw-html"><center><img src="xkcd-compiling.png" id="responsive-image-small"></img></center></span>
</p>
<p>The bad news is that it will not take long, only up to a few minutes, as it is itself parallel on each package.</p>
<p>It is just a matter of running <tt class="docutils literal">make</tt> from the Sim-Diasca source root, i.e. its base directory, which contains the <tt class="docutils literal">myriad</tt>, <tt class="docutils literal">wooper</tt>, <tt class="docutils literal">traces</tt>, etc. directories.</p>
<p>If using a clone, go to this root typically by entering <tt class="docutils literal">cd <span class="pre">sim-diasca-clone</span></tt>. If using a file release, it will be: <tt class="docutils literal">cd <span class="pre">Sim-Diasca-clone</span></tt>.</p>
<p>Then:</p>
<pre class="code bash literal-block">
$ make all
Building all, sequentially, in <span class="o">[</span>..<span class="o">]</span>/Sim-Diasca-clone
Building all, in parallel over <span class="m">8</span> cores, from <span class="o">[</span>..<span class="o">]</span>/myriad
Building all in <span class="o">[</span>..<span class="o">]</span>/Sim-Diasca-clone/myriad/contrib
Building all in <span class="o">[</span>..<span class="o">]</span>/Sim-Diasca-clone/myriad/src
           Compiling module hashtable.erl
           Compiling module hashtable_test.erl
           Compiling module hashtables_comparison_test.erl
<span class="o">[</span>...<span class="o">]</span>
Building all, in parallel over <span class="m">8</span> cores, from <span class="o">[</span>..<span class="o">]</span>/wooper
<span class="o">[</span>...<span class="o">]</span>
Building all, in parallel over <span class="m">8</span> cores, from <span class="o">[</span>..<span class="o">]</span>/traces
<span class="o">[</span>...<span class="o">]</span>
Building all, in parallel over <span class="m">8</span> cores, from <span class="o">[</span>..<span class="o">]</span>/sim-diasca
<span class="o">[</span>...<span class="o">]</span>
Building all, in parallel over <span class="m">8</span> cores, from <span class="o">[</span>..<span class="o">]</span>/mock-simulators
<span class="o">[</span>...<span class="o">]</span>
</pre>
<p>Then <strong>you should have a version of Sim-Diasca properly built, and fully able to run, locally or not</strong>.</p>
<p>However, should multiple computing hosts be used, a few system-level checks shall be performed first, to ensure that the distributed mode of operation is correctly enabled - as discussed in the next section.</p>
<p id="domain-configuration">Just before, a note about what we believe is a rather common network misconfiguration of too many Linux computers, which may impact even local, single-host simulations <a class="footnote-reference" href="#id37" id="id36">[17]</a>: one should ensure that, if FQDN hostnames are associated to IPs for the local host in <tt class="docutils literal">/etc/hosts</tt> (ex: <tt class="docutils literal">127.0.1.1 hurricane.foobar.org hurricane</tt>), their domain matches the one (if any) specified in <tt class="docutils literal">/etc/resolv.conf</tt>.</p>
<p>Often one can see there <tt class="docutils literal">domain localdomain</tt> (instead of, say, <tt class="docutils literal">domain foobar.org</tt>), which may lead to resolve the local FQDN as <tt class="docutils literal">hurricane.localdomain</tt> instead of <tt class="docutils literal">hurricane.foobar.org</tt> (which may be a problem at least for the Erlang VM).</p>
<table class="docutils footnote" frame="void" id="id37" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id36">[17]</a></td><td>The network configuration still plays a role even in a non-distributed mode of operation, as the user node is to launch, on that same given host, a computing node, and this spawned one is to connect back to the user node by designating it with either just a node name (ex: <tt class="docutils literal">my_user_node</tt>) or with a node name <em>and</em> a (local, here) hostname (ex: <tt class="docutils literal">my_user_node&#64;LOCAL_HOSTNAME</tt>). A problem with the aforementioned discrepancy is that, if we just specify <tt class="docutils literal">my_user_node</tt>, it will be expanded by the VM in <tt class="docutils literal">my_user_node&#64;hurricane.localdomain</tt> instead of <tt class="docutils literal">my_user_node&#64;hurricane.foobar.org</tt>, and that computing node will never be seen by the user node.</td></tr>
</tbody>
</table>
<p></p>
</div>
<div class="section" id="enabling-the-distributed-mode-of-operation">
<h1><a class="toc-backref" href="#id61">Enabling The Distributed Mode Of Operation</a></h1>
<p>A key point of scalability lies in the possibility of harnessing distributed resources.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Should Sim-Diasca be run only locally (i.e. on the current computer), this section can be safely skipped.</p>
</div>
<p>In a distributed context, Sim-Diasca must be able to make use of the computing resources available in other networked hosts.</p>
<p>To do so, the Sim-Diasca agents must be already running - and thus be already installed - on each of the targeted hosts before a simulation relying on them is run.</p>
<p>Of course, the user could log on each of these hosts, and install then launch manually the agents needed, however this process would be quite cumbersome and could not scale up. Sim-Diasca can fully perform this deployment task on the user's behalf instead (installation and execution), if proper settings are used. Then it is sufficient either to list the candidate hosts that can be used, or to run the higher-level cluster scripts that we provide (for which the amount of processing resources required has just to be specified).</p>
<p>One has mainly to ensure that the network is correctly configured and that, with one's account, a SSH password-less login can be performed from the current computer to all targeted remote hosts, which are expected to already have an Erlang environment directly available.</p>
<p>From now on, the <em>user node</em> will designate the Erlang node from which the user will run the simulation (ex: the one created when issuing a command like <tt class="docutils literal">make my_simulation_run</tt> from the user shell). That Erlang node will never take part directly to the computing. However, depending on the simulation settings, the <em>host</em> this node runs on may or may not be used as a computing resource, thanks to the automatic creation of another (local, simulation-dedicated) computing node.</p>
<p>One can also refer to the <em>distributed cheat sheet</em> of the <em>Sim-Diasca Technical Manual</em> for further guidance.</p>
<div class="section" id="basic-network-configuration">
<h2><a class="toc-backref" href="#id62">Basic Network Configuration</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Sim-Diasca will check automatically all the points discussed in this section, whose purpose is only to inform the reader and to provide some guidelines, should a check determine that the network is not properly configured.</p>
</div>
<div class="section" id="interconnectivity">
<h3>Interconnectivity</h3>
<p>All hosts able to take part to a (distributed) simulation should be able to reach all other hosts thanks to the network.</p>
<p>To check that at least a basic interconnectivity is available, Sim-Diasca will ping all eligible hosts from the user host, and retain only the alive ones (i.e. hosts that cannot be ping'ed are deemed not available for the simulation) <a class="footnote-reference" href="#id39" id="id38">[18]</a>.</p>
<table class="docutils footnote" frame="void" id="id39" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id38">[18]</a></td><td>Note however that we could imagine that the user host pings successfully <tt class="docutils literal">h1</tt> and  <tt class="docutils literal">h2</tt>, while <tt class="docutils literal">h1</tt> is still not able to communicate with <tt class="docutils literal">h2</tt>. However such awkward network configuration issues seldom occur, and any non fully-meshed connectivity would be detected later, at simulation-time.</td></tr>
</tbody>
</table>
<p>Once this <em>host</em> interconnectivity is established, <em>node</em> interconnectivity is automatically checked further.</p>
</div>
<div class="section" id="name-resolving">
<h3>Name Resolving</h3>
<p>Each computing host should, in terms of network, be correctly configured.</p>
<p>Notably, for an host whose fully qualified DNS name is expected to be <tt class="docutils literal">hurricane.foobar.org</tt>, one should have indeed:</p>
<pre class="code bash literal-block">
$ hostname
hurricane

$ hostname -f
hurricane.foobar.org
</pre>
<p>In the latter case, returned values such as <tt class="docutils literal">localhost.localdomain</tt> or <tt class="docutils literal">localhost</tt> mean that the host will not be able to take part to a networked simulation.</p>
<p>Usually this configuration can be fixed if having root permissions. The <tt class="docutils literal">/etc/hosts</tt> file should indeed have a line similar to:</p>
<pre class="code bash literal-block">
<span class="m">127</span>.0.0.1 hurricane.foobar.org hurricane localhost.localdomain localhost
</pre>
<p>Note the order: the fully qualified DNS name (<tt class="docutils literal">hurricane.foobar.org</tt>) should be the first entry listed after the <tt class="docutils literal">127.0.0.1</tt> IP, otherwise the networked mode of operation of Erlang may not be activated.</p>
</div>
<div class="section" id="security">
<h3>Security</h3>
<p>All nodes created by Sim-Diasca will be given the unique cookie forged (based in a custom-generated UUID) by the user node. So no two simulations can collide, even if the same case is run by the same user on the same set of computers.</p>
</div>
</div>
<div class="section" id="password-less-authentication">
<h2><a class="toc-backref" href="#id63">Password-less Authentication</a></h2>
<p>This can be done with SSH quite simply, without requiring specific permissions <a class="footnote-reference" href="#id41" id="id40">[19]</a>, but thanks to a proper configuration.</p>
<p>Let's suppose a user <tt class="docutils literal">foobar</tt> on host <tt class="docutils literal">host_a.foobar.org</tt> wants to set-up password-less connections to <tt class="docutils literal">host_b.foobar.org</tt> (supposedly with the same username).</p>
<table class="docutils footnote" frame="void" id="id41" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id40">[19]</a></td><td>Provided that the SSH server running on the target host allows it (see the <tt class="docutils literal">PubkeyAuthentication yes</tt> entry in the <tt class="docutils literal">/etc/ssh/sshd_config</tt> file); it is generally the case.</td></tr>
</tbody>
</table>
<p><tt class="docutils literal">foobar</tt> just has to generate, when logged on <tt class="docutils literal">host_a.foobar.org</tt>, a key pair with:</p>
<pre class="code bash literal-block">
foobar&#64;host_a.foobar.org$ ssh-keygen -t rsa
Generating public/private rsa key pair.
Enter file in which to save the key <span class="o">(</span>/home/foobar/.ssh/id_rsa<span class="o">)</span>:
Enter passphrase <span class="o">(</span>empty <span class="k">for</span> no passphrase<span class="o">)</span>:
Enter same passphrase again:
Your identification has been saved in /home/foobar/.ssh/id_rsa.
Your public key has been saved in /home/foobar/.ssh/id_rsa.pub.
The key fingerprint is: XX:XX:XX... foobar&#64;host_a.foobar.org
</pre>
<p>It generates a private key (<tt class="docutils literal"><span class="pre">~/.ssh/id_rsa</span></tt>, which shall be kept as is) and a public one (<tt class="docutils literal"><span class="pre">~/.ssh/id_rsa.pub</span></tt>, which can be freely shared).</p>
<p>The user then just has to register that public key to <tt class="docutils literal">host_b.foobar.org</tt>.</p>
<p>On GNU/Linux this can be done simply thanks to:</p>
<pre class="code bash literal-block">
foobar&#64;host_a.foobar.org$ ssh-copy-id -i <span class="se">\
</span>   ~/.ssh/id_rsa.pub host_b.foobar.org
</pre>
<p>If the above command fails or is not available, then the following procedure should be used.</p>
<p>First the public key must be transferred to the remote host:</p>
<pre class="code bash literal-block">
foobar&#64;host_a.foobar.org$ scp ~/.ssh/id_rsa.pub <span class="se">\
</span>  foobar&#64;host_b.foobar.org:/home/foobar/.ssh/id_rsa-from-host_a.pub
</pre>
<p>Then it just has to be declared as authorised on that remote host, with the proper permissions:</p>
<pre class="code bash literal-block">
foobar&#64;host_b.foobar.org$ cat /home/foobar/.ssh/id_rsa-from-host_a.pub <span class="se">\
</span>   &gt;&gt; /home/foobar/.ssh/authorized_keys
foobar&#64;host_b.foobar.org$ chmod <span class="m">600</span> /home/foobar/.ssh/authorized_keys
foobar&#64;host_b.foobar.org$ chmod <span class="m">700</span> /home/foobar/.ssh
</pre>
<p>Once either of the two approaches succeeded, with a basic proper configuration of the SSH server, the login to the remote host should be performed without needing a password:</p>
<pre class="code bash literal-block">
foobar&#64;host_a.foobar.org$ ssh host_b.foobar.org
last login: XXX
foobar&#64;host_b.foobar.org$
</pre>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p>Each time a computing host that has never been used previously is added, one should preferably attempt first to perform from the command line a connection from the user host to this new host, in order to ensure that no interactive acknowledgement is needed.</p>
<p>For example, following message could be prompted once (some measures have been taken to avoid it, though):</p>
<pre class="code literal-block">
The authenticity of host 'Server (XXXXX)' can't be established. RSA key
fingerprint is YYYYY. Are you sure you want to continue connecting (yes/no)?
</pre>
<p class="last">Just answer yes (once for all).</p>
</div>
<p>Note finally that when using multiple computing nodes, all nodes should be able to connect to all nodes. More precisely, the first constraint is actually that the host on which the deployment manager will be run (i.e. the user node) should be able to connect by SSH to all other hosts (to spawn the remote computing nodes).</p>
<p>Then, once the deployment phase is over, the load balancer may spawn a model instance on any of the computing nodes, and two model instances may interact (between them and with the various simulation services) regardless of their respective actual locations. Therefore a fully-meshed network connectivity (everyone to everyone) is needed.</p>
<p>Note also that, notably for the sake of homogeneity, if the host from which the user launched the simulation has been listed among the eligible computing hosts, then another node will be created on the same host (an additional computing node), rather than reusing that launching (user) node as a computing one. No SSH connection between these two local nodes will be attempted, they will be directly interconnected.</p>
<p>Finally, for an host named <tt class="docutils literal">foo.bar.org</tt>, a simple test allows to check both the SSH configuration and the availability of an Erlang environment. One should just run for each of the computing host:</p>
<pre class="code bash literal-block">
$ ssh -q foo.bar.org erl -eval <span class="se">\
</span>   <span class="s1">'&quot;io:format( \&quot;This host would use Erlang version ~s.~n\&quot;, \
   [erlang:system_info(otp_release)]), erlang:halt().&quot;'</span>

Eshell V7.3  <span class="o">(</span>abort with ^G<span class="o">)</span>
This host would use Erlang version <span class="m">18</span>.
</pre>
<p>In that case, this host should be able to take part to the simulation, provided the firewall policy does not prevent it <a class="footnote-reference" href="#id43" id="id42">[20]</a>.</p>
<table class="docutils footnote" frame="void" id="id43" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id42">[20]</a></td><td>Note that Sim-Diasca provides a way of specifying a non-standard EPMD port and a range of allowed TCP ports (see <tt class="docutils literal">FIREWALL_OPT</tt> in <tt class="docutils literal">myriad/GNUmakevars.inc</tt> or, preferably, the <tt class="docutils literal">firewall_restrictions</tt> field of the <tt class="docutils literal">deployment_settings</tt> record). However the usual practice, and by far safest, is to avoid the use of specific firewall policies between internal hosts: there are already plenty of reasons for a distributed application to experience runtime issues, no need to add more potential problems.</td></tr>
</tbody>
</table>
<p>Note also that the Sim-Diasca host configuration file allows to specify which UNIX user should be used on which host (as one may use different logins on different hosts).</p>
</div>
<div class="section" id="managing-the-simulator-codebase">
<h2><a class="toc-backref" href="#id64">Managing the Simulator Codebase</a></h2>
<p>In a distributed context, the proper code (software) must of course be available on each of the computing hosts, so that this host is able to run a part of the simulation.</p>
<p>However installing manually everything on each host would be soon strenuous, error-prone, and could happen many times (ex: when fine-tuning some models).</p>
<p>With Sim-Diasca, the only prerequisite that must be available on a host before this host is able to take part to a simulation are:</p>
<ul class="simple">
<li>having a proper configuration of the computing host, as already described (notably regarding network and SSH)</li>
<li>and having a proper Erlang environment available on that host (i.e. <tt class="docutils literal">erl</tt> must be directly found on the shell after a non-interactive login), preferably installed once for all with the <tt class="docutils literal"><span class="pre">myriad/conf/install-erlang.sh</span></tt> script we provide, or installed globally on the mount point of a distributed filesystem (typically NFS)</li>
</ul>
<p>Then Sim-Diasca is able to launch automatically the proper agents on each of the selected computing hosts, and to transfer and set up on that host not only the simulation models to be used (both their code and data), but also its own code and prerequisites as well (i.e. the <tt class="docutils literal">myriad</tt>, <tt class="docutils literal">wooper</tt>, <tt class="docutils literal">traces</tt> and <tt class="docutils literal"><span class="pre">sim-diasca</span></tt> packages).</p>
<p>So Sim-Diasca provides an automatic deployment system for the full simulator.</p>
<p>Such a deployment is based on a deployment archive (a <tt class="docutils literal">.sdar</tt> file, for <em>Sim-Diasca archive</em> - a compressed, binary file automatically sent over the network), which can be either prebuilt once and then just specified to each Sim-Diasca run, or that can be automatically built on the fly by Sim-Diasca, from the build tree it is run from on the user node (this latter case is the default one).</p>
</div>
<div class="section" id="miscellaneous">
<h2><a class="toc-backref" href="#id65">Miscellaneous</a></h2>
<p>One should ensure that the <tt class="docutils literal">/tmp</tt> directory is writable by the user on each computing node, and that sufficient free space is available.</p>
</div>
<div class="section" id="cleaning-up">
<h2><a class="toc-backref" href="#id66">Cleaning Up</a></h2>
<p>Under some circumstances (ex: a model-level failure encountered during a simulation), some pending nodes, created by the deployment manager, may linger on a computing host; this should not be an issue, as the next launching of Sim-Diasca will wipe them out.</p>
<p>To remove them manually, the <em>Erlang Port Mapper Daemon</em> can be used, just run on that host:</p>
<pre class="code bash literal-block">
$ epmd -kill
</pre>
<p>Note that launched nodes are, except on some error cases, automatically cleaned up and shut down by Sim-Diasca on simulation termination.</p>
<p>Should a simulation crash prevent this removal, all pending nodes will stop by themselves after a time-out.</p>
<p>Additionally, each time a simulation is run, by default it will start by attempting to remove any still lingering node it would detect.</p>
<p>Finally, should a new simulation be started whereas such pending nodes are still alive (despite the counter-measures taken), the simulation will detect this abnormal situation (based on the run-specific UUID that is generated first), and will exclude the corresponding hosts from that run.</p>
<p></p>
</div>
</div>
<div class="section" id="testing-sim-diasca">
<h1><a class="toc-backref" href="#id67">Testing Sim-Diasca</a></h1>
<p>Several test cases that can be run to experiment with Sim-Diasca: when a class <tt class="docutils literal">X</tt> is defined (in <tt class="docutils literal">class_X.erl</tt>), it is recommended to add a corresponding unitary test case (in <tt class="docutils literal">class_X_test.erl</tt>).</p>
<p>To run such a test, once Sim-Diasca has been successfully built, one just has to go to the directory where that test is defined, and to run <tt class="docutils literal">make class_X_run</tt>: the Sim-Diasca Make system will take care of compiling this test if needed and run it with an appropriately-configured Erlang interpreter.</p>
<p>For example, if wanting to run a Sim-Diasca built-in soda-vending test:</p>
<pre class="code bash literal-block">
$ <span class="nb">cd</span> mock-simulators/soda-test/src
$ make
$ make demo-batch
</pre>
<p>Your console should be filled by much text similar to:</p>
<pre class="code bash literal-block">
$ make demo-batch

make<span class="o">[</span><span class="m">1</span><span class="o">]</span>: Entering directory <span class="s1">'A_ROOT_DIR/mock-simulators/soda-test/src'</span>
       Running unitary <span class="nb">test</span> soda_stochastic_integration_run <span class="o">(</span>third form<span class="o">)</span>
       from soda_stochastic_integration_test
Launching the Erlang VM in non-distributed mode.
Erlang/OTP <span class="m">19</span> <span class="o">[</span>erts-8.1<span class="o">]</span> <span class="o">[</span>source<span class="o">]</span> <span class="o">[</span><span class="m">64</span>-bit<span class="o">]</span> <span class="o">[</span>smp:8:8<span class="o">]</span> <span class="o">[</span>async-threads:128<span class="o">]</span>
<span class="o">[</span>hipe<span class="o">]</span> <span class="o">[</span>kernel-poll:true<span class="o">]</span>

Eshell V8.1  <span class="o">(</span>abort with ^G<span class="o">)</span>

<span class="m">1</span>&gt;
Simulation instance identifier is <span class="s1">'46672710'</span>.
Simulation trace file is
<span class="s1">'Soda_Stochastic_Integration_Test-by-dalton-46672710.traces'</span><span class="p">;</span>
no interactive supervision requested.

The single specified computing host is available, using corresponding
node: <span class="s1">'Sim-Diasca-Soda_Stochastic_Integration_Test-dalton-46672710-computing-node&#64;foobar.org'</span>.

Use cookie <span class="s1">'315bf70c-b6f1-4ff2-be23-f85832c08c31'</span> to connect to the
nodes <span class="o">(</span>user or computing ones<span class="o">)</span>.

<span class="o">[</span>...<span class="o">]</span>

<span class="o">[</span>Trace Aggregator<span class="o">]</span> Aggregator deleted.
End of <span class="k">case</span> soda_stochastic_integration_test
<span class="o">(</span><span class="k">case</span> finished, interpreter halted<span class="o">)</span>
make<span class="o">[</span><span class="m">1</span><span class="o">]</span>: Leaving directory <span class="s1">'A_ROOT_DIR/mock-simulators/soda-test/src'</span>
</pre>
<p>Congratulations, a full simulation case just ran successfully!</p>
<p>One may then go one step further and test also a non-batch, more graphical mode of operation by running:</p>
<pre class="code bash literal-block">
$ make demo
</pre>
<p>Three windows should pop up <a class="footnote-reference" href="#id45" id="id44">[21]</a>:</p>
<ul class="simple">
<li>a first <tt class="docutils literal">Geeqie/Gqview</tt> window, displaying the two simulation results (two time series) as graphs (plots), representing the number over time of cans available in each of the two soda vending machines</li>
<li>a second <tt class="docutils literal">Geeqie/Gqview</tt> window, displaying the measures aggregated by the performance tracker (resource consumption, number of instance per node, etc.), if this service is enabled (true by default)</li>
<li>a <tt class="docutils literal">LogMX</tt> console, for the supervision of the distributed simulation traces (if traces are enabled, which is true by default)</li>
</ul>
<table class="docutils footnote" frame="void" id="id45" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id44">[21]</a></td><td>When running a test from the command line, simulation results are displayed, whereas when the same test is run as part of a test suite, its outputs are generated but not displayed, since it must be run in batch (i.e. silently). Note that how tests are run regarding their outputs is unrelated to the operation mode of the time manager (batch or interactive mode).</td></tr>
</tbody>
</table>
<p>When not useful any more, all windows can be safely closed. The end of the simulation session occurs when the trace supervision window is closed.</p>
<p>Should a problem arise, please have a look at the <em>Sim-Diasca Troubleshooting</em> section of the <em>Sim-Diasca Technical Manual</em>.</p>
<p>To further discover how Sim-Diasca works and can be used, the next steps could be to peer in the source code of tests and of classes, before playing around and adding some toy models.</p>
</div>
<div class="section" id="installing-sim-diasca">
<h1><a class="toc-backref" href="#id68">Installing Sim-Diasca</a></h1>
<p>This completely optional action (that is generally not needed) allows to install all Sim-Diasca related packages (i.e. the <tt class="docutils literal">Myriad</tt>, <tt class="docutils literal">WOOPER</tt>, etc. packages), and Sim-Diasca itself, out of the build tree.</p>
<p>To do so, one just has to execute, from the top source directory (the one that contains the top-level directories like <tt class="docutils literal"><span class="pre">sim-diasca</span></tt>, <tt class="docutils literal">wooper</tt>, etc.):</p>
<pre class="code bash literal-block">
$ make install
</pre>
<p>In this case everything will be installed in the default <tt class="docutils literal">~/Software</tt> directory, which will be created if not existing already.</p>
<p>The user can specify any other installation directory instead, by defining the <tt class="docutils literal">INSTALLATION_PREFIX</tt> variable, like in:</p>
<pre class="code bash literal-block">
$ make install <span class="nv">INSTALLATION_PREFIX</span><span class="o">=</span>/opt/my-simulator
</pre>
<p>In all cases, under the installation directory, all Sim-Diasca related packages will be properly installed, mostly according to the Erlang recommended practices (i.e. with a hierarchy based on standard nested directories like <tt class="docutils literal">ebin</tt>, <tt class="docutils literal">examples</tt>, <tt class="docutils literal">include</tt>, <tt class="docutils literal">src</tt>, <tt class="docutils literal">test</tt>, etc.).</p>
</div>
<div class="section" id="credits">
<h1><a class="toc-backref" href="#id69">Credits</a></h1>
<p>Special thanks to <strong>Randall Munroe</strong> who is the author of all the comic strips that enliven this documentation, and who kindly allowed their use in this material.</p>
<p>See his <a class="reference external" href="http://xkcd.com/">XKCD</a> website for all information, including for all his delightful other strips.</p>
<p></p>
</div>
<div class="section" id="please-react">
<h1><a class="toc-backref" href="#id70">Please React!</a></h1>
<p>If you have information more detailed or more recent than those presented in this document, if you noticed errors, neglects or points insufficiently discussed, drop us a line! (for that, follow the <a class="reference internal" href="#support">Support</a> guidelines).</p>
</div>
<div class="section" id="support">
<h1><a class="toc-backref" href="#id71">Support</a></h1>
<p>Bugs, questions, remarks, patches, requests for enhancements, etc. regarding the installation procedure are to be reported to the <a class="reference external" href="https://github.com/Olivier-Boudeville-EDF/Sim-Diasca">project interface</a> (typically <a class="reference external" href="https://github.com/Olivier-Boudeville-EDF/Sim-Diasca/issues">issues</a>) or directly at the email address mentioned at the beginning of this document.</p>
</div>
<div class="section" id="ending-word">
<h1><a class="toc-backref" href="#id72">Ending Word</a></h1>
<p>We hope that the installation went smooth!</p>
<p>Now is maybe a good time to run some examples found in the <tt class="docutils literal"><span class="pre">mock-simulators</span></tt> tree (located at the root of the Sim-Diasca clone) - typically a <tt class="docutils literal"><span class="pre">soda-test</span></tt>?</p>
<p><span class="raw-html"><center><img src="sim-diasca.png" id="responsive-image-small"></img></center></span>
</p>
<p><span class="raw-html"><a name="sim_diasca_bottom"></a></span></p>
<p><span class="raw-html"><a name="sim_diasca_bottom"></a></span></p>
</div>
</div>
</body>
</html>
